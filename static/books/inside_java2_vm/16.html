<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>16 Control Flow | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>16 Control Flow</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="15.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="17.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr> <h2> Control Flow </h2> <p> This chapter describes the instructions that cause the Java Virtual Machine to conditionally or unconditionally branch to a different location within the same method. This includes the instructions that implement the <code> if </code> , <code> if-else </code> , <code> while </code> , <code> do-while </code> , <code> for </code> , and <code> switch </code> statements of Java source code. </p> <p> Accompanying this chapter on the CD-ROM is an applet that interactively illustrates the material presented in the chapter. The applet, named <i> Saying Tomato </i> , simulates the Java Virtual Machine executing a method that includes bytecodes that perform table jumps (the compiled version of a <code> switch </code> statement in Java source code). At the end of this chapter, you will find a description of this applet and the bytecodes it executes. </p> <p> <i> Conditional Branching </i> </p> <p> In Java source code, you specify basic control-flow within a method with <code> if </code> , <code> if-else </code> , <code> while </code> , <code> do-while </code> , <code> for </code> , and <code> switch </code> statements. With the exception of switch, Java compilers draw from the same set of opcodes when translating all of these source code constructs to bytecodes. For example, the simplest control-flow construct Java offers is the <code> if </code> statement. When a Java program is compiled, the <code> if </code> statement may be translated to any one of a variety of opcodes, depending upon the nature of the <code> if </code>'s expression. Each opcode either pops one or two values from the top of the stack and does a comparison. The opcodes that pop only one value compare that value with zero. The opcodes that pop two values compare one with the other. If the comparison succeeds (success is defined differently by each individual opcode), the Java Virtual Machine branches--or jumps--to the offset given as an operand to the comparison opcode. </p> <p> For each of the conditional branch opcodes, the Java Virtual Machine follows the same procedure to determine the next instruction to execute. The virtual machine first performs the comparison specified by the opcode. If the comparison fails, the virtual machine continues execution with the instruction that immediately follows the conditional branch instruction. If the comparison succeeds, the virtual machine forms a signed 16-bit offset from two operand bytes that trail the opcode. It adds the offset to the contents of the current pc register (the address of the conditional branch opcode) to get the target address. The target address must point to an opcode of an instruction in the same method. Execution continues as the target address. </p> <p> One family of <code> if </code> opcodes, shown in Table 16-1, performs integer comparisons against zero. When the Java Virtual Machine encounters one of these opcodes, it pops one <code> int </code> off the stack and compares it with zero. </p> <p> Table 16-1. Conditional branch: integer comparison with zero </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> ifeq </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value, if value == 0, branch to offset </td> </tr> <tr> <td valign="top"> <code> ifne </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value, if value != 0, branch to offset </td> </tr> <tr> <td valign="top"> <code> iflt </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value, if value &lt; 0, branch to offset </td> </tr> <tr> <td valign="top"> <code> ifle </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value, if value &lt;= 0, branch to offset </td> </tr> <tr> <td valign="top"> <code> ifgt </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value, if value 0, branch to offset </td> </tr> <tr> <td valign="top"> <code> ifge </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value, if value = 0, branch to offset </td> </tr> </tbody> </table> <p> Another family of <code> if </code> opcodes, shown in Table 16-2, pops two integers off the top of the stack and compares them against one another. The virtual machine branches if the comparison succeeds. Just before these opcodes are executed, value2 is on the top of the stack; value1 is just beneath value2. </p> <p> Table 16-2. <strong> Conditional branch: comparison of two integers </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> if_icmpeq </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value2 and value1, if value1 == value2, branch to offset </td> </tr> <tr> <td valign="top"> <code> if_icmpne </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value2 and value1, if value1 != value2, branch to offset </td> </tr> <tr> <td valign="top"> <code> if_icmplt </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value2 and value1, if value1 &lt; value2, branch to offset </td> </tr> <tr> <td valign="top"> <code> if_icmple </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value2 and value1, if value1 &lt;= value2, branch to offset </td> </tr> <tr> <td valign="top"> <code> if_icmpgt </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value2 and value1, if value1 value2, branch to offset </td> </tr> <tr> <td valign="top"> <code> if_icmpge </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop <code> int </code> value2 and value1, if value1 = value2, branch to offset </td> </tr> </tbody> </table> <p> The opcodes shown above in Table 16-2 operate on <code> ints </code> . These opcodes also are used for comparisons of types <code> short </code> , <code> byte </code> , and <code> char </code> ; the Java Virtual Machine always manipulates types smaller than <code> int </code> by first converting them to <code> ints </code> and then manipulating the <code> ints </code> . </p> <p> A third family of opcodes, shown in Table 16-3, takes care of comparisons of the other primitive types: <code> long </code> , <code> float </code> , and <code> double </code> . These opcodes don't cause a branch by themselves . Instead, they push the <code> int </code> value that represents the result of the comparison--0 for equal to, 1 for greater than, and -1 for less than--and then use one of the <code> int </code> compare opcodes introduced above to force the actual branch. </p> <p> Table 16-3. <strong> Comparison of <code> long </code> s, <code> float </code> s, and <code> double </code> s </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> lcmp </code> </td> <td valign="top"> (none) </td> <td valign="top"> pop <code> long </code> value2 and value1, compare, push <code> int </code> result </td> </tr> <tr> <td valign="top"> <code> fcmpg </code> </td> <td valign="top"> (none) </td> <td valign="top"> pop <code> float </code> value2 and value1, compare, push <code> int </code> result </td> </tr> <tr> <td valign="top"> <code> fcmpl </code> </td> <td valign="top"> (none) </td> <td valign="top"> pop <code> float </code> value2 and value1, compare, push <code> int </code> result </td> </tr> <tr> <td valign="top"> <code> dcmpg </code> </td> <td valign="top"> (none) </td> <td valign="top"> pop <code> double </code> value2 and value1, compare, push <code> int </code> result </td> </tr> <tr> <td valign="top"> <code> dcmpl </code> </td> <td valign="top"> (none) </td> <td valign="top"> pop <code> double </code> value2 and value1, compare, push <code> int </code> result </td> </tr> </tbody> </table> <p> The two opcodes for <code> float </code> comparisons ( <em> <code> fcmpg </code> </em> and <em> <code> fcmpl </code> </em> ) differ only in how they handle NaN &nbsp;("not a number"). In the Java Virtual Machine, comparisons of floating-point numbers always fail if one of the values being compared is NaN. If neither value being compared is NaN, both <em> <code> fcmpg </code> </em> and <em> <code> fcmpl </code> </em> instructions push a 0 if the values are equal, a 1 if value1 is greater than value2, and a -1 if value1 is less than value2. But if one or both of the values is NaN, the <em> <code> fcmpg </code> </em> instruction pushes a 1, whereas the <em> <code> fcmpl </code> </em> instruction pushes a -1. Because both of these operands are available, any comparison between two <code> float </code> values can push the same result onto the stack independent of whether the comparison failed because of a NaN. This is also true for the two opcodes that compare <code> double </code> values: <em> <code> dcmpg </code> </em> and <em> <code> dcmpl </code> </em> . </p> <p> A fourth family of <code> if </code> opcodes, shown in Table 16-4, pops one object reference off the top of the stack and compares it with <code> null </code> . If the comparison succeeds, the Java Virtual Machine branches. </p> <p> Table 16-4. <strong> Conditional branch: object reference comparison with <code> null </code> </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> ifnull </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop reference value, if value == null, branches to offset </td> </tr> <tr> <td valign="top"> <code> ifnonnull </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop reference value, if value != null, branches to offset </td> </tr> </tbody> </table> <p> The last family of <code> if </code> opcodes, which is shown in Table 16-5, pops two object references off the stack and compares them with each other. In this case, there are only two comparisons that make sense: "equals" and "not equals." If the references are equal, then they refer to the exact same object on the heap. If not, they refer to two different objects. As with all the other <code> if </code> opcodes, if the comparison succeeds, the Java Virtual Machine branches. </p> <p> Table 16-5. <strong> Conditional branch: comparison of two object references </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> if_acmpeq </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop reference value2 and value1, if value1 == value2, branch to offset </td> </tr> <tr> <td valign="top"> <code> if_acmpne </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pop reference value2 and value1, if value1 != value2, branch to offset </td> </tr> </tbody> </table> <p> <i> <strong> Unconditional Branching </strong> </i> </p> <p> That's all of the opcodes that cause the Java Virtual Machine to branch conditionally. One other family of opcodes, however, causes the virtual machine to branch unconditionally. Not surprisingly, these opcodes, shown in Table 16-6, are called " <em> <code> goto </code> </em> ." To execute a <code> goto </code> instruction, the virtual machine forms a signed 16-bit offset from two operand bytes that follow the <code> goto </code> opcode. (To execute a <code> goto_w </code> instruction, the virtual machine forms a signed 32-bit offset from four operand bytes that follow the <code> goto_w </code> opcode.) The virtual machine adds this offset to the current contents of the pc register. The resulting address must contain an opcode of an instruction in the current method. The virtual machine continues execution at this instruction. </p> <p> Table 16-6. <strong> Unconditional branch </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> goto </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> branch to offset </td> </tr> <tr> <td valign="top"> <code> goto </code> _w </td> <td valign="top"> branchbyte1, branchbyte2, branchbyte3, branchbyte4 </td> <td valign="top"> branch to offset </td> </tr> </tbody> </table> <p> The opcodes shown in Tables 16-1 through 16-6 are sufficient to express in bytecodes the any control flow specified in Java source code with an <code> if </code> , <code> if-else </code> , <code> while </code> , <code> do-while </code> , or <code> for </code> statement. The above opcodes also could be used to express a <code> switch </code> statement, but the Java Virtual Machine's instruction set includes two opcodes specially designed for the <code> switch </code> statement: <em> <code> tableswitch </code> </em> and <em> <code> lookupswitch </code> </em> . </p> <p> <i> <strong> Conditional Branching with Tables </strong> </i> </p> <p> The <code> tableswitch </code> and <code> lookupswitch </code> instructions, shown in Table 16-7, both include one default branch offset and a variable-length set of <code> case </code> value/branch offset pairs. Both instructions pop the key (the value of the expression in the parentheses immediately following the <code> switch </code> keyword) from the stack. The key is compared with all the case values. If a match is found, the branch offset associated with the case value is taken. If no match is found, the default branch offset is taken. </p> <p> The difference between <code> tableswitch </code> and <code> lookupswitch </code> is in how they indicate the case values. The <code> lookupswitch </code> instruction is more general-purpose than <code> tableswitch </code> , but <code> tableswitch </code> is usually more efficient. Both instructions are followed by zero to three bytes of padding--enough so that the byte immediately following the padding starts at an address that is a multiple of four bytes from the beginning of the method. (These two instructions, by the way, are the only ones in the entire Java Virtual Machine instruction set that involve alignment on a greater than one-byte boundary.) For both instructions, the next four bytes after the padding is the default branch offset. </p> <p> After the zero- to three-byte padding and the four-byte default branch offset, the <code> lookupswitch </code> opcode is followed by a four-byte value, <em> npairs </em> , which indicates the number of case value/branch offset pairs that will follow. The case value is an <code> int </code> , which highlights the fact that switch statements in Java require a key expression that is an <code> int </code> , <code> short </code> , <code> char </code> , or <code> byte </code> . If you attempt to use a <code> long </code> , <code> float </code> , or <code> double </code> as a switch key, your program won't compile. The branch offset associated with each case value is another four-byte offset. The value/branch offset pairs must appear in increasing numerical order of case value. </p> <p> In the <code> tableswitch </code> instruction, the zero- to three-byte padding and the four-byte default branch offset are followed by low and high <code> int </code> values. The low and high values indicate the endpoints of a range of case values included in this <code> tableswitch </code> instruction. Following the low and high values are high - low + 1 branch offsets--one branch offset for high, one for low, and one for each integer case value in between high and low. The branch offset for low immediately follows the high value. </p> <p> Thus, when the Java Virtual Machine encounters a <code> lookupswitch </code> instruction, it must check the key against each case value until it finds a match, encounters a case value greater than the key (the values/branch offset pairs are sorted in increasing numerical order of case value), or runs out of case values. If it doesn't find a match, it uses the default branch offset. On the other hand, when the Java Virtual Machine encounters a <code> tableswitch </code> instruction, it can simply check to see if the key is within the range defined by low and high. If not, it takes the default branch offset. If so, it just subtracts low from key to get an offset into the list of branch offsets. This way, it can determine the appropriate branch offset without having to check each case value. </p> <p> Table 16-7. <strong> Table jumping </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> lookupswitch </code> </td> <td valign="top"> &lt;0-3 byte paddefaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, pairs3, npairs4, case value/branch offset pairs... </td> <td valign="top"> pop key, match key with case values, if match found jump to associated branch offset, else jump to default branch offset </td> </tr> <tr> <td valign="top"> <code> tableswitch </code> </td> <td valign="top"> &lt;0-3 byte paddefaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, branch offsets... </td> <td valign="top"> pop key, if not in low/high range jump to default branch offset, else get the (key - low) branch offset and jump </td> </tr> </tbody> </table> <p> Other than the opcodes described above, the only Java Virtual Machine instructions that affect control flow are those that deal with throwing and catching exceptions, finally clauses, and invoking and returning from methods . These opcodes are discussed in later chapters. </p> <p> <i> <strong> Saying Tomato: A Simulation </strong> </i> </p> <p> The <strong> <i> Saying Tomato </i> </strong> applet, shown in Figure 16-1, demonstrates a Java Virtual Machine executing a sequence of bytecodes. The applet is part of a web page on the CD-ROM in file <code> applets/SayingTomato.html </code> . The bytecode sequence in the simulation was generated by the <code> javac </code> compiler for the <code> argue() </code> method of the class shown below: </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> // On CD-ROM in file opcodes/ex1/Struggle.java <p> class Struggle { </p> <p> </p> <p> public final static int TOMAYTO = 0; </p> <p> public final static int TOMAHTO = 1; </p> <p> </p> <p> static void argue() { </p> <p> </p> <p> int say = TOMAYTO; </p> <p> </p> <p> for (;;) { </p> <p> </p> <p> switch (say) { </p> <p> </p> <p> case TOMAYTO: </p> <p> </p> <p> say = TOMAHTO; </p> <p> break; </p> <p> </p> <p> case TOMAHTO: </p> <p> </p> <p> say = TOMAYTO; </p> <p> break; </p> <p> } </p> <p> } </p> <p> } </p> <p> } </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> The bytecodes generated by <code> javac </code> for the <code> argue() </code> method are shown below: </code> </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> 0 iconst_0      // Push constant 0 (TOMAYTO) <p> 1 istore_0      // Pop into local var 0: int say = TOMAYTO; </p> <p> 2 iload_0       // Push key for switch from local var 0 </p> <p> // Perform switch statement: switch (say) {... </p> <p> // Low case value is 0, high case value is 1 </p> <p> // Default branch offset will goto 2 </p> <p> 3 tableswitch 0 to 1: default=2 </p> <p> 0: 24  // case 0 (TOMAYTO): goto 24 </p> <p> 1: 29  // case 1 (TOMAHTO): goto 29 </p> <p> // Note that the next instruction starts at address </p> <p> // 24, which means the tableswitch took up 21 bytes </p> <p> 24 iconst_1      // Push constant 1 (TOMAHTO) </p> <p> 25 istore_0      // Pop into local var 0: say = TOMAHTO </p> <p> 26 goto 2        // Branch unconditionally to 2, top of while loop </p> <p> 29 iconst_0      // Push constant 1 (TOMAYTO) </p> <p> 30 istore_0      // Pop into local var 0: say = TOMAYTO </p> <p> 31 goto 2        // Branch unconditionally to 2, top of while loop </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> <code> The <code> argue() </code> method merely switches the value of <code> say </code> back and forth between <code> TOMAYTO </code> and <code> TOMAHTO </code> . Because the values of <code> TOMAYTO </code> and <code> TOMAHTO </code> were consecutive ( <code> TOMAYTO </code> was a 0 and <code> TOMAHTO </code> was a 1), the <code> javac </code> compiler used a <code> tableswitch </code> . The <code> tableswitch </code> is a more efficient instruction than a <code> lookupswitch </code> , and the equivalent <code> lookupswitch </code> instruction would occupy 28 bytes--4 bytes more than <code> tableswitch </code> . </code> </code> </p> <p> <code> <code> It turns out that even if <code> TOMAYTO </code> were a 0 and <code> TOMAHTO </code> were a 2, the <code> javac </code> compiler still would have used a <code> tableswitch </code> , because even with the extra default branch offset in there for a 1, the <code> tableswitch </code> instruction would occupy only 28 bytes--the same number of bytes as the equivalent <code> lookupswitch </code> . Both instructions occupy the same number of bytes, but <code> tableswitch </code> is more efficient, so it is used. As soon as you make <code> TOMAHTO </code> a 3, however, <code> javac </code> starts using a <code> lookupswitch </code> . This is because a <code> tableswitch </code> would now need two default branch offsets in its list (for 1 and 2), which would push its size up to 32 bytes. Thus, a <code> lookupswitch </code> now would require fewer bytes than a <code> tableswitch </code> --so <code> javac </code> chooses the <code> lookupswitch </code> . </code> </code> </p> <p> <code> <code> The branch offsets for the case values cause the Java Virtual Machine to hop down to code that will change the value of the <code> say </code> local variable. The value of <code> say </code> will alternate between <code> TOMAYTO </code> and <code> TOMAHTO </code> indefinitely, until the user aborts the program, thereby calling the whole thing off. </code> </code> </p> <p> <code> <code> To drive the <i> Saying Tomato </i> simulation, use the Step, Reset, Run, and Stop buttons . Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking. </code> </code> </p> <p> <code> <code> <img src="images/fig16-1.gif" alt="figure 16-1"> </code> </code> </p> <p> <code> <code> <em> On the CD-ROM </em> </code> </code> </p> <p> <code> <code> The CD-ROM contains the source code examples from this chapter in the <code> opcodes </code> directory. The <i> Saying Tomato </i> applet is contained in a web page on the CD-ROM in file <code> applets/SayingTomato.html </code> . The source code for this applet is found alongside its class files, in the <code> applets/JVMSimulators </code> and <code> applets/JVMSimulators/COM/artima/jvmsim </code> directories. </code> </code> </p> <p> <code> <code> <em> The Resources Page </em> </code> </code> </p> <p> <code> <code> For more information about the material presented in this chapter, visit the resources page: <code> http://www.artima.com/insidejvm/flow.html </code> . </code> </code> </p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="15.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="17.html">Next page</a>
                </div>
            </div>
            <hr/>
        </div>

    </div>
</div>

</body>
</html>


