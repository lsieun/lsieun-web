<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>18 Finally Clauses | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>18 Finally Clauses</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="17.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="19.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr>
                    <h2> Finally Clauses </h2> <p> This chapter describes the way finally clauses are implemented in bytecodes. It describes the relevant instructions and shows how they are used. The chapter also describes some surprising behaviors exhibited by finally clauses in Java source code and explains this behavior at the bytecode level. </p> <p> Accompanying this chapter on the CD-ROM is an applet that interactively illustrates the material presented in the chapter. The applet, named <i> Hop Around </i> , simulates the Java Virtual Machine executing a method that includes finally clauses. At the end of this chapter, you will find a description of this applet and the bytecodes it executes. </p> <p> <i> Miniature Subroutines </i> </p> <p> In bytecodes, <code> finally </code> clauses act as "miniature subroutines" within a method. The subroutine for a finally clause is "invoked" at each exit point inside a <code> try </code> block and its associated <code> catch </code> . After the <code> finally </code> clause completes--as long as it completes by executing past the last statement in the <code> finally </code> clause, not by throwing an exception or executing a <code> return </code> , <code> continue </code> , or <code> break </code> --the miniature subroutine itself "returns." Execution continues just past the point where the miniature subroutine was called in the first place. </p> <p> The opcode that causes a Java Virtual Machine to jump to a miniature subroutine is the <em> <code> jsr </code> </em> instruction. The <em> <code> jsr </code> </em> opcode takes a two-byte operand, the 16-bit signed offset from the location of the <em> <code> jsr </code> </em> instruction where the miniature subroutine begins. A second variant of the <em> <code> jsr </code> </em> instruction is <em> <code> jsr_w </code> </em> , which performs the same function as <em> <code> jsr </code> </em> but takes a wide (four-byte) operand. When the Java Virtual Machine encounters a <em> <code> jsr </code> </em> or <em> <code> jsr_w </code> </em> instruction, it pushes a return address onto the stack, then continues execution at the start of the miniature subroutine. The return address is the address (an offset or native pointer) of the bytecode immediately following the <em> <code> jsr </code> </em> or <em> <code> jsr_w </code> </em> opcode and its operands. The type of the address is <code> returnAddress </code> . </p> <p> After a miniature subroutine completes, it invokes the <em> <code> ret </code> </em> instruction, which returns from the subroutine. The <em> <code> ret </code> </em> instruction takes one operand, an index into the local variables where the return address is stored. The opcodes that deal with <code> finally </code> clauses are summarized in Table 18-1: </p> <p> Table 18-1. <strong> Finally clauses </strong> </p> <table width="500"> <tbody> <tr> <td valign="top"> <strong> Opcode </strong> </td> <td valign="top"> <strong> Operand(s) </strong> </td> <td valign="top"> <strong> Description </strong> </td> </tr> <tr> <td valign="top"> <code> jsr </code> </td> <td valign="top"> branchbyte1, branchbyte2 </td> <td valign="top"> pushes the return address, branches to offset </td> </tr> <tr> <td valign="top"> <code> jsr </code> _w </td> <td valign="top"> branchbyte1, branchbyte2, branchbyte3, branchbyte4 </td> <td valign="top"> pushes the return address, branches to wide offset </td> </tr> <tr> <td valign="top"> <code> ret </code> </td> <td valign="top"> index </td> <td valign="top"> returns to the address stored in local variable index </td> </tr> <tr> <td valign="top"> <code> wide </code> </td> <td valign="top"> <code> ret </code> , indexbyte1, indexbyte2 </td> <td valign="top"> returns to the address stored in local variable index </td> </tr> </tbody> </table> <p> Don't confuse a miniature subroutine with a Java method. Java methods use a different set of instructions. Instructions such as <em> <code> invokevirtual </code> </em> or <em> <code> invokespecial </code> </em> cause a Java method to be invoked, and instructions such as <em> <code> return </code> </em> , <em> <code> areturn </code> </em> , or <em> <code> ireturn </code> </em> cause a Java method to return. The <em> <code> jsr </code> </em> instruction does not cause a Java method to be invoked. It merely causes a jump to a different opcode within the same method. Likewise, the <em> <code> ret </code> </em> instruction doesn't return from a method. It just causes the virtual machine to jump back to the opcode in the same method that immediately follows the calling <em> <code> jsr </code> </em> opcode and its operands. In this book, the bytecodes that implement a <code> finally </code> clause are called a "miniature subroutine" because they act like a small subroutine within the bytecode stream of a single method. </p> <p> <em> Asymmetrical Invocation and Return </em> </p> <p> You might think that the <em> <code> ret </code> </em> instruction should pop the return address off the stack, because that is where it was pushed by the <em> <code> jsr </code> </em> instruction. But it doesn't. At the start of each subroutine, the return address is popped off the top of the stack and stored in a local variable--the same local variable from which the <em> <code> ret </code> </em> instruction later gets it. This asymmetrical manner of working with the return address is necessary because finally clauses (and therefore, miniature subroutines) themselves can throw exceptions or include <code> return </code> , <code> break </code> , or <code> continue </code> statements. Because of this possibility, the extra return address that was pushed onto the stack by the <em> <code> jsr </code> </em> instruction must be removed from the stack right away, so it won't still be there if the <code> finally </code> clause exits with a <code> break </code> , <code> continue </code> , <code> return </code> , or thrown exception. </p> <p> As an illustration, consider the following code, which includes a <code> finally </code> clause that exits with a break statement. The result of this code is that, irrespective of the parameter <code> bVal </code> passed to method <code> surpriseTheProgrammer() </code> , the method returns <code> false </code> : </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> // On CD-ROM in file opcodes/ex3/Surprise.java <p> class Surprise { </p> <p> </p> <p> static boolean surpriseTheProgrammer(boolean bVal) { </p> <p> while (bVal) { </p> <p> try { </p> <p> return true; </p> <p> } </p> <p> finally { </p> <p> break; </p> <p> } </p> <p> } </p> <p> return false; </p> <p> } </p> <p> } </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> The example above shows why the return address must be stored into a local variable at the beginning of the <code> finally </code> clause. Because the <code> finally </code> clause exits with a break, it never executes the <em> <code> ret </code> </em> instruction. As a result, the Java Virtual Machine never goes back to finish up the " <code> return true </code> " statement. Instead, it just goes ahead with the <code> break </code> and drops down past the closing curly brace of the <code> while </code> statement. The next statement is " <code> return false </code> ," which is precisely what the Java Virtual Machine does. </code> </p> <p> <code> The behavior shown by this <code> finally </code> clause, which exits with a <code> break, </code> is also shown by <code> finally </code> clauses that exit with a <code> return </code> or <code> continue </code> , or by throwing an exception. In any of these cases, the <em> <code> ret </code> </em> instruction at the end of the <code> finally </code> clause is never executed. Because the <em> <code> ret </code> </em> instruction is not guaranteed to be executed, it can't be relied on to remove the return address from the stack. Therefore, the return address is stored into a local variable at the beginning of the <code> finally </code> clause's miniature subroutine. </code> </p> <p> <code> For a complete example of a finally clause, consider the following method, which contains a <code> try </code> block with two exit points. In this example, both exit points are <code> return </code> statements: </code> </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> // On CD-ROM in file opcodes/ex1/Nostalgia.java <p> class Nostalgia { </p> <p> </p> <p> static int giveMeThatOldFashionedBoolean(boolean bVal) { </p> <p> try { </p> <p> if (bVal) { </p> <p> return 1; </p> <p> } </p> <p> return 0; </p> <p> } </p> <p> finally { </p> <p> System.out.println("Got old fashioned."); </p> <p> } </p> <p> } </p> <p> } </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> <code> The <code> giveMeThatOldFashionedBoolean() </code> method compiles to the following bytecodes: </code> </code> </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> // The bytecode sequence for the try block: <p> 0 iload_0   // Push local variable 0 (bval parameter) </p> <p> 1 ifeq 11   // Pop int, if equal to 0, jump to 11 (just past </p> <p> // the if statement): if (bval) {} </p> <p> 4 iconst_1  // Push int 1 </p> <p> 5 istore_1  // Pop an int (the 1), store into local variable 1 </p> <p> 6 jsr 24    // Jump to the mini-subroutine for the finally clause </p> <p> 9 iload_1   // Push local variable 1 (the 1) </p> <p> 10 ireturn   // Return int on top of the stack (the 1): return 1; </p> <p> 11 iconst_0  // Push int 0 </p> <p> 12 istore_1  // Pop an int (the 0), store into local variable 1 </p> <p> 13 jsr 24    // Jump to the mini-subroutine for the finally clause </p> <p> 16 iload_1   // Push local variable 1 (the 0) </p> <p> 17 ireturn   // Return int on top of the stack (the 0): return 0; </p> <p> </p> <p> // The bytecode sequence for a catch clause that catches any kind </p> <p> // of exception thrown from within the try block. </p> <p> 18 astore_2  // Pop the reference to the thrown exception, store </p> <p> // into local variable 2 </p> <p> 19 jsr 24    // Jump to the mini-subroutine for the finally clause </p> <p> 22 aload_2   // Push the reference (to the thrown exception) from </p> <p> // local variable 2 </p> <p> 23 athrow    // Rethrow the same exception </p> <p> </p> <p> // The miniature subroutine that implements the finally block. </p> <p> 24 astore_3  // Pop the return address, store it in local variable 3 </p> <p> 25 getstatic #7 &lt;Field java.io.PrintStream out </p> </code> <p> // Get a reference to java.lang.System.out </p> <p> 28 ldc #1 &lt;String "Got old fashioned." </p> <p> // Push reference to "Got old fashioned." String from </p> <p> // the constant pool </p> <p> 30 invokevirtual #8 &lt;Method void println(java.lang.String) </p> <p> // Invoke System.out.println() </p> <p> 33 ret 3     // Return to return address stored in local variable 3 </p> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> <code> <code> The bytecodes for the <code> try </code> block include two <em> <code> jsr </code> </em> instructions. Another <em> <code> jsr </code> </em> instruction is contained in the <code> catch </code> clause. The <code> catch </code> clause is added by the compiler because if an exception is thrown during the execution of the <code> try </code> block, the finally block must still be executed. Therefore, the <code> catch </code> clause merely invokes the miniature subroutine that represents the <code> finally </code> clause, then throws the same exception again. The exception table for the <code> giveMeThatOldFashionedBoolean() </code> method, shown below, indicates that any exception thrown between and including addresses 0 and 17 (all the bytecodes that implement the <code> try </code> block) are handled by the <code> catch </code> clause that starts at address 18. </code> </code> </code> </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> Exception table: <p> from    to   target type </p> <p> 0     18     18   any </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> <code> <code> <code> The bytecodes of the <code> finally </code> clause begin by popping the return address off the stack and storing it into local variable three. At the end of the <code> finally </code> clause, the <em> <code> ret </code> </em> instruction takes its return address from the proper place, local variable three. </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <i> <strong> Hop Around: A Simulation </strong> </i> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> The <i> Hop Around </i> applet, shown in Figure 18-1, demonstrates a Java Virtual Machine executing a sequence of bytecodes. The applet is embedded in a web page on the CD-ROM in file <code> applets/HopAround.html </code> . The bytecode sequence in the simulation was generated by the <code> javac </code> compiler for the <code> hopAround() </code> method of the class shown below: </code> </code> </code> </code> </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> // On CD-ROM in file opcodes/ex1/Clown.java <p> class Clown { </p> <p> </p> <p> static int hopAround() { </p> <p> int i = 0; </p> <p> while (true) { </p> <p> try { </p> <p> try { </p> <p> i = 1; </p> <p> } </p> <p> finally {  // The first finally clause </p> <p> i = 2; </p> <p> } </p> <p> i = 3; </p> <p> // This return never completes, because of </p> <p> // the continue in the second finally clause </p> <p> return i; </p> <p> } </p> <p> finally {      // The second finally clause </p> <p> if (i == 3) { </p> <p> // This continue overrides the return statement </p> <p> continue; </p> <p> } </p> <p> } </p> <p> } </p> <p> } </p> <p> } </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> <code> <code> <code> <code> The bytecodes generated by <code> javac </code> for the <code> hopAround() </code> method are shown below: </code> </code> </code> </code> </code> </p> <pre> <p> <code> begin </code> </p> <code> <p/> </code> <code> 0 iconst_0      // Push constant 0 <p> 1 istore_0      // Pop into local var 0: int i = 0; </p> <p> </p> <p> // Both try blocks start here (see exception table, below): </p> <p> 2 iconst_1      // Push constant 1 </p> <p> 3 istore_0      // Pop into local var 0: i = 1; </p> <p> 4 jsr 18        // Jump to mini-subroutine at offset 18 (the </p> <p> // first finally clause) </p> <p> 7 goto 24       // Jump to offset 24 (to just below first </p> <p> // finally clause) </p> <p> </p> <p> // Catch clause for the first finally clause: </p> <p> 10 astore 4      // Pop the reference to thrown exception, store </p> <p> // in local variable 4 </p> <p> 12 jsr 18        // Jump to mini-subroutine at offset 18 (the </p> <p> // first finally clause) </p> <p> 15 aload 4       // Push the reference (to thrown exception) </p> <p> // from local variable 4 </p> <p> 17 athrow        // Rethrow the same exception </p> <p> </p> <p> // The first finally clause: </p> <p> 18 astore 5      // Store the return address in local variable 5 </p> <p> 20 iconst_2      // Push constant 2 </p> <p> 21 istore_0      // Pop into local var 0: i = 2; </p> <p> 22 ret 5         // Jump to return address stored in local variable 5 </p> <p> </p> <p> // Bytecodes for the code just after the first finally clause: </p> <p> 24 iconst_3      // Push constant 3 </p> <p> 25 istore_0      // Pop into local var 0: int i = 3; </p> <p> </p> <p> // Bytecodes for the return statment: </p> <p> 26 iload_0       // Push the int from local </p> <p> // variable 0 (i, which is 3) </p> <p> 27 istore_1      // Pop and store the int into local </p> <p> // variable 1 (the return value, i) </p> <p> 28 jsr 39        // Jump to mini-subroutine at offset 39 (the </p> <p> // second finally clause) </p> <p> 31 iload_1       // Push the int from local variable 1 (the </p> <p> // return value) </p> <p> 32 ireturn       // Return the int on the top of the stack </p> <p> </p> <p> // Catch clause for the second finally clause: </p> <p> 33 astore_2      // Pop the reference to thrown exception, store </p> <p> // in local variable 2 </p> <p> 34 jsr 39        // Jump to mini-subroutine at offset 39 (the </p> <p> // second finally clause) </p> <p> 37 aload_2       // Push the reference (to thrown exception) </p> <p> // from local variable 2 </p> <p> 38 athrow        // Rethrow the same exception </p> <p> </p> <p> // The second finally clause: </p> <p> 39 astore_3      // Store the return address in local variable 3 </p> <p> 40 iload_0       // Push the int from local variable 0 (i) </p> <p> 41 iconst_3      // Push constant 3 </p> <p> 42 if_icmpeq 47  // If the top two ints on the stack are equal, jump </p> <p> // to offset 47: if (i == 3) { </p> <p> 45 ret 3         // Jump to return address stored in local variable 3 </p> <p> 47 goto 2        // Jump to offset 2 (the top of the while </p> <p> // block): continue; </p> <p> </p> <p> Exception table: </p> <p> from   to  target type </p> <p> 2     4    10   any </p> <p> 2    31    31   any </p> </code> <code> <p> </p> </code> <code> end </code> </pre> <p> <code> <code> <code> <code> <code> <code> The <code> hopAround() </code> method returns from the first <code> finally </code> clause by executing past the closing curly brace, but returns from the second <code> finally </code> clause by executing a <code> continue </code> statement. The first <code> finally </code> clause, therefore, exits via its <em> <code> ret </code> </em> instruction. But because the second <code> finally </code> clause exits via a <code> continue </code> , its <em> <code> ret </code> </em> instruction is never executed. The <code> continue </code> statement causes the Java Virtual Machine to jump to the top of the <code> while </code> loop again. This results in an endless loop, even though it is a <code> return </code> statement that originally causes the second <code> finally </code> clause to be executed in the first place. The continue statement in the <code> finally </code> clause supersedes the <code> return </code> statement, so the method never returns. </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> Note that the bytecodes that implement the <code> return </code> statement store a copy of the return value into local variable one before jumping to the miniature subroutine that represents the second <code> finally </code> clause. Then, after the miniature subroutine returns (in this case it never does, because the continue is always executed), the return value is retrieved from local variable one and returned. </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> This highlights the way the Java Virtual Machine returns values when <code> finally </code> clauses are also executed. Rather than returning the value of <code> i </code> after the <code> finally </code> clause is executed, the Java Virtual Machine will return the value that <code> i </code> had just <i> before </i> the <code> finally </code> clause was executed. This means that even if the <code> finally </code> clause changes the value of <code> i </code> , the method will still return the value that <code> i </code> had when the <code> return </code> statement was first reached, before the <code> finally </code> clause was invoked. If you wanted the <code> finally </code> clause to be able to change the return value of the method, you would have to put an actual <code> return </code> statement with the new return value into the <code> finally </code> clause itself. </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> To drive the <i> Hop Around </i> simulation, use the Step, Reset, Run, and Stop buttons . Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking. </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> <img src="images/fig18-1.gif" alt="figure 18-1"> </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> <em> On the CD-ROM </em> </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> The CD-ROM contains the source code examples from this chapter in the <code> opcodes </code> directory. The <i> Hop Around </i> applet is contained in a web page on the CD-ROM in file <code> applets/HopAround.html </code> . The source code for this applet is found alongside its class files, in the <code> applets/JVMSimulators </code> and <code> applets/JVMSimulators/COM/artima/jvmsim </code> directories. </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> <em> The Resources Page </em> </code> </code> </code> </code> </code> </code> </p> <p> <code> <code> <code> <code> <code> <code> For more information about the material presented in this chapter, visit the resources page: <code> http://www.artima.com/insidejvm/finally.html </code> . </code> </code> </code> </code> </code> </code> </p>
                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="17.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="19.html">Next page</a>
                </div>
            </div>
            <hr/>

        </div>
    </div>

</div>

</body>
</html>


