<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>11 Type Conversion | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>11 Type Conversion</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="10.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="12.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr/>
                    <ul>
                        <li><a href="#on_the_cd">On the CD-ROM</a></li>
                        <li><a href="#resources_page">The Resources Page</a></li>
                    </ul>
                    <hr>
                    <p>This chapter describes the instructions that convert values from one primitive type to another inside the Java Virtual Machine. It also looks at some of the idiosyncrasies of type conversion that arise from the virtual machine's limited support of <code>byte</code> s, <code>short</code> s, and <code>char</code> s.</p> <p>Accompanying this chapter on the CD-ROM is an applet that interactively illustrates the material presented in the chapter. The applet, named <em>Conversion Diversion</em>, simulates the Java Virtual Machine executing a method that performs type conversion. At the end of this chapter, you will find a description of this applet and the bytecodes it executes.</p> <p><em> The Conversion Opcodes </em></p> <p>The Java Virtual Machine has many opcodes that convert from one primitive type to another. No operands follow the conversion opcodes in the bytecode stream. The value to convert is taken from the top of the stack. The Java Virtual Machine pops the value at the top of the stack, converts it, and pushes the result back onto the stack. Opcodes that convert between <code>int</code>, <code>long</code>, <code>float</code>, and <code>double</code> are shown in Table 11-1. There is an opcode for each possible from-to combination of these four types:</p> <p>Table 11-1. Converting <code>int</code> s, <code>long</code> s, <code>float</code> s, and <code>double</code> s</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>i2l</code></td> <td>(none)</td> <td>converts <code>int</code> to <code>long</code></td></tr> <tr><td><code>i2f</code></td> <td>(none)</td> <td>converts <code>int</code> to <code>float</code></td></tr> <tr><td><code>i2d</code></td> <td>(none)</td> <td>converts <code>int</code> to <code>double</code></td></tr> <tr><td><code>l2i</code></td> <td>(none)</td> <td>converts <code>long</code> to <code>int</code></td></tr> <tr><td><code>l2f</code></td> <td>(none)</td> <td>converts <code>long</code> to <code>float</code></td></tr> <tr><td><code>l2d</code></td> <td>(none)</td> <td>converts <code>long</code> to <code>double</code></td></tr> <tr><td><code>f2i</code></td> <td>(none)</td> <td>converts <code>float</code> to <code>int</code></td></tr> <tr><td><code>f2l</code></td> <td>(none)</td> <td>converts <code>float</code> to <code>long</code></td></tr> <tr><td><code>f2d</code></td> <td>(none)</td> <td>converts <code>float</code> to <code>double</code></td></tr> <tr><td><code>d2i</code></td> <td>(none)</td> <td>converts <code>double</code> to <code>int</code></td></tr> <tr><td><code>d2l</code></td> <td>(none)</td> <td>converts <code>double</code> to <code>long</code></td></tr> <tr><td><code>d2f</code></td> <td>(none)</td> <td>converts <code>double</code> to <code>float</code></td></tr> </tbody> </table> <p>Opcodes that convert from an <code>int</code> to a type smaller than <code>int</code> are shown in Table 11-2. These opcodes pop one <code>int</code> off the operand stack, convert it to an <code>int</code> value that fits into a <code>byte</code>, <code>short</code>, or <code>char</code>, and push the resulting <code>int</code> back onto the operand stack. The <code>i2b</code> instruction truncates the popped <code>int</code> value to a <code>byte</code>, then sign-extends back out to an <code>int</code>. The <code>i2s</code> instruction truncates the popped <code>int</code> value to a <code>short</code>, then sign-extends back out to an <code>int</code>. The <code>i2c</code> instruction truncates the popped <code>int</code> value to a <code>char</code>, then zero-extends back out to an <code>int</code>.</p> <p>Table 11-2. Converting <code>int</code> s, <code>byte</code> s, <code>chars</code>, and <code>short</code> s.</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>i2b</code></td> <td>(none)</td> <td>converts <code>int</code> to <code>byte</code></td></tr> <tr><td><code>i2c</code></td> <td>(none)</td> <td>converts <code>int</code> to <code>char</code></td></tr> <tr><td><code>i2s</code></td> <td>(none)</td> <td>converts <code>int</code> to <code>short</code></td></tr> </tbody> </table> <p>No opcodes exist that convert directly from a <code>long</code>, <code>float</code>, or <code>double</code> to the types smaller than <code>int</code>. Therefore converting from a <code>float</code> to a <code>byte</code>, for example, requires two steps. First the <code>float</code> must be converted to an <code>int</code> with <code>f2i</code>, then the resulting <code>int</code> can be converted to a <code>byte</code> with <code>i2b</code>.</p> <p>Although opcodes exist that convert an <code>int</code> to primitive types smaller than <code>int</code> ( <code>byte</code>, <code>short</code>, and <code>char</code> ), no opcodes exist that convert in the opposite direction. This is because any <code>byte</code> s, <code>short</code> s, or <code>char</code> s are effectively converted to <code>int</code> before being pushed onto the stack. The instructions that retrieve <code>byte</code>, <code>short</code>, and <code>char</code> values from arrays or objects on the heap and push them onto the stack convert the values to <code>int</code>. These instructions are described in Chapter 15, "Objects and Arrays."</p> <p>Arithmetic operations upon <code>byte</code> s, <code>short</code> s, and <code>char</code> s are done by first converting the values to <code>int</code>, performing the arithmetic operations on the <code>int</code> s, and being happy with an <code>int</code> result. This means that if you add 2 <code>byte</code> s you get an <code>int</code>, and if you want a <code>byte</code> result you must explicitly convert the <code>int</code> result back to a <code>byte</code>. For example, the following code won't compile:</p> <pre> <p><code>begin</code></p> <code><p/></code> <code>// On the CD-ROM in file opcodes/ex1/BadArithmetic.java <p>class BadArithmetic {</p> <p></p> <p>static byte addOneAndOne() {</p> <p>byte a = 1;</p> <p>byte b = 1;</p> <p>byte c = a + b;</p> <p>return c;</p> <p>}</p> <p>}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>When presented with the above code, <code>javac</code> objects with the following remark:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>BadArithmetic.java(7): Incompatible type for declaration. Explicit <p>cast needed to convert int to byte.</p> <p>byte c = a + b;</p> <p>^</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>To remedy the situation, the you must explicitly convert the <code>int</code> result of the addition of <code>a + b</code> back to a <code>byte</code>, as in the following code:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>// On the CD-ROM in file opcodes/ex1/GoodArithmetic.java <p>class GoodArithmetic {</p> <p></p> <p>static byte addOneAndOne() {</p> <p>byte a = 1;</p> <p>byte b = 1;</p> <p>byte c = (byte) (a + b);</p> <p>return c;</p> <p>}</p> <p>}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>This makes <code>javac</code> so happy it drops a <code>GoodArithmetic.class</code> file, which contains the following bytecode sequence for the <code>addOneAndOne()</code> method:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>0 iconst_1   // Push int constant 1. <p>1 istore_0   // Pop into local variable 0, which is a: byte a = 1;</p> <p>2 iconst_1   // Push int constant 1 again.</p> <p>3 istore_1   // Pop into local variable 1, which is b: byte b = 1;</p> <p>4 iload_0    // Push a (a is already stored as an int in local</p> <p>// variable 0).</p> <p>5 iload_1    // Push b (b is already stored as an int in local</p> <p>// variable 1).</p> <p>6 iadd       // Perform addition. Top of stack is</p> <p>// now (a + b), an int.</p> <p>7 i2b        // Convert int result to byte (result still</p> <p>// occupies 32 bits).</p> <p>8 istore_2   // Pop into local variable 3, which is</p> <p>// byte c: byte c = (byte) (a + b);</p> <p>9 iload_2    // Push the value of c so it can be returned.</p> <p>10 ireturn    // Proudly return the result of the addition: return c;</p></code> <code><p></p></code> <code>end</code> </pre> <p><code><em><strong> Conversion Diversion: A Simulation </strong></em></code></p> <p><code>The <em>Conversion Diversion</em> applet, shown in Figure 11-1, demonstrates a Java Virtual Machine executing a sequence of bytecodes. The applet is embedded in a web page on the CD-ROM in file <code>applets/ConversionDiversion.html</code>. The bytecode sequence in the simulation was generated by <code>javac</code> for the <code>Convert()</code> method of the class shown below:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>// On CD-ROM in file opcodes/ex1/Diversion.java <p>class Diversion {</p> <p></p> <p>static void Convert() {</p> <p></p> <p>byte imByte = 0;</p> <p>int imInt = 125;</p> <p></p> <p>for (;;) {</p> <p>++imInt;</p> <p>imByte = (byte) imInt;</p> <p></p> <p>imInt *= -1;</p> <p>imByte = (byte) imInt;</p> <p>imInt *= -1;</p> <p>}</p> <p>}</p> <p>}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>The bytecodes generated by <code>javac</code> for <code>Convert()</code> are shown below:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>0 iconst_0    // Push int constant 0. <p>1 istore_0    // Pop to local variable 0, which is</p> <p>// imByte: byte imByte = 0;</p> <p>2 bipush 125  // Expand byte constant 125 to int and push.</p> <p>4 istore_1    // Pop to local variable 1, which</p> <p>// is imInt: int imInt = 125;</p> <p>5 iinc 1 1    // Increment local variable 1 (imInt) by 1: ++imInt;</p> <p>8 iload_1     // Push local variable 1 (imInt).</p> <p>9 i2b         // Truncate and sign extend top of stack so it</p> <p>// has a valid byte value.</p> <p>10 istore_0    // Pop to local variable 0 (imByte):</p> <p>// imByte = (byte) imInt;</p> <p>11 iload_1     // Push local variable 1 (imInt) again.</p> <p>12 iconst_m1   // Push integer -1.</p> <p>13 imul        // Pop top two ints, multiply, push result.</p> <p>14 istore_1    // Pop result of multiply to local variable 1 (imInt):</p> <p>// imInt *= -1;</p> <p>15 iload_1     // Push local variable 1 (imInt).</p> <p>16 i2b         // Truncate and sign extend top of stack so it has</p> <p>// a valid byte value.</p> <p>17 istore_0    // Pop to local variable 0 (imByte):</p> <p>// imByte = (byte) imInt;</p> <p>18 iload_1     // Push local variable 1 (imInt) again.</p> <p>19 iconst_m1   // Push integer -1.</p> <p>20 imul        // Pop top two ints, multiply, push result.</p> <p>21 istore_1    // Pop result of multiply to local variable 1 (imInt):</p> <p>// imInt *= -1;</p> <p>22 goto 5      // Jump back to the iinc instruction: for (;;) {}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>The <code>Convert()</code> method demonstrates the manner in which the Java Virtual Machine converts from <code>int</code> to <code>byte</code>. <code>imInt</code> starts out as 125. Each pass through the while loop, it is incremented and converted to a <code>byte</code>. Then it is multiplied by -1 and again converted to a <code>byte</code>. The simulation quickly shows what happens at the edges of the valid range for the <code>byte</code> type.</code></p> <p><code>The maximum value for a <code>byte</code> is 127. The minimum value is -128. Values of type <code>int</code> that are within this range convert directly to <code>byte</code>. As soon as the <code>int</code> gets beyond the valid range for <code>byte</code>, however, things get interesting.</code></p> <p><code>The Java Virtual Machine converts an <code>int</code> to a <code>byte</code> by truncating and sign extending. The highest order bit, the "sign bit," of <code>long</code> s, <code>int</code> s, <code>short</code> s, and <code>byte</code> s indicate whether or not the integer value is positive or negative. If the sign bit is zero, the value is positive. If the sign bit is one, the value is negative. Bit 7 of a <code>byte</code> value is its sign bit. To convert an <code>int</code> to a <code>byte</code>, bit 7 of the <code>int</code> is copied to bits 8 through 31. This produces an <code>int</code> that has the same numerical value that the <code>int</code> 's lowest order byte would have if it were interpreted as a <code>byte</code> type. After the truncation and sign extension, the <code>int</code> will contain a valid <code>byte</code> value.</code></p> <p><code>The simulation applet shows what happens when an <code>int</code> that is just beyond the valid range for <code>byte</code> types gets converted to a <code>byte</code>. For example, when the <code>imInt</code> variable has a value of 128 (0x00000080) and is converted to <code>byte</code>, the resulting <code>byte</code> value is -128 (0xffffff80). Later, when the <code>imInt</code> variable has a value of -129 (0xffffff7f) and is converted to <code>byte</code>, the resulting <code>byte</code> value is 127 (0x0000007f).</code></p> <p><code>To drive the <em>Conversion Diversion</em> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.</code></p>
                    <p><code><img src="images/fig11-1.gif" alt="figure 11-1"></code></p>



                    <h2 id="on_the_cd">On the CD-ROM</h2>
                    <p>The CD-ROM contains the source code examples from this chapter in the <code>opcodes</code> directory. The <em>Conversion Diversion</em> applet is contained in a web page on the CD-ROM in file <code>applets/ConversionDiversion.html</code>. The source code for this applet is found alongside its class files, in the <code>applets/JVMSimulators</code> and <code>applets/JVMSimulators/COM/artima/jvmsim</code> directories.</p>



                    <h2 id="resources_page">The Resources Page</h2>
                    <p>For more information about the material presented in this chapter, visit the resources page: <a href="http://www.artima.com/insidejvm/resources" target="_blank">http://www.artima.com/insidejvm/resources</a>.</p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="10.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="12.html">Next page</a>
                </div>
            </div>
            <hr/>
        </div>
    </div>
</div>

</body>
</html>


