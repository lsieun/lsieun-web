<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>12 Integer Arithmetic | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>12 Integer Arithmetic</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="11.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="13.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr/>
                    <ul>
                        <li><a href="#on_the_cd">On the CD-ROM</a></li>
                        <li><a href="#resources_page">The Resources Page</a></li>
                    </ul>
                    <hr>
                    <p>This chapter describes integer arithmetic in the Java Virtual Machine. It explains two's complement arithmetic (the mechanism used by the Java Virtual Machine to perform integer arithmetic) and describes the instructions that perform integer arithmetic.</p> <p>Accompanying this chapter on the CD-ROM are two applets that interactively illustrate the material presented in the chapter. One applet, named <i>Inner Int</i>, allows you to view and manipulate the individual components that make up a two's complement number. The other applet, named <i>Prime Time</i>, simulates the Java Virtual Machine executing a method that generates prime numbers. At the end of this chapter, you will find a description of this applet and the bytecodes it executes.</p> <p><i>Two's Complement Arithmetic</i></p> <p>All integer types supported by the Java Virtual Machine-- <code>byte</code> s, <code>short</code> s, <code>int</code> s, and <code>long</code> s--are signed two's-complement numbers. The two's-complement scheme allows both positive and negative integers to be represented. The most significant bit of a two's-complement number is its sign bit. The sign bit is one for negative numbers and zero for positive numbers and for the number zero.</p> <p>The number of unique values that can be represented by the two's-complement scheme is two raised to the power of the total number of bits. For example, the <code>short</code> type in Java is a 16-bit signed two's-complement integer. The number of unique integers that can be represented by this scheme is 2 <sup> 16 </sup>, or 65,536. Half of the <code>short</code> type's range of values are used to represent zero and positive numbers; the other half of the <code>short</code> type's range are used to represent negative numbers. The range of negative values for a 16-bit two's-complement number is -32,768 (0x8000) to -1 (0xffff). Zero is 0x0000. The range of positive values is one (0x0001) to 32,767 (0x7fff).</p> <p>Positive numbers are intuitive in that they are merely the base two representation of the number. Negative numbers can be calculated by adding the negative number to two raised to the power of the total number of bits. For example, the total number of bits in a <code>short</code> is 16, so the two's-complement representation of a negative number in the valid range for a <code>short</code> (-32,768 to -1) can be calculated by adding the negative number to 2 <sup> 16 </sup>, or 65,536. The two's-complement representation for -1 is 65,536 + (-1) or 65,535 (0xffff). The two's-complement representation for -2 is 65,536 + (-2) or 65,534 (0xfffe).</p> <p>Addition is performed on two's-complement signed numbers in the same way it would be performed on unsigned binary numbers. The two numbers are added, overflow is ignored, and the result is interpreted as a signed two's-complement number. This will work as long as the result is actually within the range of valid values for the type. For example, to add 4 + (-2), just add 0x00000004 and 0xfffffffe. The result is actually 0x100000002, but because there are only 32 bits in an <code>int</code>, the overflow is ignored and the result becomes 0x00000002.</p> <p>Overflow in integer operations does not throw any exception in the Java Virtual Machine. The result is merely truncated to fit into the result type (either <code>int</code> or <code>long</code> ). For example, adding <code>int</code> s 0x7fffffff and 1 yields 0x80000000. This means that the Java Virtual Machine will report that 2,147,483,647 + 1 = -2,147,483,648, if the type of the values being added are <code>int</code> s and not <code>long</code> s. As you program in Java, you must keep in mind that overflow can happen and make sure you choose the appropriate type, <code>int</code> or <code>long</code>, in each situation. Integer division by zero does throw an <code>ArithmeticException</code>, so you should also keep in mind that this exception could be thrown and catch it if necessary.</p> <p>If you encounter a situation in which <code>long</code> just isn't long enough, you can use the <code>BigInteger</code> class of the <code>java.math</code> package. Instances of this class are arbitrary-length integers. The <code>BigInteger</code> class supports all arithmetic operations on arbitrary-length integers that are provided for the primitive types by the Java Virtual Machine and the <code>java.lang.Math</code> package.</p> <p><i>Inner Int: A Java int Reveals its Inner Nature</i></p> <p>The <i>Inner Int</i> applet, shown in Figure 12-1, lets you play around with the two's-complement format of integers in the Java Virtual Machine. The Max and Min buttons will give you the maximum and minimum values of the <code>int</code> type. By clicking Max followed by ++ you can increment beyond the maximum integer and see what happens. Clicking Min followed by -- lets you decrement beyond the minimum integer. Both of these result in overflow, but no exceptions are thrown by the Java Virtual Machine. The applet is embedded in a web page on the CD-ROM in file <code>applets/InnerInt.html</code>.</p> <p><img src="images/fig12-1.gif" alt="figure 12-1"></p> <p><i><strong> Arithmetic Opcodes </strong></i></p> <p>The Java Virtual Machine offers several opcodes that perform integer arithmetic operations on <code>int</code> s and <code>long</code> s. As mentioned in earlier chapters, values of type <code>byte</code>, <code>short</code>, and <code>char</code> are converted to <code>int</code> before they take part in arithmetic operations. For each opcode that performs arithmetic on <code>int</code> s, there is a corresponding opcode that performs the same operation on <code>long</code> s.</p> <p>Integer addition can be performed on <code>int</code> s and <code>long</code> s. Table 12-1 shows the opcodes that pop the top two values on the stack, add them, and push the resulting sum. The values to be added must have been pushed onto the stack by previous instructions. The type of the values is indicated by the opcode itself, and the result always has the same type as the numbers being added. No exceptions are thrown for any of these opcodes. Overflow is just ignored.</p> <p>Table 12-1. Integer addition</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>iadd</code></td> <td>(none)</td> <td>pops two <code>int</code> s, adds them, and pushes the <code>int</code> result</td></tr> <tr><td><code>ladd</code></td> <td>(none)</td> <td>pops two <code>long</code> s, adds them, and pushes the <code>long</code> result</td></tr> </tbody> </table> <p>Table 12-2 shows the exception to the rule that arithmetic opcodes take their operands from the stack. The <code>iinc</code> opcode performs an addition on a local variable of type <code>int</code>. The local variable to increment is specified by the first byte that follows the <code>iinc</code> instruction in the bytecode stream. The amount to add to the local variable is taken from the second byte following the <code>iinc</code> instruction. The second byte is interpreted as an 8-bit signed two's-complement number. The local variable and 8-bit signed value are added, and the result is written back to the local variable. This opcode can be used to change a local variable value by any number between and including -128 through 127. This opcode makes for more efficient incrementing and decrementing of variables that are used to control execution of loops, such as <code>for</code> or <code>while</code>. As with the add instruction, no exceptions are thrown. Overflow is ignored.</p> <p>The second row in Table 12-2 shows the <code>wide</code> variant of the <code>iinc</code> instruction. As mentioned in Chapter 10, "Stack and Local Variable Operations," the <code>wide</code> instruction is used to extend unsigned local variable indexes from eight bits to sixteen. Sixteen bits allows instructions to address up to 65,536 local variable slots. In the <code>iinc</code> case, the <code>wide</code> instruction also extends the size of the signed increment value from eight bits to sixteen. This means the <code>wide</code> variant of the <code>iinc</code> opcode can be used to change a local variable value by any number between and including -32,768 through 32,767.</p> <p>Table 12-2. Increment a local variable by a constant</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>iinc</code></td> <td>vindex, const</td> <td>adds const to an <code>int</code> at local variable position vindex</td></tr> <tr><td><code>wide</code></td> <td><code>iinc</code>, indexbyte1, indexbyte2, constbyte1, constbyte2</td> <td>adds const to an <code>int</code> at local variable position index <code>end table</code></td></tr> </tbody> </table> <p>Integer subtraction is performed on <code>int</code> s and <code>long</code> s via the opcodes shown in Table 12-3. Each opcode causes the top two values of the appropriate type to be popped off the stack. The topmost value is subtracted from the value just beneath it. The result is pushed back onto the stack. No exceptions are thrown by these opcodes.</p> <p>Table 12-3. Integer subtraction</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>isub</code></td> <td>(none)</td> <td>pops two <code>int</code> s, subtracts them, and pushes the <code>int</code> result</td></tr> <tr><td><code>lsub</code></td> <td>(none)</td> <td>pops two <code>long</code> s, subtracts them, and pushes the <code>long</code> result</td></tr> </tbody> </table> <p>Integer multiplication of <code>int</code> s and <code>long</code> s is accomplished via the opcodes shown in Table 12-4. Each opcode causes two values of the same type to be popped off the stack and multiplied. The result, of the same type as the numbers being multiplied, is pushed back onto the stack. No exceptions are thrown.</p> <p>Table 12-4. Integer multiplication</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>imul</code></td> <td>(none)</td> <td>pops two <code>int</code> s, multiplies them, and pushes the <code>int</code> result</td></tr> <tr><td><code>lmul</code></td> <td>(none)</td> <td>pops two <code>long</code> s, multiplies them, and pushes the <code>long</code> result</td></tr> </tbody> </table> <p>The opcodes that perform division on <code>int</code> s and <code>long</code> s are shown in Table 12-5. The division opcodes cause the top two values of the appropriate type to be popped off the stack. The value just beneath the topmost value is divided by the topmost value. (In other words, the first value pushed onto the stack is used as the dividend or numerator. The second value pushed--the top of the stack--is used as the divisor or denominator.) The result of the division is pushed back onto the stack. Integer division yields a result that is truncated down to the nearest integer value between it and zero. Integer division by zero throws an <code>ArithmeticException</code>.</p> <p>Table 12-5. Integer division</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>idiv</code></td> <td>(none)</td> <td>pops two <code>int</code> s, divides them, and pushes the <code>int</code> result</td></tr> <tr><td><code>ldiv</code></td> <td>(none)</td> <td>pops two <code>long</code> s, divides them, and pushes the <code>long</code> result</td></tr> </tbody> </table> <p>The remainder operation is performed on <code>int</code> s and <code>long</code> s via the opcodes shown in Table 12-6. Theses opcodes cause the top two values to be popped from the stack. The value just beneath the topmost value is divided by the topmost value, and the remainder of that division is pushed back onto the stack. As with the division opcodes, integer remainder by zero throws an <code>ArithmeticException</code>.</p> <p>Table 12-6. Integer remainder</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>irem</code></td> <td>(none)</td> <td>pops two <code>int</code> s, divides them, and pushes the <code>int</code> remainder</td></tr> <tr><td><code>lrem</code></td> <td>(none)</td> <td>pops two <code>long</code> s, divides them, and pushes the <code>long</code> remainder</td></tr> </tbody> </table> <p>The opcodes shown in Table 12-7 perform arithmetic negation on <code>int</code> s and <code>long</code> s. The negation opcodes pop the top value from the stack, negate it, and push the result.</p> <p>Table 12-7. Integer negation</p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>ineg</code></td> <td>(none)</td> <td>pops an <code>int</code>, negates it, and pushes the result</td></tr> <tr><td><code>lneg</code></td> <td>(none)</td> <td>pops a <code>long</code>, negates it, and pushes the result</td></tr> </tbody> </table> <p><em> Prime Time </em></p> <strong> : A Simulation </strong> The <i>Prime Time</i> applet, shown in Figure 12-2, demonstrates a Java Virtual Machine executing a sequence of bytecodes that generates prime numbers. The applet is embedded in a web page on the CD-ROM in file <code>applets/PrimeTime.html</code>. The bytecode sequence in the simulation was generated by the <code>javac</code> compiler for the <code>findPrimes</code> <code>()</code> method of the class shown below: <pre> <p><code>begin</code></p> <code><p/></code> <code>// On CD-ROM in file integer/ex1/PrimeFinder.java <p>class PrimeFinder {</p> <p></p> <p>static void findPrimes() {</p> <p>int primeNum = 1;</p> <p>int numToCheck = 2;</p> <p></p> <p>for (;;) {</p> <p></p> <p>boolean foundPrime = true;</p> <p></p> <p>for (int divisor = numToCheck / 2; divisor</p></code> 1; <p>--divisor) {</p> <p></p> <p>if (numToCheck % divisor == 0) {</p> <p>foundPrime = false;</p> <p>break;</p> <p>}</p> <p>}</p> <p></p> <p>if (foundPrime) {</p> <p>primeNum = numToCheck;</p> <p>}</p> <p></p> <p>++numToCheck;</p> <p>}</p> <p>}</p> <p>}</p> <code><p></p></code> <code>end</code> </pre> <p><code>The <code>findPrimes()</code> method places prime numbers, one at a time and in increasing numerical order, into the <code>primeNum</code> variable. To find the primes, it checks each positive integer in increasing numerical order starting with integer value two. It keeps the current number it is checking in the <code>numToCheck</code> variable. The outer for loop, a "forever" loop, keeps this process going indefinitely. To check a number, it divides the number by smaller integers looking for a zero remainder. If it encounters a zero remainder, then the number has integral factors other than one and itself and therefore isn't prime.</code></p> <p><code>For each number to check, the <code>findPrimes()</code> method divides the number by two. The result of this integer division is the first value checked as a possible integral divisor for the number.</code></p> <p><code>In the inner for loop, the <code>findPrimes()</code> method tries each number as a divisor between the result of the division by two and the divisor two. If the remainder of any of these divisions is zero, it breaks out of the inner for loop and skips to the next number to check. If it reaches divisor two and has found no divisor that yields a zero remainder, it has found the next prime number. It exits the inner for loop and sets <code>primeNum</code> equal to the number to check.</code></p> <p><code>For example, when <code>numToCheck</code> is 10, <code>findPrimes()</code> first divides 10 by 2 to get the first divisor, 5. It then performs the remainder operation on 10 and 5 and discovers a zero remainder. So it breaks out of the inner for loop and sets numToCheck to 11. (It doesn't ever set <code>primeNum</code> to 10.) It divides 11 by 2 to get the first divisor to check, once again 5. It performs the remainder operation on 11 and integers 5, 4, 3, and 2, none of which yield a zero remainder. It completes the inner for loop, sets primeNum equal to 11, and continues on to check 12.</code></p> <p><code>The bytecodes generated by <code>javac</code> for the <code>findPrimes</code> <code>()</code> method are shown below:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>0 iconst_1      // Push int constant 1 <p>1 istore_0      // Pop into local var 0: int primeNum = 1;</p> <p>2 iconst_2      // Push int constant 2</p> <p>3 istore_1      // Pop into local var 1: int numToCheck = 2;</p> <p></p> <p>// The outer for loop (the "forever" loop) begins here:</p> <p>4 iconst_1      // Push int constant 1</p> <p>5 istore_2      // Pop into local var 2: boolean foundPrime = true;</p> <p></p> <p>// The inner for loop begins here. First, initialize divisor.</p> <p>6 iload_1       // Push int in local var 1 (numToCheck)</p> <p>7 iconst_2      // Push int constant 2</p> <p>8 idiv          // Pop two ints, divide them, push int result</p> <p>// Pop int into local var 3:</p> <p>9 istore_3       // int divisor = numToCheck / 2;</p> <p></p> <p>// Next, test the inner for loop's termination condition</p> <p>10 goto 27       // Jump to for loop condition check</p> <p></p> <p>// The body of the inner for loop begins here.</p> <p>13 iload_1       // Push the int in local var 1 (numToCheck)</p> <p>14 iload_3       // Push the int in local var 3 (divisor)</p> <p>15 irem          // Pop two ints, remainder them, push result</p> <p>// Pop int, jump if equal to zero:</p> <p>16 ifne 24       // if (numToCheck % divisor == 0)</p> <p>19 iconst_0      // Push int constant 0</p> <p>20 istore_2      // Pop into local var 2: foundPrime = false;</p> <p>21 goto 32       // Jump out of inner for loop</p> <p></p> <p>// At this point, the body of the inner for loop is done. Now just</p> <p>// perform the third statement of the for expression: decrement</p> <p>// divisor.</p> <p>24 iinc 3 -1     // Increment local var 3 by -1: --divisor</p> <p></p> <p>// The test for the inner for loop's termination condition</p> <p>// begins here. This loop will keep on looping while (divisor</p></code> 1). <p>27 iload_3       // Push int from local var 3 (divisor)</p> <p>28 iconst_1      // Push int constant 1</p> <p>29 if_icmpgt 13  // Pop top two ints, jump if greater than</p> <p></p> <p>// At this point, the inner for loop has completed. Next check</p> <p>// to see if a prime number was found.</p> <p>32 iload_2       // Push int from local var 2 (foundPrime)</p> <p>33 ifeq 38       // Pop top int, jump if zero: if (foundPrime) {</p> <p>36 iload_1       // Push int from local var 1 (numToCheck)</p> <p>37 istore_0      // Pop into local var 0: primeNum = numToCheck;</p> <p>38 iinc 1 1      // Increment local var 1 by 1: ++numToCheck;</p> <p>41 goto 4        // Jump back to top of outer for loop.</p> <code><p></p></code> <code>end</code> </pre> <p><code>The <code>javac</code> compiler placed local variable <code>primeNum</code> from the source into local variable slots 0 on the stack frame. It put <code>numToCheck</code> into slot 1, <code>foundPrime</code> into slot 2, and <code>divisor</code> into slot 3. As mentioned above, as this method finds each successive prime number, it places the number into the <code>primeNum</code> variable. As you run the simulation, therefore, you will see the prime numbers appear sequentially in the <code>int</code> value stored in local variable slot 0.</code></p> <p><code>One thing to note about this bytecode sequence is that it demonstrates the way in which <code>boolean</code> s from Java source code are treated on the stack frame by Java bytecodes. The value stored in local variable slot 2, which represents the <code>boolean</code> <code>foundPrime</code> variable from the source, is an <code>int</code>. It is set to <code>true</code> or <code>false</code> by instructions that push a constant <code>int</code> zero or one. Its boolean value is checked by instructions that compare an <code>int</code> against zero.</code></p> <p><code>Another thing to note about this simulation is that eventually the <code>numToCheck</code> value will overflow. When it does, the virtual machine will throw no exceptions. It will just continue executing the <code>findPrimes()</code> method with <code>int</code> values that no longer hold any relationship to the prime numbers.</code></p> <p><code>To drive the <i>Prime Time</i> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.</code></p> <p><code><img src="images/fig12-2.gif" alt="figure 12-2"></code></p> <p><code><em> On the CD-ROM </em></code></p> <p><code>The CD-ROM contains the source code examples from this chapter in the <code>integer</code> directory. The <i>Prime Time</i> applet is contained in a web page on the CD-ROM in file <code>applets/PrimeTime.html</code>. The source code for this applet is found alongside its class files, in the <code>applets/JVMSimulators</code> and <code>applets/JVMSimulators</code>.</code></p> <p><code><em> The Resources Page </em></code></p> <p><code>For more information about the material presented in this chapter, visit the resources page: <code>https://www.artima.com/insidejvm/ed2/integer.html</code>.</code></p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="11.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="13.html">Next page</a>
                </div>
            </div>
            <hr/>
        </div>
    </div>
</div>

</body>
</html>


