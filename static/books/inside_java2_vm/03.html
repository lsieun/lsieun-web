<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>03 Security | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>03 Security</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="02.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="04.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr/>
                    <ul>
                        <li><a href="#on_the_cd">On the CD-ROM</a></li>
                        <li><a href="#resources_page">The Resources Page</a></li>
                    </ul>
                    <hr>
                    <p>Aside from platform independence, discussed in the previous chapter, the other major technical challenge a network-oriented software technology must deal with is security. Networks, because they allow computers to share data and distribute processing, can potentially serve as a way to break into a computer system, enabling someone to steal information, destroy information, or steal computing resources. As a consequence, connecting a computer to a network raises many security issues.</p>
                    <p>To address the security concerns raised by networks, Java's architecture comes with an extensive built-in security model. This chapter gives an overview of the security model built into Java's core architecture.</p>
                    <p><em> Why Security? </em></p>
                    <p>Java's security model is one of the key architectural features that makes it an appropriate technology for networked environments. Security is important because networks represent a potential avenue of attack to any computer hooked to them. This concern becomes especially strong in an environment in which software is downloaded across the network and executed locally, as is done, for example, with Java applets. Because the class files for an applet are automatically downloaded when a user goes to the containing web page in a browser, it is likely that a user will encounter applets from untrusted sources. Without any security, this would be a convenient way to spread viruses. Thus, Java's security mechanisms help make Java suitable for networks because they establish a needed trust in the safety of network-mobile code.</p>
                    <p>Java's security model is focused on protecting end-users from hostile programs downloaded across a network from untrusted sources. To accomplish this goal, Java provides a customizable "sandbox" in which Java programs run. A Java program must play only inside its sandbox. It can do anything within the boundaries of its sandbox, but can't take any action outside those boundaries. The sandbox for untrusted Java applets, for example, prohibits many activities, including:</p>
                    <ul>
                        <li>reading or writing to the local disk, </li>
                        <li>making a network connection to any but the host from which the applet came, </li>
                        <li>creating a new process, and </li>
                        <li>loading a new dynamic library and directly calling a native method. </li>
                    </ul>
                    <p>By making it impossible for downloaded code to perform certain actions, Java's security model protects the end-user from the threat of hostile code.</p>
                    <p><em> The Sandbox </em></p>
                    <p>Traditionally, you had to trust software before you ran it. You achieved security by being careful only to use software from trusted sources, and by regularly scanning for viruses just to make sure. Once some software got access to your system, it had full reign. If it was malicious, it could do a great deal of damage because there were no restrictions placed on it by the runtime environment of your computer. So in the traditional security scheme, you tried to prevent malicious code from ever gaining access to your computer in the first place.</p>
                    <p>The sandbox security model makes it easier to work with software that comes from sources you don't fully trust. Instead of approaching security by requiring you to prevent any code you don't trust from ever making its way onto your computer, the sandbox model allows you to welcome code from any source. But as code from an untrusted source runs, the sandbox restricts code from untrusted sources from taking any actions that could possibly harm your system. You don't need to figure out what code you can and can't trust. You don't need to scan for viruses. The sandbox itself prevents any viruses or other malicious code you may invite into your computer from doing any damage.</p>
                    <p>If you have a properly skeptical mind, you'll need to be convinced a sandbox has no leaks before you trust it to protect you. To make sure the sandbox must has no leaks, Java's security model involves every aspect of its architecture. If there were areas in Java's architecture where security was weak, a malicious programmer (a "cracker") could potentially exploit those areas to "go around" the sandbox. To understand the sandbox, therefore, you must look at several different parts of Java's architecture, and understand how they work together.</p>
                    <p>The fundamental components responsible for Java's sandbox are:</p>
                    <ul>
                        <li>the class loader architecture </li>
                        <li>the class file verifier </li>
                        <li>safety features built into the Java Virtual Machine (and the language) </li>
                        <li>the security manager and the Java API </li>
                    </ul>
                    <p>One of the greatest strengths of Java's security model is that two of these components, the class loader and the security manager, are customizable. By customizing these components, you can create a customized security policy for a Java application. As a developer, you may never need to create your own customized sandbox. You can often make use of sandboxes created by others. When you write and run a Java applet, for instance, you make use of a sandbox created by the developers of the web browser that hosts your applet.</p>
                    <p><em> The Class Loader Architecture </em></p>
                    <p>In Java's sandbox, the class loader architecture is the first line of defense. It is the class loader, after all, that brings code into the Java Virtual Machine--code that could be hostile. The class loader architecture contributes to Java's sandbox in two ways:</p> <ol> <li>it guards the borders of the trusted class libraries, and </li> <li>it prevents malicious code from interfering with benevolent code. </li> </ol>
                    <p>The class loader architecture guards the borders of the trusted class libraries by preventing an untrusted classes from pretending to be trusted. If a malicious class could successfully trick the Java Virtual Machine into believing it was a trusted class from the Java API, that malicious class could potentially break through the sandbox barrier. By preventing untrusted classes from impersonating trusted classes, the class loader architecture blocks one potential approach to compromising the security of the Java runtime.</p>
                    <p>The class loader architecture prevents malicious code from interfering with benevolent code by providing protected name -spaces for classes loaded by different class loaders. A <em>name-space</em> is a set of unique names for loaded classes that is maintained by the Java Virtual Machine. Once a Java Virtual Machine has loaded a class named <code>Volcano</code> into a particular name-space, for example, it is impossible to load a different class named <code>Volcano</code> into that same name-space. You can load multiple <code>Volcano</code> classes into a Java Virtual Machine, however, because you can create multiple name-spaces inside a Java application by creating multiple class loaders. If you create three separate name-spaces (one for each of three class loaders) in a running Java application, then, by loading one <code>Volcano</code> class into each name-space, your program could load three different <code>Volcano</code> classes into your application.</p>
                    <p>Name-spaces contribute to security because you can place a shield between classes loaded into different name-spaces. Inside the Java Virtual Machine, classes in the same name-space can interact with one another directly. Classes in different name-spaces, however, can't even detect each other's presence unless you explicitly provide a mechanism that allows them to interact. If a malicious class, once loaded, had guaranteed access to every other class currently loaded by the virtual machine, that class could potentially learn things it shouldn't know or interfere with the proper execution of your program.</p>
                    <p>Often, a class loader object relies on other class loaders--at the very least, upon the primordial class loader--to help it fulfill some of the class load requests that come its way. For example, imagine you write a Java application that installs a class loader whose particular manner of loading class files is by downloading them across a network. Assume that during the course of running the Java application, a request is made of your class loader to load a class named <code>Volcano</code>. One way you could write the class loader is to have it first asks the primordial class loader to find and load the class from its trusted repository. In this case, since <code>Volcano</code> is not a part of the Java API, assume the primordial class loader can't find a class named <code>Volcano</code>. When the primordial class loader responds that it can't load the class, your class loader could then attempt to load the <code>Volcano</code> class in its custom manner, by downloading it across the network. Assuming your class loader was able to download class <code>Volcano</code>, that <code>Volcano</code> class could then play a role in the application's future course of execution.</p>
                    <p>To continue with the same example, assume that at some time later a method of class <code>Volcano</code> is invoked for the first time, and that method references class <code>String</code> from the Java API. Because it is the first time the reference was used by the running program, the virtual machine asks your class loader (the one that loaded <code>Volcano</code> ) to load <code>String</code>. As before, your class loader first passes the request to the primordial class loader, but in this case, the primordial class loader is able to return a <code>String</code> class back to your class loader. (The primordial class loader most likely didn't have to actually load <code>String</code> at this point because, given that <code>String</code> is such a fundamental class in Java programs, it was almost certainly used before and therefore already loaded. Most likely, the primordial class loader just returned the <code>String</code> class that it had previously loaded from the trusted repository.) Since the primordial class loader was able to find the class, your class loader doesn't attempt to download it across the network; it merely passes to the virtual machine the <code>String</code> class returned by the primordial class loader. From that point forward, the virtual machine uses that <code>String</code> class whenever class <code>Volcano</code> references a class named <code>String</code>.</p>
                    <p>When you write a class loader, you create a new environment in which the loaded code runs. If you want the environment to be free of security holes, you must follow certain rules when you write your class loader. In general, you will want to write class loaders such that they protect the borders of trusted class libraries, such as those of the Java API.</p>
                    <p>Java allows classes in the same package to grant each other special access privileges that aren't granted to classes outside the package. So, if your class loader receives a request to load a class that by its name brazenly declares itself to be part of the Java API (for example, a class named <code>java.lang.Virus</code> ), it could gain special access to the trusted classes of <code>java.lang</code> and could possibly use that special access for devious purposes. Consequently, you would normally write a class loader so that it simply refuses to load any class that claims to be part of the Java API (or any other trusted runtime library), but that doesn't exist in the local trusted repository. In other words, after your class loader passes a request to the primordial class loader, and the primordial class loader indicates it can't load the class, your class loader should check to make sure the class doesn't declare itself to be a member of a trusted package. If it does, your class loader, instead of trying to download the class across the network, should throw a security exception.</p>
                    <p>In addition, you may have installed some packages in the trusted repository that contain classes you want your application to be able to load through the primordial class loader, but that you don't want to be accessible to classes loaded through your class loader. For example, assume you have created a package named <code>absolutepower</code> and installed it on the local repository accessible by the primordial class loader. Assume also that you don't want classes loaded by your class loader to be able to load any class from the <code>absolutepower</code> package. In this case, you would write your class loader such that the very first thing it does is make sure the requested class doesn't declare itself as a member of the <code>absolutepower</code> package. If such a class is requested, your class loader, rather than passing the class name to the primordial class loader, should throw a security exception.</p>
                    <p>The only way a class loader can know whether or not a class is from a restricted package, such as <code>java.lang</code>, or a forbidden package, such as <code>absolutepower</code>, is by the class's name. Thus a class loader must be given a list of the names of restricted and forbidden packages. Because the name of class <code>java.lang.Virus</code> indicates it is from the <code>java.lang</code> package, and <code>java.lang</code> is on the list of restricted packages, your class loader should throw a security exception if the primordial class loader can't load it. Likewise, because the name of class <code>absolutepower.FancyClassLoader</code> indicates it is part of the <code>absolutepower</code> package, and the <code>absolutepower</code> package is on the list of forbidden packages, your class loader should throw a security exception absolutely.</p>
                    <p>A common way, therefore, to write a security-minded class loader is using the following four steps:</p> <ol> <li>If packages exist that this class loader is not allowed to load from, the class loader checks whether the requested class is in one of those forbidden packages. If so, it throws a security exception. Else, it continues on to step two. </li> <li>The class loader passes the request to the primordial class loader. If the primordial class loader successfully returns the class, the class loader returns that same class. Else, it continues on to step three. </li> <li>If trusted packages exist that this class loader is not allowed to add classes to, the class loader checks whether the requested class is in one of those restricted packages. If so, it throws a security exception. Else, it continues on to step four. </li> <li>Finally, the class loader attempts to load the class in the custom way, such as by downloading it across a network. If successful, it returns the class. Else, it throws a "no class definition found" error. </li> </ol>
                    <p>By performing steps one and three as outlined above, the class loader guards the borders of the trusted packages. With step one, it prevents a class from a forbidden package to be loaded at all. With step three, it doesn't allow an untrusted class to insert itself into a trusted package.</p>
                    <p><em> The Class File Verifier </em></p>
                    <p>Working in conjunction with the class loader, the class file verifier ensures that loaded class files have a proper internal structure. If the class file verifier discovers a problem with a class file, it throws an exception. Although compliant Java compilers should not generate malformed class files, a Java Virtual Machine can't tell how a particular class file was created. Because a class file is just a sequence of binary data, a virtual machine can't know whether a particular class file was generated by a well-meaning Java compiler or by shady crackers bent on compromising the integrity of the virtual machine. As a consequence, all Java Virtual Machine implementations have a class file verifier that can be invoked on untrusted classes, to make sure the classes are safe to use.</p>
                    <p>One of the security goals that the class file verifier helps achieve is program robustness. If a buggy compiler or savvy cracker generated a class file that contained a method whose bytecodes included an instruction to jump beyond the end of the method, that method could, if it were invoked, cause the virtual machine to crash. Thus, for the sake of robustness, it is important that the virtual machine verify the integrity of the bytecodes it imports. Although Java Virtual Machine designers are allowed to decide when their virtual machines will perform these checks, many implementations will do most checking just after a class is loaded. Such a virtual machine, rather than checking every time it encounters a jump instruction as it executes bytecodes, analyzes bytecodes (and verifies their integrity) once, before they are ever executed. As part of its verification of bytecodes, the Java Virtual Machine makes sure all jump instructions cause a jump to another valid instruction in the bytecode stream of the method. In most cases, checking all bytecodes once, before they are executed, is a more efficient way to guarantee robustness than checking every bytecode instruction every time it is executed.</p>
                    <p>A class file verifier that performs its checking as early as possible most likely operates in two distinct phases. During phase one, which takes place just after a class is loaded, the class file verifier checks the internal structure of the class file, including verifying the integrity of the bytecodes it contains. During phase two, which takes place as bytecodes are executed, the class file verifier confirms the existence of symbolically referenced classes, fields, and methods.</p>
                    <p>Phase One: Internal Checks</p>
                    <p>During phase one, the class file verifier checks everything that's possible to check in a class file by looking at only the class file itself. In addition to verifying the integrity of the bytecodes during phase one, the verifier performs many checks for proper class file format and internal consistency. For example, every class file must start with the same four bytes, the magic number: <code>0xCAFEBABE</code>. The purpose of magic numbers is to make it easy for file parsers to recognize a certain type of file. Thus, the first thing a class file verifier likely checks is that the imported file does indeed begin with <code>0xCAFEBABE</code>.</p>
                    <p>The class file verifier also checks to make sure the class file is neither truncated nor enhanced with extra trailing bytes. Although different class files can be different lengths, each individual component contained inside a class file indicates its length as well as its type. The verifier can use the component types and lengths to determine the correct total length for each individual class file. In this way, it can verify that the imported file has a length consistent with its internal contents.</p>
                    <p>The verifier also looks at individual components, to make sure they are well- formed instances of their type of component. For example, a method descriptor (its return type and the number and types of its parameters) is stored in the class file as a string that must adhere to a certain context-free grammar. One check the verifier performs on individual components is to make sure each method descriptor is a well-formed string of the appropriate grammar.</p>
                    <p>In addition, the class file verifier checks that the class itself adheres to certain constraints placed upon it by the specification of the Java programming language. For example, the verifier enforces the rule that all classes, except class <code>Object</code>, must have a superclass. Thus, the class file verifier checks at run-time some of the Java language rules that should have been enforced at compile-time. Because the verifier has no way of knowing if the class file was generated by a benevolent, bug-free compiler, it checks each class file to make sure the rules are followed.</p>
                    <p>Once the class file verifier has successfully completed the checks for proper format and internal consistency, it turns its attention to the bytecodes. During this part of phase one, which is commonly called the "bytecode verifier," the Java Virtual Machine performs a data-flow analysis on the streams of bytecodes that represent the methods of the class. To understand the bytecode verifier, you need to understand a bit about bytecodes and frames.</p>
                    <p>The bytecode streams that represent Java methods are a series of one-byte instructions, called <em>opcodes</em>, each of which may be followed by one or more <em>operands</em>. The operands supply extra data needed by the Java Virtual Machine to execute the opcode instruction. The activity of executing bytecodes, one opcode after another, constitutes a thread of execution inside the Java Virtual Machine. Each thread is awarded its own <em>Java Stack</em>, which is made up of discrete <em>frames</em>. Each method invocation gets its own frame, a section of memory where it stores, among other things, local variables and intermediate results of computation. The part of the frame in which a method stores intermediate results is called the method's <em>operand stack</em>. An opcode and its (optional) operands may refer to the data stored on the operand stack or in the local variables of the method's frame. Thus, the virtual machine may use data on the operand stack, in the local variables, or both, in addition to any data stored as operands following an opcode when it executes the opcode.</p>
                    <p>The bytecode verifier does a great deal of checking. It checks to make sure that no matter what path of execution is taken to get to a certain opcode in the bytecode stream, the operand stack always contains the same number and types of items. It checks to make sure no local variable is accessed before it is known to contain a proper value. It checks that fields of the class are always assigned values of the proper type, and that methods of the class are always invoked with the correct number and types of arguments. The bytecode verifier also checks to make sure that each opcode is valid, that each opcode has valid operands, and that for each opcode, values of the proper type are in the local variables and on the operand stack. These are just a few of the many checks performed by the bytecode verifier, which is able, through all its checking, to verify that a stream of bytecodes is safe for the Java Virtual Machine to execute.</p>
                    <p>Phase one of the class file verifier makes sure the imported class file is properly formed, internally consistent, adheres to the constraints of the Java programming language, and contains bytecodes that will be safe for the Java Virtual Machine to execute. If the class file verifier finds that any of these are not true, it throws an error, and the class file is never used by the program.</p>
                    <p>Phase Two: Verification of Symbolic References</p>
                    <p>Although phase one happens immediately after the Java Virtual Machine loads a class file, phase two is delayed until the bytecodes contained in the class file are actually executed. During phase two, the Java Virtual Machine follows the references from the class file being verified to the referenced class files, to make sure the references are correct. Because phase two has to look at other classes external to the class file being checked, phase two may require that new classes be loaded. Most Java Virtual Machine implementations will likely delay loading classes until they are actually used by the program. If an implementation does load classes earlier, perhaps in an attempt to speed up the loading process, then it must still give the impression that it is loading classes as late as possible. If, for example, a Java Virtual Machine discovers during early loading that it can't find a certain referenced class, it doesn't throw a "class definition not found" error until (and unless) the referenced class is used for the first time by the running program. Therefore, phase two, the checking of symbolic references, is usually delayed until each symbolic reference is actually used for the first time during bytecode execution.</p>
                    <p>Phase two of class file verification is really just part of the process of dynamic linking. When a class file is loaded, it contains symbolic references to other classes and their fields and methods. A symbolic reference is a character string that gives the name and possibly other information about the referenced item--enough information to uniquely identify a class, field, or method. Thus, symbolic references to other classes give the full name of the class; symbolic references to the fields of other classes give the class name, field name, and field descriptor; symbolic references to the methods of other classes give the class name, method name, and method descriptor.</p>
                    <p>Dynamic linking is the process of <em>resolving</em> symbolic references into direct references. As the Java Virtual Machine executes bytecodes and encounters an opcode that, for the first time, uses a symbolic reference to another class, the virtual machine must resolve the symbolic reference. The virtual machine performs two basic tasks during resolution:</p> <ol> <li>find the class being referenced (loading it if necessary) </li> <li>replace the symbolic reference with a direct reference, such as a pointer or offset, to the class, field, or method </li> </ol>
                    <p>The virtual machine remembers the direct reference so that if it encounters the same reference again later, it can immediately use the direct reference without needing to spend time resolving the symbolic reference again.</p>
                    <p>When the Java Virtual Machine resolves a symbolic reference, phase two of the class file verifier makes sure the reference is valid. If the reference is not valid--for instance, if the class cannot be loaded or if the class exists but doesn't contain the referenced field or method--the class file verifier throws an error.</p>
                    <p>As an example, consider again the <code>Volcano</code> class. If a method of class <code>Volcano</code> invokes a method in a class named <code>Lava</code>, the name and descriptor of the method in <code>Lava</code> are included as part of the binary data in the class file for <code>Volcano</code>. So, during the course of execution when the <code>Volcano</code>'s method first invokes the <code>Lava</code>'s method, the Java Virtual Machine makes sure a method exists in class <code>Lava</code> that has a name and descriptor that matches those expected by class <code>Volcano</code>. If the symbolic reference (class name, method name and descriptor) is correct, the virtual machine replaces it with a direct reference, such as a pointer, which it will use from then on. But if the symbolic reference from class <code>Volcano</code> doesn't match any method in class <code>Lava</code>, phase two verification fails, and the Java Virtual Machine throws a "no such method" error.</p>
                    <p>Binary Compatibility</p>
                    <p>The reason phase two of the class file verifier must look at classes that refer to one</p> nother to make sure they are compatible is because Java programs are dynamically linked. Java compilers will often recompile classes that depend on a class you have changed, and in so doing, detect any incompatibility at compile-time. But there may be times when your compiler doesn't recompile a dependent class. For example, if you are developing a large system, you will likely partition the various parts of the system into packages. If you compile each package separately, then a change to one class in a package would cause a recompilation of affected classes within that same package, but not necessarily in any other package. Moreover, if you are using someone else's packages, especially if your program downloads class files from someone else's package across a network as it runs, it may be impossible for you to check for compatibility at compile-time. That's why phase two of the class file verifier must check for compatibility at run-time.
                    <p>As an example of incompatible changes, imagine you compiled class <code>Volcano</code> (from the above example) with a Java compiler. Because a method in <code>Volcano</code> invokes a method in another class named <code>Lava</code>, the Java compiler would look for a class file or a source file for class <code>Lava</code> to make sure there was a method in <code>Lava</code> with the appropriate name, return type, and number and types of arguments. If the compiler couldn't find any <code>Lava</code> class, or if it encountered a <code>Lava</code> class that didn't contain the desired method, the compiler would generate an error and would not create a class file for <code>Volcano</code>. Otherwise, the Java compiler would produce a class file for <code>Volcano</code> that is compatible with the class file for <code>Lava</code>. In this case, the Java compiler refused to generate a class file for <code>Volcano</code> that wasn't already compatible with class <code>Lava</code>.</p>
                    <p>The converse, however, is not necessarily true. The Java compiler could conceivably generate a class file for <code>Lava</code> that isn't compatible with <code>Volcano</code>. If the <code>Lava</code> class doesn't refer to <code>Volcano</code>, you could potentially change the name of the method <code>Volcano</code> invokes from the <code>Lava</code> class, and then recompile only the <code>Lava</code> class. If you tried to run your program using the new version of <code>Lava</code>, but still using the old version of <code>Volcano</code> that wasn't recompiled since you made your change to <code>Lava</code>, the Java Virtual Machine would, as a result of phase two class file verification, throw a "no such method" error when <code>Volcano</code> attempted to invoke the now non-existent method in <code>Lava</code>.</p>
                    <p>In this case, the change to class <code>Lava</code> broke <em>binary compatibility</em> with the pre-existing class file for <code>Volcano</code>. In practice, this situation may arise when you update a library you have been using, and your existing code isn't compatible with the new version of the library. To make it easier to alter the code for libraries, the Java programming language was designed to allow you to make many kinds of changes to a class that don't require recompilation of classes that depend upon it. The changes you are allowed to make, which are listed in the Java Language Specification, are called the rules of binary compatibility. These rules clearly define what can be changed, added, or deleted in a class without breaking binary compatibility with pre-existing class files that depend on the changed class. For example, it is always a binary compatible change to add a new method to a class, but never to delete a method that other classes may be using. So in the case of <code>Lava</code>, you violated the rules of binary compatibility when you changed the name of the method used by <code>Volcano</code>, because you in effect deleted the old method and added a new. If you had, instead, added the new method and then rewritten the old method so it calls the new, that change would have been binary compatible with any pre-existing class file that already used <code>Lava</code>, including <code>Volcano</code>.</p>
                    <p><em> Safety Features Built Into the Java Virtual Machine </em></p>
                    <p>Once the Java Virtual Machine has loaded a class and performed phase one of class file verification, the bytecodes are ready to be executed. Besides the verification of symbolic references (phase two of class file verification), the Java Virtual Machine has several other built-in security mechanisms operating as bytecodes are executed. These are the same mechanisms listed in Chapter 1 as features of the Java programming language that make Java programs robust. They are, not surprisingly, also features of the Java Virtual Machine:</p> <ul> <li>type-safe reference casting </li> <li>structured memory access (no pointer arithmetic) </li> <li>automatic garbage collection (can't explicitly free allocated memory) </li> <li>array bounds checking </li> <li>checking references for <code>null</code> </li> </ul>
                    <p>By granting a Java program only safe, structured ways to access memory, the Java Virtual Machine makes Java programs more robust, but it also makes their execution more secure. Why? There are two reasons. First, a program that corrupts memory, crashes, and possibly causes other programs to crash represents one kind of security breach. If you are running a mission critical server process, it is critical that the process doesn't crash. This level of robustness is also important in embedded systems, such as a cell phone, which people don't usually expect to have to reboot. The second reason unrestrained memory access would be a security risk is because a wily cracker could potentially use it to subvert the security system. If, for example, a cracker could learn where in memory a class loader is stored, it could assign a pointer to that memory and manipulate the class loader's data. By enforcing structured access to memory, the Java Virtual Machine yields programs that are robust, but also frustrates crackers who dream of harnessing the internal memory of the Java Virtual Machine for their own devious plots.</p>
                    <p>Another safety feature built into the Java Virtual Machine--one that serves as a backup to structured memory access--is the unspecified manner in which the runtime data areas are laid out inside the Java Virtual Machine. The <em>runtime data areas</em> are the memory areas in which the Java Virtual Machine stores the data it needs to execute a Java application: Java stacks (one for each thread), a <em>method area</em>, where bytecodes are stored, and a <em>garbage-collected heap</em>, where the objects created by the running program are stored. If you peer into a class file, you won't find any memory addresses. When the Java Virtual Machine loads a class file, it decides where in its internal memory to put the bytecodes and other data it parses from the class file. When the Java Virtual Machine starts a thread, it decides where to put the Java stack it creates for the thread. When it creates a new object, it decides where in memory to put the object. Thus, a cracker cannot predict by looking at a class file where in memory the data representing that class, or objects instantiated from that class, will be kept. What's worse (for the cracker) is the cracker can't tell anything about memory layout by reading the Java Virtual Machine specification either. The manner in which a Java Virtual Machine lays out its internal data is not part of the specification. The designers of each Java Virtual Machine implementation decide which data structures their implementation will use to represent the runtime data areas, and where in memory their implementation will place them. As a result, even if a cracker were somehow able to break through the Java Virtual Machine's memory access restrictions, they would next be faced with the difficult task of finding something to subvert by looking around.</p>
                    <p>The prohibition on unstructured memory access is not something the Java Virtual Machine must actively enforce on a running program; rather, it is intrinsic to the bytecode instruction set itself. Just as there is no way to express an unstructured memory access in the Java programming language, there is also no way to express it in bytecodes--even if you write the bytecodes by hand. Thus, the prohibition on unstructured memory access is a solid barrier against the malicious manipulation of memory.</p>
                    <p>There is, however, a way to penetrate the security barriers erected by the Java Virtual Machine. Although the bytecode instruction set doesn't give you an unsafe, unstructured way to access memory, there is a way you can go around bytecodes: native methods. Basically, when you call a native method, Java's security sandbox becomes dust in the wind. First of all, the robustness guarantees don't hold for native methods. Although you can't corrupt memory from a Java method, you can from a native method. But most importantly, native methods don't go through the Java API (they are how you go around the Java API) so the security manager isn't checked before a native method attempts to do something that could be potentially damaging. (This is, of course, often how the Java API itself gets anything done. But the native methods used by the Java API are "trusted.") Thus, once a thread gets into a native method, no matter what security policy was established inside the Java Virtual Machine, it doesn't apply anymore to that thread, so long as that thread continues to execute the native method. This is why the security manager includes a method that establishes whether or not a program can load dynamic libraries, which are necessary for invoking native methods. Applets, for example, aren't allowed to load a new dynamic library, therefore they can't install their own new native methods. They can, however, call methods in the Java API, methods which may be native, but which are always trusted. When a thread invokes a native method, that thread leaps outside the sandbox. The security model for native methods is, therefore, the same security model described earlier as the traditional approach to computer security: you have to trust a native method before you call it.</p>
                    <p>One final mechanism that is built into the Java Virtual Machine that contributes to security is structured error handling with exceptions. Because of its support for exceptions, the Java Virtual Machine has something structured to do when a security violation occurs. Instead of crashing, the Java Virtual Machine can throw an exception or an error, which may result in the death of the offending thread, but shouldn't crash the system. Throwing an error (as opposed to throwing an exception) almost always results in the death of the thread in which the error was thrown. This is usually a major inconvenience to a running Java program, but won't necessarily result in termination of the entire program. If the program has other threads doing useful things, those threads may be able to carry on without their recently departed colleague. Throwing an exception, on the other hand, may result in the death of the thread, but is often just used as a way to transfer control from the point in the program where the exception condition arose to the point in the program where the exception condition is handled.</p>
                    <p><em> The Security Manager and the Java API </em></p>
                    <p>By using class loaders, you can prevent code loaded by different class loaders from interfering with one another inside the Java Virtual Machine, but to protect assets external to the Java Virtual Machine, you must use a security manager. The security manager defines the outer boundaries of the sandbox. Because it is customizable, the security manager allows you to establish a custom security policy for an application. The Java API enforces the custom security policy by asking the security manager for permission before it takes any action that is potentially unsafe. For each potentially unsafe action, there is a method in the security manager that defines whether that action is allowed by the sandbox. Each method's name starts with "check," so for example, <code>checkRead()</code> defines whether or not a thread is allowed to read to a specified file, and <code>checkWrite()</code> defines whether or not a thread is allowed to write to a specified file. The implementation of these methods is what defines the custom security policy of the application.</p>
                    <p>Most of the activities that are regulated by a "check" method are listed below. The classes of the Java API check with the security manager before they:</p>
                    <ul>
                        <li>accept a socket connection from a specified host and port number </li>
                        <li>modify a thread (change its priority, stop it, etc &ndash;) </li>
                        <li>open a socket connection to a specified host and port number </li>
                        <li>create a new class loader </li>
                        <li>delete a specified file </li>
                        <li>create a new process </li>
                        <li>cause the application to exit </li>
                        <li>load a dynamic library that contains native methods </li>
                        <li>wait for a connection on a specified local port number </li>
                        <li>load a class from a specified package (used by class loaders) </li>
                        <li>add a new class to a specified package (used by class loaders) </li>
                        <li>access or modify system properties </li>
                        <li>access a specified system property </li>
                        <li>read from a specified file </li>
                        <li>write to a specified file </li>
                    </ul>
                    <p>Because the Java API always checks with the security manager before it performs any of the activities listed above, the Java API will not perform any action forbidden under the security policy established by the security manager.</p>
                    <p>Two actions not present in the above list that could potentially be unsafe are allocation of memory and invocation of threads. Currently, a hostile applet that can possibly crash the browser by:</p>
                    <ul>
                        <li>allocating memory until it runs out </li>
                        <li>firing off threads until everything slows to a crawl </li>
                    </ul>
                    <p>These kinds of attacks are called <em>denial of service</em>, because the deny the end-users from using their own computers. The security manager does not allow you to enforce any kind of limit on allocated memory or thread creation. (There are no <code>checkAllocateMemory()</code> or <code>checkCreateThread()</code> methods in the security manager class.) The difficulty in attempting to thwart this kind of hostile code is that it is hard to tell the difference, for example, between a hostile applet allocating a lot of memory and an image processing applet attempting to do useful work. Other kinds of hostile applets that are currently possible are:</p>
                    <ul>
                        <li>applets that send unauthorized e-mail from the end-user's computer </li>
                        <li>applets that make annoying noises even after you leave the web page </li>
                        <li>applets that display offensive images or animations </li>
                    </ul>
                    <p>So a security manager isn't enough to prevent every possible action that could possibly offend or inconvenience an end-user. Other than the attacks listed here, however, the security manager attempts to provide a check method that allows you to control access to any potentially unsafe action.</p>
                    <p>When a Java application starts, it has no security manager, but the application can install one at its option. If it does not install a security manager, there are no restrictions placed on any activities requested of the Java API--the Java API will do whatever it is asked. (This is why Java applications, by default, do not have any security restrictions such as those that limit the activities of untrusted applets.) If the application does install a security manager, then that security manager will be in charge for the entire remainder of the lifetime of that application. It can't be replaced, extended, or changed. From that point on, the Java API will only fulfill those requests that are sanctioned by the security manager.</p>
                    <p>In general, a "check" method of the security manager throws a security exception if the checked upon activity is forbidden, and simply returns if the activity is permitted. Therefore, the procedure a Java API method generally follows when it is about to perform a potentially unsafe activity involves two steps. First, the Java API code checks whether a security manager has been installed. If not, it skips step two and goes ahead with the potentially unsafe action. Otherwise, as step two, it calls the appropriate "check" method in the security manager. If the action is forbidden, the "check" method will throw a security exception, which will cause the Java API method to immediately abort. The potentially unsafe action will never be taken. If, on the other hand, the action is permitted, the "check" method will simply return. In this case, the Java API method carries on and performs the potentially unsafe action.</p>
                    <p>Although you can only install one security manager, you can write the security manager so that it establishes multiple security policies. In addition to the "check" methods, the security manager also has methods that allow you to determine if a request is being made either directly or indirectly from a class loaded by a class loader object, and if so, which class loader object. This enables you to implement a security policy that varies depending upon which class loader loaded the classes making the request. You can also vary the security policy based on information about the class files loaded by the class loader, such whether or not the class files were down loaded across a network or imported from the local disk. So even though an application can only have one security manager, that security manager can establish a flexible security policy that varies depending upon the trustworthiness of the code requesting the potentially unsafe action.</p>
                    <p><em> Authentication </em></p>
                    <p>The support for authentication introduced in Java 1.1 in the <code>java.security</code> package expands your ability to establish multiple security policies by enabling you to implement a sandbox that varies depending upon who actually created the code. Authentication allows you to verify that a set of class files was blessed as trustworthy by some vendor, and that the class files were not altered en route to your virtual machine. Thus, to the extent you trust the vendor, you can ease the restrictions placed on the code by the sandbox. You can establish different security policies for code that comes from different vendors.</p>
                    <p>For links to more information about authentication and <code>java.security</code>, visit the resources page for this chapter.</p>
                    <p><em> Security Beyond the Architecture </em></p>
                    <p>Security is a tradeoff between cost and risk: the lower the security risk, the higher the cost of security. The costs associated with any computer or network security strategy must be weighed against the costs that would be associated with the theft or destruction of the information or computing resources being protected. The nature of a computer or network security strategy should be shaped by the value of the assets being protected.</p>
                    <p>To be effective, a computer or network security strategy must be comprehensive. It cannot consist exclusively of a sandbox for running downloaded Java code. For instance, it may not matter much that the Java applets you download from the internet and run on your computer can't read the word processing file of your top-secret business plan if you:</p> <ul> <li>routinely download untrusted native executables from the internet and run them </li> <li>throw away extra printed copies of your business plan without shredding them </li> <li>leave your doors unlocked when you're gone </li> <li>hire someone to help you who is actually a spy for your arch-rival </li> </ul>
                    <p>In the context of a comprehensive security strategy, however, Java's security model can play a useful role.</p>
                    <p>The nice thing about Java's security model is that once you set it up, it does most of the work for you. You don't have to worry about whether a particular program is trusted or not--the Java runtime will determine that for you; and if it is untrusted, the Java runtime will protect your assets by encasing the untrusted code in a sandbox.</p>
                    <p>End-users of Java software cannot rely only on the security mechanisms built into Java's architecture. They must have a comprehensive security policy appropriate to their actual security requirements.</p>
                    <p>Similarly, the security strategy of Java technology itself does not rely exclusively on the architectural security mechanisms described in this chapter. For example, one aspect of Java's security strategy is that anyone can sign a license agreement and get a copy of the source code of Sun's Java Platform implementation. Instead of keeping the internal implementation of Java's security architecture a secret "black box," it is open to anyone who wishes to look at it. This encourages security experts seeking a good technical challenge to try and find security holes in the implementation. When security holes are discovered, they can be patched. Thus, the openness of Java's internal implementation is part of Java's overall security strategy.</p>
                    <p>Besides openness, there are several other aspects to Java's overall security strategy that don't directly involve its architecture. You can find out more information about these on the resources page for this chapter.</p>
                    <p><em> The Resources Page </em></p>
                    <p>For more information about Java and security, see the resource page for this chapter: <code>http://www.artima.com/insidejvm/security.html</code>.</p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="02.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="04.html">Next page</a>
                </div>
            </div>
            <hr/>
        </div>
    </div>

</div>

</body>
</html>


