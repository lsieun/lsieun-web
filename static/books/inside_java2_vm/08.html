<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>08 The Linking Model | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
<div class="row">
<div class="twelve columns">

<div class="row test">
    <h1>08 The Linking Model</h1>
</div>
<div class="u-cf"></div>

<div class="row">
    <div class="one-third column value">
        <a class="button button-primary mod" href="07.html">Previous page</a>
    </div>
    <div class="one-third column value" style="text-align:center;">
        <a class="button button-primary mod" href="index.html">Table of content</a>
    </div>
    <div class="one-third column value">
        <a class="button button-primary mod u-pull-right" href="09.html">Next page</a>
    </div>
</div>

<div class="content index ">
<div class="u-cf"></div>

<div class="waka">
<hr/>
<ul>
    <li><a href="#dynamic_linking_and_resolution">Dynamic Linking and Resolution</a></li>
    <li><a href="#resolution_and_dynamic_extension">Resolution and Dynamic Extension</a></li>

    <li>
        <a href="#constant_pool_resolution">Constant Pool Resolution</a>
        <ul>
            <li>
                <a href="#resolution_of_class_info">Resolution of CONSTANT_Class_info Entries</a>
                <ul>
                    <li><a href="#array_classes">Array Classes</a></li>
                    <li>
                        <a href="#non_array_classes_and_interfaces">Non-Array Classes and Interfaces</a>
                        <ul>
                            <li><a href="#step1">Step 1. Load the Type and any Superclasses</a></li>
                            <li>
                                <a href="#step2">Step 2. Link and Initialize the Type and any Superclasses</a>
                                <ul>
                                    <li><a href="#step2a">Step 2a. Verify the Type</a></li>
                                    <li><a href="#step2b">Step 2b. Prepare the Type</a></li>
                                    <li><a href="#step2c">Optional Step 2c. Resolve the Type</a></li>
                                    <li><a href="#step2d">Step 2d. Initialize the Type</a></li>
                                    <li><a href="#step2e">Step 2e. Check Access Permission</a></li>
                                </ul>
                            </li>

                        </ul>
                    </li>

                </ul>
            </li>
            <li><a href="#resolution_of_field_ref_info">Resolution of CONSTANT_Fieldref_info Entries</a></li>
            <li><a href="#resolution_of_method_ref_info">Resolution of CONSTANT_Methodref_info Entries</a></li>
            <li><a href="#resolution_of_interface_method_ref_info">Resolution of CONSTANT_InterfaceMethodref_info Entries</a></li>
            <li><a href="#resolution_of_string_info">Resolution of CONSTANT_String_info Entries</a></li>
            <li><a href="#resolution_of_other_types">Resolution of Other Types of Entries</a></li>

        </ul>
    </li>
    <li><a href="#compile_time_resolution_of_constant">Compile-Time Resolution of Constants</a></li>
    <li><a href="#direct_references">Direct References</a></li>
    <li><a href="#quick_instructions">_quick Instructions</a></li>
    <li><a href="#salutation_application">Example: The Linking of the Salutation Application</a></li>
    <li><a href="#greet_application">Example: The Dynamic Extension of the Greet Application</a></li>
    <li><a href="#unloading_greeters">Example: Unloading Unreachable Greeters</a></li>
    <li><a href="#on_the_cd">On the CD-ROM</a></li>
    <li><a href="#resources_page">The Resources Page</a></li>
</ul>

<hr>
<p>
    From the programmer's perspective, one of the most important aspects of Java's architecture to understand is the linking model.
    As mentioned in earlier chapters, Java's linking model allows you to design class loader objects that extend your application in custom ways at run-time.
    Through class loader objects, your application can load and dynamically link to classes and interfaces that were unknown or did not even exist when your application was compiled.
    <span class="note">note：java architecture --&gt; one of the most important aspects --&gt; linking model</span>
</p>
<p>
    The engine that drives Java's linking model is the process of resolution.
    The previous chapter described in detail all the various stages in the lifetime of a class, except for resolution.
    This chapter looks at resolution in depth, and shows how the process of resolution fits in with dynamic extension.
    It gives an overview of the linking model,
    explains constant pool resolution,
    describes method tables,
    shows how to write and use class loaders,
    and gives several examples.
    <span class="note">note：linking model --&gt; engine --&gt; the process of resolution</span>
</p>



<h2 id="dynamic_linking_and_resolution">Dynamic Linking and Resolution</h2>
<p>
    When you compile a Java program, you get a separate class file for each class or interface in your program.
    Although the individual class files may appear to be independent, they actually harbor symbolic connections to one another and to the class files of the Java API.
    When you run your program, the Java Virtual Machine loads your program's classes and interfaces and hooks them together in a process of <i>dynamic linking</i>.
    As your program runs, the Java Virtual Machine builds an internal web of interconnected classes and interfaces.
    <span class="note">note：dynamic linking</span>
</p>
<p>
    A class file keeps all its symbolic references in one place, the constant pool.
    Each class file has a constant pool, and each class or interface loaded by the Java Virtual Machine has an internal version of its constant pool.
    The internal constant pool is an implementation-specific data structure that maps to the constant pool in the class file.
    Thus, after a type is initially loaded, all the symbolic references from the type reside in the type's internal constant pool.
    <span class="note">note：runtime constant pool</span>
</p>
<p>
    At some point during the running of a program, if a particular symbolic reference is to be used, it must be <i>resolved</i>.
    Resolution is the process of finding the entity identified by the symbolic reference and replacing the symbolic reference with a direct reference.
    Because all symbolic references reside in the constant pool, this process is often called <i>constant pool resolution</i>.
    <span class="note">note：constant pool resolution</span>
</p>
<p>
    As described in Chapter 6, "The Java Class File," the constant pool is organized as a sequence of items.
    Each item has a unique index, much like an array element.
    A symbolic reference is one kind of item that may appear in the constant pool.
    Java Virtual Machine instructions that use a symbolic reference specify the index in the constant pool where the symbolic reference resides.
    For example, the <code>getstatic</code> opcode, which pushes the value of a static field onto the stack, is followed in the bytecode stream by an index into the constant pool.
    The constant pool entry at the specified index, a <code>CONSTANT_Fieldref_info</code> entry, reveals the fully qualified name of the class in which the field resides,
    and the name and type of the field.
    <span class="note">note：the constant pool is organized as a sequence of items.</span>
</p>
<p>
    Keep in mind that the Java Virtual Machine contains a separate internal constant pool for each class and interface it loads.
    When an instruction refers to the fifth item in the constant pool,
    it is referring to the fifth item in the constant pool for the current class,
    the class that defined the method the Java Virtual Machine is currently executing.
    <span class="note">note：internal constant pool</span>
</p>
<p>
    Several instructions, from the same or different methods, may refer to the same constant pool entry, but each constant pool entry is resolved only once.
    After a symbolic reference has been resolved for one instruction,
    subsequent attempts to resolve it by other instructions take advantage of the hard work already done,
    and use the same direct reference resulting from the original resolution.
    <span class="note">note：each constant pool entry is resolved only once</span>
</p>
<p>
    Linking involves not only the replacement of symbolic references with direct ones, it also involves checking for correctness and permission.
    As mentioned in Chapter 7, "The Lifetime of a Class," the checking of symbolic references for existence and access permission (one aspect of the full verification phase) is likely performed during resolution.
    For example, when a Java Virtual Machine resolves a <code>getstatic</code> instruction to a field of another class,
    the Java Virtual Machine checks to make sure that:
    <span class="note">note：Linking involves not only the replacement of symbolic references with direct ones, it also involves checking for correctness and permission.</span>
</p>
<ul>
    <li>The other class exists.</li>
    <li>This class has permission to access the other class.</li>
    <li>The named field exists in the other class.</li>
    <li>The field has the expected type (symbolic references to fields include the field type).</li>
    <li>This class has permission to access the field.</li>
    <li>That the field is really static--a class variable and not an instance variable.</li>
</ul>
<p>
    If any of these checks fail, an error is thrown and resolution fails.
    Otherwise, the symbolic reference is replaced by the direct reference and resolution succeeds.
</p>
<p>
    As described in Chapter 7, "The Lifetime of a Class,"
    different implementations of the Java Virtual Machine are permitted to perform resolution at different times during the execution of a program.
    An implementation may choose to link everything up front by following all symbolic references from the initial class,
    then all symbolic references from subsequent classes,
    until every symbolic reference has been resolved.
    In this case, the application would be completely linked before its <code>main()</code> method was ever invoked.
    This approach is called <i>early resolution</i>.
    Alternatively, an implementation may choose to wait until the very last minute to resolve each symbolic reference.
    In this case, the Java Virtual Machine would resolve a symbolic reference only when it is first used by the running program.
    This approach is called <i>late resolution</i>.
    Other implementations could choose a resolution strategy in-between these two extremes.
    <span class="note">note：when to perform resolution? early resolution or late resolution</span>
</p>
<p>
    Although a Java Virtual Machine implementation has some freedom in choosing when to resolve symbolic references,
    every Java Virtual Machine must give the outward impression that it uses late resolution.
    No matter when a particular Java Virtual Machine performs its linking,
    it will always throw any error that results from attempting to resolve a symbolic reference at the point in the execution of the program
    where the symbolic reference was actually used for the first time.
    In this way, it will always appear to the user as if the linking were late.
    If a Java Virtual Machine does early linking, and during early linking discovers that a class file is missing,
    it won't report the class file missing by throwing the appropriate error until later in the program when something in that class file is actually used.
    If the class is never used by the program, the error will never be thrown.
    <span class="note">note：every Java Virtual Machine must give the outward impression that it uses late resolution</span>
</p>



<h2 id="resolution_and_dynamic_extension">Resolution and Dynamic Extension</h2>
<p>
    In addition to simply linking types at run-time, Java applications can decide at run-time which types to link.
    Java's architecture allows Java programs to be <i>dynamically extended</i>, the process of deciding at run-time other types to use, loading them, and using them.
    You can dynamically extend a Java application by creating a class loader object and using it to load types that are not part of your original application,
    but are determined by your running application.
    An example of dynamic extension is a Java-capable web browser loading class files for applets from across a network.
    When the browser starts, it doesn't know what class files it will be loading across the network.
</p>
<p>
    To dynamically extend a Java application, you must include a class loader as part of your application.
    To create your own class loader, you write a subclass of <code>java.lang.ClassLoader</code> and implement the <code>loadClass()</code> method.
    When the <code>loadClass()</code> method of a class loader successfully loads a type,
    it returns a <code>java.lang.Class</code> object to represent the newly loaded (and optionally, verified, prepared, resolved, and initialized ) type.
    Here's the declaration of the <code>loadClass()</code> method:
    <span class="note">note：class loader</span>
</p>

<pre>begin
// A method declared in class java.lang.ClassLoader:
protected abstract Class loadClass(String name, boolean resolve) throws ClassNotFoundException;
end
</pre>

<p>
    The class loader takes care of loading, linking, and initializing types.
    Admittedly the name <code>ClassLoader</code> might lead you to believe it is responsible only for loading, and not linking or initialization,
    but the name <code>ClassLoaderLinkerAndInitializer</code> is a bit unwieldy.
    Also, the purpose of creating your own class loader is to customize the load phase while still using the primordial link and initialization mechanisms.
    Class loaders differ not in how they link or initialize types, but in how they load types.
    In other words, class loaders distinguish themselves by the manner in which they produce a binary form for a type given a fully qualified name.
    <span class="note">note：class loader = loading + linking + initializing. Class loaders differ not in how they link or initialize types, but in how they load types.</span>
</p>
<p>
    The <code>loadClass()</code> method encompasses all three steps of loading, linking, and initialization of a new type.
    You pass the fully qualified name of the requested type to <code>loadClass()</code> in the parameter <code>name</code>.
    If you want linking and initialization to be performed at this time, you pass <code>true</code> in the parameter <code>resolve</code>.
    If <code>loadClass()</code> is invoked with <code>resolve</code> set to <code>false</code>, it will load but not link and initialize the type.
    From your programs, you will likely invoke <code>loadClass()</code> with the <code>resolve</code> parameter always set to <code>true</code>.
    Normally, the <code>loadClass()</code> method is invoked with the <code>resolve</code> parameter set to <code>false</code> only by the virtual machine itself.
    (More on this later in this chapter.)
    <span class="note">note：loadClass(String name, boolean resolve)</span>
</p>
<p>
    As mentioned in earlier chapters, each class loader--primordial or object--is awarded its own name space, which is populated by the names of the types it has loaded.
    Dynamic extension and name spaces are both supported by one aspect of the process of resolution:
    the way a virtual machine chooses a class loader when it resolves a symbolic reference to a type.
</p>
<p>
    When the resolution of a constant pool entry requires loading a type, the virtual machine uses the same class loader that loaded the referencing type to load the referenced type.
    For example, imagine a <code>Cat</code> class refers via a symbolic reference in its constant pool to a type named <code>Mouse</code>.
    Assume <code>Cat</code> was loaded by a class loader object.
    When the virtual machine resolves the reference to <code>Mouse</code>, it checks to see if <code>Mouse</code> has been loaded into the name space to which <code>Cat</code> belongs.
    (It checks to see if the class loader that loaded <code>Cat</code> has previously loaded a type named <code>Mouse</code>.)
    If not, the virtual machine requests <code>Mouse</code> from the same class loader that loaded <code>Cat</code>.
    This is true even if a class named <code>Mouse</code> had previously been loaded into a different name space.
    When a symbolic reference from a type loaded by the primordial class loader is resolved, the Java Virtual Machine uses the primordial class loader to load the referenced type.
    When a symbolic reference from a type loaded by a class loader object is resolved, the Java Virtual Machine uses the same class loader object to load the referenced type.
    <span class="note">note：the virtual machine uses the same class loader that loaded the referencing type to load the referenced type</span>
</p>



<h2 id="constant_pool_resolution">Constant Pool Resolution</h2>
<p>
    This section describes the details of resolving each type of constant pool entry, including the errors that may be thrown during resolution.
    If an error is thrown during resolution, the error is seen as being thrown by the instruction that refers to the constant pool entry being resolved.
    Besides the errors described here, individual instructions that trigger the resolution of a constant pool entry may cause other errors to be thrown.
    For example, <code>getstatic</code> causes a <code>CONSTANT_Fieldref_info</code> entry to be resolved.
    If the entry is resolved successfully, the virtual machine performs one additional check: it makes sure the field is actually static (a class variable and not an instance variable).
    If the field is not static, the virtual machine throws an error.
    Any extra errors that may be thrown during resolution besides those described in this section are described for each individual instruction in Appendix A.
</p>



<h3 id="resolution_of_class_info">Resolution of CONSTANT_Class_info Entries</h3>
<p>
    Of all the types of constant pool entries, the most complicated to resolve is <code>CONSTANT_Class_info</code>.
    This type of entry is used to represent symbolic references to classes (including array classes) and interfaces.
    Several instructions, such as <code>new</code> and <code>anewarray</code>, refer directly to <code>CONSTANT_Class_info</code> entries.
    Other instructions, such as <code>putfield</code> or <code>invokevirtual</code>, refer indirectly to <code>CONSTANT_Class_info</code> entries through other types of entry.
    For example, the <code>putfield</code> instruction refers to a <code>CONSTANT_Fieldref_info</code> entry.
    The <code>class_index</code> item of a <code>CONSTANT_Fieldref_info</code> gives the constant pool index of a <code>CONSTANT_Class_info</code> entry.
    <span class="note">note：the most complicated to resolve is CONSTANT_Class_info</span>
</p>
<p>
    The details of resolving a <code>CONSTANT_Class_info</code> entry vary depending on
    whether or not the type is an array and whether the referencing type (the one that contains in its constant pool the <code>CONSTANT_Class_info</code> entry being resolved) was loaded via the primordial class loader or a class loader object.
    <span class="note">note：第一个考虑的问题，是不是array类型；第二个考虑的问题，是由primordial class loader，还是由a class loader object来执行加载工作。</span>
</p>



<h4 id="array_classes">Array Classes</h4>
<p>
    A <code>CONSTANT_Class_info</code> entry refers to an array class
    if its <code>name_index</code> refers to a <code>CONSTANT_Utf8_info</code> string that begins with a left bracket, as in " <code>[I</code>."
    As described in Chapter 6, "The Java Class File," internal array names contain one left bracket for each dimension, followed by an element type.
    If the element type begins with an " <code>L</code>," as in " <code>Ljava/lang/Integer;</code>," the array is an array of references.
    Otherwise, the element type is a primitive type, such as "<code>I</code>" for <code>int</code> or "<code>D</code>" for <code>double</code>, and the array is an array of primitive types.
    <span class="note">note：array class = array of references + array of primitive type</span>
</p>
<p>
    In the case of an array of references, the virtual machine resolves the element type.
    For example, if resolving an array class with the name " <code>[[Ljava/lang/Integer;</code>,"
    the virtual machine would make certain class <code>java.lang.Integer</code> is loaded, linked, and initialized.
    <span class="note">note：array of references</span>
</p>
<p>
    The end product of the resolution of a symbolic reference to an array class is a <code>Class</code> instance that represents the array class.
    If a <code>Class</code> instance has already been created for the array type being resolved, that same <code>Class</code> instance is used.
    Otherwise, the virtual machine creates a new <code>Class</code> instance to represent the newly resolved array type.
    <span class="note">note：the end product of the resolution of a symbolic reference to an array class</span>
</p>



<h4 id="non_array_classes_and_interfaces">Non-Array Classes and Interfaces</h4>
<p>
    A <code>CONSTANT_Class_info</code> entry
    whose <code>name_index</code> refers to a <code>CONSTANT_Utf8_info</code> string that doesn't begin with a left bracket
    is a symbolic reference to non-array class or an interface.
    Resolution of this kind of symbolic reference is a multiple step process.
    <span class="note">note：multiple step process</span>
</p>
<p>
    The Java Virtual Machine performs the same basic steps, described below as Steps 1 and 2a through 2e,
    to resolve any symbolic reference (any <code>CONSTANT_Class_info</code> entry) to a non-array class or interface.
    In Step 1, the type is loaded.
    In Steps 2a through 2e, the type is linked and initialized.
    The precise way in which the virtual machine performs these steps depends on whether the referencing type was loaded via the primordial class loader or a class loader object.
    <span class="note">note：primordial class loader or a class loader object</span>
</p>


<h5 id="step1">Step 1. Load the Type and any Superclasses</h5>
<p>
    Resolution of a non-array class or interface begins by making sure the type is loaded into the current name space.
    If the virtual machine determines that the referenced type hasn't yet been loaded into the current name space, it passes the fully qualified name of the type to a class loader.
    The class loader loads the type, parses the binary data into internal data structures, and creates a <code>Class</code> instance.
    <span class="note">note：class file --&gt; class loader --&gt; parse binary data --&gt; internal data structures --&gt; create a Class instance</span>
</p>
<p>
    Once the referenced type is loaded in, the virtual machine can peer into its binary data.
    If the type is a class and not <code>java.lang.Object</code>, the virtual machine determines from the class's data the fully qualified name of the class's direct superclass.
    The virtual machine then checks to see if the superclass has been loaded into the current name space.
    If not, it loads the superclass.
    Once that class comes in, the virtual machine can again peer into its binary data to find its superclass.
    This process repeats all the way up to <code>Object</code>.
    <span class="note">note：load the superclass --&gt; ...... --&gt; java.lang.Object</span>
</p>
<p>
    Through Step 1, the Java Virtual Machine makes sure a type is loaded, and if the type is a class, that all its superclasses are loaded.
    During this step, these types are not linked and initialized--just loaded.
    <span class="note">note：just loaded</span>
</p>
<p>
    If the referencing type (the one that contains in its constant pool the <code>CONSTANT_Class_info</code> entry being resolved) was loaded through the primordial class loader,
    the virtual machine uses the primordial class loader to load the referenced type (and its superclasses, if any).
    Otherwise, the referencing type was loaded through a class loader object, and the virtual machine uses the same class loader object to load the referenced type.
    <span class="note">note：the same class loader</span>
</p>
<p>
    The Java Virtual Machine maintains a list of the names of all the types already loaded by each class loader.
    Each of these lists forms a name space inside the Java Virtual Machine.
    The virtual machine uses this list during resolution to determine whether a class has already been loaded by a particular class loader.
    If during resolution, the Java Virtual Machine encounters a symbolic reference to a class that was not previously loaded by the appropriate class loader,
    that class loader will be asked to load the class.
    If the appropriate class loader is a class loader object, the Java Virtual Machine will make the load request by invoking the class loader object's <code>loadClass()</code> method.
    On the other hand, if the Java Virtual Machine encounters a symbolic reference to a class previously loaded by the same class loader object,
    the class loader object will not be asked to load it again.
    Instead, the class previously loaded will automatically be used again.
    This helps ensure that only one class with a given name is loaded by a particular class loader.
    <span class="note">note：class loader --&gt; name space --&gt; load only once</span>
</p>
<p>
    If the referencing type was loaded via the primordial class loader, the virtual machine will check the primordial class loader's name space to see if the class was already loaded.
    If not, the virtual machine will use the primordial class loader to load the referenced type in an implementation-dependent way.
    If the referenced type is a class, the virtual machine will make sure all the class's superclasses are loaded as well.
    If any of these classes haven't yet been loaded into the primordial loader's name space, the virtual machine will use the primordial class loader to load those classes.
    <span class="note">note：primordial class loader</span>
</p>
<p>
    If the referencing type was loaded via a class loader object,
    the virtual machine invokes <code>loadClass()</code> on the class loader object that loaded the referencing type,
    passing in parameter <code>name</code> the fully qualified name of the referenced type and setting the <code>resolve</code> flag to <code>true</code>.
    When <code>loadClass()</code> returns, it will have performed both Step 1 (loading) and Steps 2a through 2e (linking and initialization).
    (It will perform Steps 2a through 2e because the <code>resolve</code> flag is set to <code>true</code>.)
    Nonetheless, the <code>loadClass()</code> method will perform Step 1 completely before embarking on Steps 2a through 2e.
</p>
<p>
    When a class loader object's <code>loadClass()</code> method is invoked, it has two ways to do its job.
    One way is to use the primordial class loader by invoking <code>findSystemClass()</code>.
    In this case, the primordial loader will load, link, and initialize the requested type.
    Alternatively, <code>loadClass()</code> can produce the binary data in its own custom way,
    then call <code>defineClass()</code> and--if <code>true</code> was passed in <code>loadClass()</code>'s <code>resolve</code> parameter--call <code>resolveClass()</code>.
    In this case, the class loader object would produce the binary form for the requested type in its own custom way,
    then used the primordial class loader's standard mechanism to link and initialize the type.
    Here are the declarations for <code>findSystemClass()</code>, <code>defineClass()</code>, and <code>resolveClass()</code>:
    <span class="note">note：two way. One way is to use the primordial class loader</span>
</p>

<pre>begin
// Three methods declared in class java.lang.ClassLoader:
protected final Class findSystemClass(String name) throws ClassNotFoundException;
protected final Class defineClass(String name, byte data[], int offset, int length);
protected final void resolveClass(Class c);
end
</pre>

<p>
    If the <code>loadClass()</code> method invokes <code>findSystemClass()</code>,
    the class loader object is in effect asking the virtual machine to use the primordial loader to resolve the reference completely.
    The <code>findSystemClass()</code> method accepts the fully qualified name of the type to resolve in its <code>name</code> parameter.
    If the primordial class loader is able to successfully resolve the reference, it returns a reference to a <code>Class</code> instance that represents the referenced type.
    The <code>loadClass()</code> method would then just return a reference to the same <code>Class</code> instance.
    If the primordial class loader is unsuccessful, however, <code>findSystemClass()</code> will complete abruptly by throwing a <code>ClassNotFoundException</code>.
    In this case, the <code>loadClass()</code> method can either throw <code>ClassNotFoundException</code> itself or attempt to load the type in its custom way.
</p>
<p>
    Types brought in through the primordial class loader via <code>findSystemClass()</code> are marked as having no class loader object.
    Any types they refer to will be requested directly from the primordial class loader.
    <span class="note">note：primordial class loader</span>
</p>
<p>
    If the <code>loadClass()</code> method produces the stream of binary data for the type in its own custom way (such as if it downloads the type's class file across a network),
    it must invoke <code>defineClass()</code>, passing a reference to a <code>byte</code> array containing the type's binary data in the Java class file format.
    <span class="note">note：loadClass() --&gt; stream of binary data --&gt; defineClass()</span>
</p>
<p>
    Invoking <code>defineClass()</code> will cause the virtual machine to do two things.
    First, the virtual machine will parse the binary data into internal data structures and create a <code>Class</code> instance to represent the type.
    Second, if the type is a class and not <code>java.lang.Object</code>, the virtual machine will retrieve the name of the class's direct superclass.
    It will then check to see if the direct superclass has been previously loaded by this class loader object (the one whose <code>loadClass()</code> method just invoked <code>defineClass()</code> ).
    This is a check to see if the direct superclass already resides in the current name space.
    If the direct superclass has already been loaded by this class loader object, the <code>defineClass()</code> method returns the <code>Class</code> instance for the freshly loaded type.
    Otherwise, the virtual machine invokes <code>loadClass()</code> on the same class loader object,
    passing the fully qualified name of the direct superclass in the <code>name</code> parameter and setting the <code>resolve</code> flag to <code>false</code>.
    Because the <code>resolve</code> flag is <code>false</code>, the direct superclass (and recursively, all its superclasses) will be loaded, but not linked or initialized.
    <span class="note">note：defineClass() to two things. first, parse binary data and create a Class instance; second, load superclass.</span>
</p>
<p>
    The reason the <code>resolve</code> flag is set to <code>false</code> when <code>loadClass()</code> is invoked by <code>defineClass()</code> is because this is Step 1: loading of the type and any superclasses.
    Linking and initialization, which would occur if <code>resolve</code> were set to <code>true</code>, is saved for Step 2.
</p>
<p>
    When <code>defineClass()</code> has made certain the type and all its superclasses, if any, have been loaded into the current name space.
    It returns the new <code>Class</code> instance that represents the type. Step 1 is then complete.
</p>
<p>
    During Step 1, the virtual machine may throw the following errors:
</p>
<ul>
    <li>If the binary data can't be produced (for example, if a class file of the appropriate name can't be found), the virtual machine throws <code>NoClassDefFoundError</code>.</li>
    <li>If the binary data is produced, but isn't of the proper structure or a recognized version (such as if the minor or major version number of a Java class file is too high), the virtual machine throws <code>NoClassDefFoundError</code>.</li>
    <li>If the binary data is produced and well formed, but doesn't contain the sought after class or interface (such as if file <code>CuteKitty.class</code> is discovered to contain class <code>HungryTiger</code> instead of <code>CuteKitty</code>), the virtual machine throws <code>NoClassDefFoundError</code>.</li>
    <li>If the class doesn't contain a superclass and isn't class <code>Object</code> itself, the virtual machine throws a <code>ClassFormatError</code>. (Note that this check has to be done here, during the loading step, because that one piece of information--the symbolic reference to the superclass--is needed by the virtual machine during this step. During Step 1, the virtual machine must load in all the superclasses recursively.) </li>
    <li>If a class appears as its own superclass, the virtual machine throws <code>ClassCircularityError</code>.</li>
</ul>



<h5 id="step2">Step 2. Link and Initialize the Type and any Superclasses</h5>
<p>
    At this point, the type being referred to by the <code>CONSTANT_Class_info</code> entry being resolved has been loaded, but not linked or initialized.
    In addition, if the type being resolved is a class, all its superclasses have been loaded, but not necessarily linked or initialized.
    Some of the superclasses may be initialized at this point, because they may have been initialized during earlier resolutions.
    <span class="note">note: the type has been loaded, but not linked or initialized</span>
</p>
<p>
    As described in Chapter 7, "The Lifetime of a Class," superclasses must be initialized before subclasses.
    If the virtual machine is resolving a reference to a class (not an interface),
    it must make sure that the superclasses have been initialized, starting with <code>Object</code> and proceeding down the inheritance hierarchy to the referenced class.
    (Note that this is the opposite order in which they were loaded in Step 1.)
    If a type hasn't yet been linked, it must be linked before it is initialized.
    <span class="note">note: superclasses must be initialized before subclasses. If a type hasn't yet been linked, it must be linked before it is initialized.</span>
</p>



<h6 id="step2a">Step 2a. Verify the Type</h6>
<p>
    Step 2 begins with the official verification phase of linking, described in Chapter 7, "The Lifetime of a Class."
    As mentioned in Chapter 7, the process of verification may require that the virtual machine load new types.
    For example, when verifying a type, the Java Virtual Machine must check all a type's superclasses and superinterfaces to make sure they are all binary compatible with the type.
    If the type being verified has superinterfaces, they may not yet be loaded.
    During Step 1, the virtual machine makes sure all the type's superclasses are loaded, but not its superinterfaces.
    Thus, verification may require that a type's superinterfaces be loaded.
    At this point, the superinterfaces would be loaded and possibly linked, but definitely not initialized.
    <span class="note">note: verification may require that a type's superinterfaces be loaded</span>
</p>
<p>
    In addition, when verifying bytecodes, the Java Virtual Machine may need to load types to ensure the bytecodes are adhering to the semantics of the Java language.
    For example, if a reference to an instance of a particular class is assigned to a variable with a declared type of a different class, the virtual machine would have to load both types to make sure one is a subclass of the other.
    As with the superinterfaces described above, these classes would at this point be loaded and possibly linked, but definitely not initialized.
    <span class="note">note: verify bytecodes --&gt; ensure semantics</span>
</p>
<p>
    If during the verification process the Java Virtual Machine uncovers trouble, it throws <code>VerifyError</code>.
</p>



<h6 id="step2b">Step 2b. Prepare the Type</h6>
<p>
    After the official verification phase is complete, the type must be prepared.
    As described in Chapter 7, "The Lifetime of a Class,"
    during preparation the virtual machine allocates memory for class variables and implementation-dependent data structures such as method tables.
    If the virtual machine discovers during this step that a class that is not declared abstract contains an abstract method, the virtual machine throws <code>AbstractMethodError</code>.
    <span class="note">note: during preparation the virtual machine allocates memory for class variables and implementation-dependent data structures such as method tables</span>
</p>



<h6 id="step2c">Optional Step 2c. Resolve the Type</h6>
<p>
    At this point, the type has been loaded, verified and prepared.
    As described in Chapter 7, "The Lifetime of a Class," a Java Virtual Machine implementation may optionally resolve the type at this point.
    Keep in mind that at this stage in the resolution process,
    Steps 1, 2a, and 2b have been performed on a referenced type to resolve a <code>CONSTANT_Class_info</code> entry in the constant pool of a referencing type.
    Step 2c is the resolution of symbolic references contained in the referencing type, not the referenced type.
    <span class="note">note: Step 2c is the resolution of symbolic references contained in the referencing type, not the referenced type.</span>
</p>
<p>
    For example, if the virtual machine is resolving a symbolic reference from class <code>Cat</code> to class <code>Mouse</code>,
    the virtual machine performs Steps 1, 2a, and 2b on class <code>Mouse</code>.
    At this stage of resolving the symbolic reference to <code>Mouse</code> contained in the constant pool of <code>Cat</code>,
    the virtual machine could optionally (as Step 2c) resolve all the symbolic references contained in the constant pool for <code>Mouse</code>.
    If <code>Mouse</code>'s constant pool contains a symbolic reference to class <code>Cheese</code>,
    for example, the virtual machine could load and optionally link (but not initialize) <code>Cheese</code> at this time.
    The virtual machine mustn't attempt initialize <code>Cheese</code> here because <code>Cheese</code> is not being actively used.
    (Of course, <code>Cheese</code> may in fact have already been actively used elsewhere, so it could have been already be loaded into this name space, linked, and initialized.)
    <span class="note">note: for example</span>
</p>
<p>
    As mentioned earlier in this chapter, if an implementation does perform Step 2c at this point in the resolution process (early resolution),
    it must not report any errors until the symbolic references are actually used by the running program.
    For example, if during the resolution of <code>Mouse</code>'s constant pool,
    the virtual machine can't find class <code>Cheese</code>, it won't throw a <code>NoClassDefFound</code> error until (and unless) <code>Cheese</code> is actually used by the program.
    <span class="note">note: it must not report any errors until the symbolic references are actually used by the running program.</span>
</p>

<h6 id="step2d">Step 2d. Initialize the Type</h6>
<p>
    At this point, the type has been loaded, verified, prepared and optionally resolved.
    At long last, the type is ready for initialization.
    As defined in Chapter 7, "The Lifetime of a Class," initialization consists of two steps.
    The initialization of the type's superclasses in top down order, if the type has any superclasses, and the execution of the type's class initialization method, if it has one.
    Step 2d just consists of executing the class initialization method, if one exists.
    Because Steps 2a through 2e are performed for all the referenced type's superclasses, from the top down,
    Step 2d will occur for superclasses before it occurs for subclasses.
    <span class="note">note: Step 2d just consists of executing the class initialization method.</span>
</p>
<p>
    If the class initialization method completes abruptly by throwing some exception that isn't a subclass of <code>Error</code>,
    the virtual machine throws <code>ExceptionInInitializerError</code> with the thrown exception as a parameter to the constructor.
    Otherwise, if the thrown exception is already a subclass of <code>Error</code>, that error is thrown.
    If the virtual machine can't create a new <code>ExceptionInInitializerError</code> because there isn't enough memory,
    it throws an <code>OutOfMemoryError</code>.
    <span class="note">note: If the class initialization method completes abruptly</span>
</p>



<h6 id="step2e">Step 2e. Check Access Permission</h6>
<p>
    Lastly, after loading, linking, and initialization are complete, the virtual machine checks for access permission.
    If the referencing type does not have permission to access the referenced type, the virtual machine throws a <code>IllegalAccessError</code>.
    Step 2e is another activity that is logically part of verification, but that is performed at some other time than the official verification phase of Step 2a.
    In this case, the check for access permission is delayed to just after initialization.
    (Actually, the error can be detected at some other time, such as in Step 2a.
    But regardless of when or how it is detected,
    an access violation must be reported only after the Steps 1 and 2a through 2d have been successfully completed.
    As mentioned in Chapter 7, "The Lifetime of a Class,"
    the Java Virtual Machine specification says when errors should be thrown, but doesn't dictate exactly when they should be detected.)
    Once this check is complete, Step 2e--and the entire process of resolving the <code>CONSTANT_Class_info</code> entry--is complete.
    <span class="note">note: checks for access permission</span>
</p>
<p>
    If an error occurred in any of Steps 1 through 2e, the resolution of the type fails.
    But if all went well up until the access permission check of Step 2e, the type is still usable in general, just not usable by the referencing type.
    If an error occurred before the access permission check, however, the type is unusable and must be marked as such or discarded.
</p>


<hr/>


<p>
    The way a class loader object's <code>loadClass()</code> method accomplishes Steps 2a through 2e is by invoking <code>resolveClass()</code>,
    passing the reference to the <code>Class</code> instance returned by <code>defineClass()</code>.
    Invoking this method causes all of Steps 2a through 2e to be performed on the type and all its superclasses,
    starting from the furthest up superclass that hasn't yet been linked and initialized and proceeding down the inheritance hierarchy.
    <span class="note">note: loadClass() --&gt; defineClass() --&gt; resolveClass() --&gt; Steps 2a through 2e</span>
</p>
<p>
    Remember that when <code>defineClass()</code> was invoked,
    the virtual machine brought in the type's superclasses by calling <code>loadClass()</code> with the <code>resolve</code> flag set to <code>false</code>.
    So those superclasses were only loaded.
    They weren't linked or initialized.
    Only if the superclasses were already linked and initialized before <code>defineClass()</code> was invoked
    would they be already linked and initialized before <code>resolveClass()</code> is invoked.
</p>
<p>
    Note that the <code>loadClass()</code> method should only invoke <code>resolveClass()</code> on types it imported via calling <code>defineClass()</code>,
    which loads a type but doesn't link or initialize it.
    (In addition, <code>loadClass()</code> should invoke <code>resolveClass()</code> only if the resolve parameter is <code>true</code>.)
    As mentioned above, <code>findSystemClass()</code> takes care of linking and initialization as well as loading.
    You needn't invoke <code>resolveClass()</code> on types returned by <code>findSystemClass()</code>.
</p>



<h3 id="resolution_of_field_ref_info">Resolution of CONSTANT_Fieldref_info Entries</h3>
<p>
    To resolve a constant pool entry of type <code>CONSTANT_Fieldref_info</code>,
    the virtual machine must first resolve the <code>CONSTANT_Class_info</code> entry specified in the <code>class_index</code> item.
    Therefore, any error that can be thrown because of the resolution of a <code>CONSTANT_Class_info</code> can be thrown during the resolution of a <code>CONSTANT_Fieldref_info</code>.
    If resolution of the <code>CONSTANT_Class_info</code> entry succeeds, the virtual machine checks to make sure the field exists and that the current class has permission to access it.
    <span class="note">note: CONSTANT_Class_info --&gt; CONSTANT_Fieldref_info</span>
</p>
<p>
    If the virtual machine discovers there is no field with the proper name and type in the referenced class, the virtual machine throws <code>NoSuchFieldError</code>.
    Otherwise, if the field exists, but the current class doesn't have permission to access the field, the virtual machine throws <code>IllegalAccessError</code>.
</p>
<p>The virtual machine marks the entry as resolved and places a direct reference to the field in the data for the constant pool entry.</p>



<h3 id="resolution_of_method_ref_info">Resolution of CONSTANT_Methodref_info Entries</h3>
<p>
    To resolve a constant pool entry of type <code>CONSTANT_Methodref_info</code>,
    the virtual machine must first resolve the <code>CONSTANT_Class_info</code> entry specified in the <code>class_index</code> item.
    Therefore, any error that can be thrown because of the resolution of a <code>CONSTANT_Class_info</code> can be thrown during the resolution of a <code>CONSTANT_Methodref_info</code>.
    If the resolution of the <code>CONSTANT_Class_info</code> entry succeeds, the virtual machine checks to make sure the method exists and that the current class has permission to access it.
    <span class="note">note: CONSTANT_Class_info --&gt; CONSTANT_Methodref_info</span>
</p>
<p>
    If the virtual machine discovers there is no method with the proper name, return type, and number and types of parameters in the referenced class,
    the virtual machine throws <code>NoSuchMethodError</code>.
    Otherwise, if the method exists, but the current class doesn't have permission to access the method, the virtual machine throws <code>IllegalAccessError</code>.
</p>
<p>The virtual machine marks the entry as resolved and places a direct reference to the method in the data for the constant pool entry.</p>



<h3 id="resolution_of_interface_method_ref_info">Resolution of CONSTANT_InterfaceMethodref_info Entries</h3>
<p>
    To resolve a constant pool entry of type <code>CONSTANT_InterfaceMethodref_info</code>,
    the virtual machine must first resolve the <code>CONSTANT_Class_info</code> entry specified in the <code>class_index</code> item.
    Therefore, any error that can be thrown because of the resolution of a <code>CONSTANT_Class_info</code> can be thrown during the resolution of a <code>CONSTANT_InterfaceMethodref_info</code>.
    If the resolution of the <code>CONSTANT_Class_info</code> entry succeeds, the virtual machine checks to make sure the method exists.
    (The virtual machine need not check to make sure the current class has permission to access the method, because all methods declared in interfaces are implicitly public.)
    <span class="note">note: CONSTANT_Class_info --&gt; CONSTANT_InterfaceMethodref_info</span>
</p>
<p>
    If the virtual machine discovers there is no method with the proper name, return type, and number and types of parameters in the referenced interface,
    the virtual machine throws <code>NoSuchMethodError</code>.
</p>
<p>The virtual machine marks the entry as resolved and places a direct reference to the method in the data for the constant pool entry.</p>



<h3 id="resolution_of_string_info">Resolution of CONSTANT_String_info Entries</h3>
<p>
    To resolve an entry of type <code>CONSTANT_String_info</code>,
    the virtual machine must place a reference to an <i>interned</i> <code>String</code> object in the data for the constant pool entry being resolved.
    The <code>String</code> object (an instance of class <code>java.lang.String</code>) must have the character sequence specified by
    the <code>CONSTANT_Utf8_info</code> entry identified by the <code>string_index</code> item of the <code>CONSTANT_String_info</code>.
</p>
<p>
    Each Java Virtual Machine must maintain an internal list of references to <code>String</code> objects that have been "interned" during the course of running the application.
    Basically, a <code>String</code> object is said to be interned simply if it appears in the virtual machine's internal list of interned <code>String</code> objects.
    The point of maintaining this list is that any particular sequence of characters is guaranteed to appear in the list no more than once.
</p>
<p>
    To intern a sequence of characters represented by a <code>CONSTANT_String_info</code> entry,
    the virtual machine checks to see if the sequence of characters is already in the list of interned strings.
    If so, the virtual machine uses the reference to the existing, previously-interned <code>String</code> object.
    Otherwise, the virtual machine creates a new <code>String</code> object with the proper character sequence and adds a reference to that <code>String</code> object to the list.
    To complete the resolution process for a <code>CONSTANT_String_info</code> entry,
    the virtual machine places the reference to the interned <code>String</code> object in the data of the constant pool entry being resolved.
</p>
<p>
    In your Java programs, you can intern a string by invoking the <code>intern()</code> method of class <code>String</code>.
    All literal strings are interned via the process of resolving <code>CONSTANT_String_info</code> entries.
    If a string with the same sequence of Unicode characters has been previously interned,
    the <code>intern()</code> method returns a reference to the matching already-interned <code>String</code> object.
    If the <code>intern()</code> method is invoked on a <code>String</code> object that contains a sequence of characters that has not yet been interned,
    that object itself will be interned.
    The <code>intern()</code> method will return a reference to the same <code>String</code> object upon which it was invoked.
</p>
<p>Here's an example:</p>

<pre>begin
// On CD-ROM in file linking/ex1/Example1.java
class Example1 {

    // Assume this application is invoked with one command-line
    // argument, the string "Hi!".
    public static void main(String[] args) {

        // argZero, because it is assigned a String from the command
        // line, does not reference a string literal. This string
        // is not interned.
        String argZero = args[0];

        // literalString, however, does reference a string literal.
        // It will be assigned a reference to a String with the value
        // "Hi!" by an instruction that references a
        // CONSTANT_String_info entry in the constant pool. The
        // "Hi!" string will be interned by this process.
        String literalString = "Hi!";

        // At this point, there are two String objects on the heap
        // that have the value "Hi!". The one from arg[0], which
        // isn't interned, and the one from the literal, which
        // is interned.
        System.out.print("Before interning argZero: ");
        if (argZero == literalString) {
            System.out.println("they're the same string object!");
        }
        else {
            System.out.println("they're different string objects.");
        }

        // argZero.intern() returns the reference to the literal
        // string "Hi!" that is already interned. Now both argZero
        // and literalString have the same value. The non-interned
        // version of "Hi!" is now available for garbage collection.
        argZero = argZero.intern();
        System.out.print("After interning argZero: ");
        if (argZero == literalString) {
            System.out.println("they're the same string object!");
        }
        else {
            System.out.println("they're different string objects.");
        }
    }
}

end
</pre>

<p>When executed with the string <code>"Hi!"</code> as the first command-line argument, the <code>Example1</code> application prints the following:</p>

<pre>begin
Before interning argZero: they're different string objects.
After interning argZero: they're the same string object!
end
</pre>

<h3 id="resolution_of_other_types">Resolution of Other Types of Entries</h3>
<p>
    <code>The CONSTANT_Integer_info</code>, <code>CONSTANT_Long_info</code>, <code>CONSTANT_Float_info</code>, <code>CONSTANT_Double_info</code> entries
    contain the constant values they represent within the entry itself.
    These are straightforward to resolve.
    To resolve this kind of entry, many virtual machine implementations may not have to do anything but use the value as is.
    Other implementations, however, may choose to do some processing on it.
    For example, a virtual machine on a little-endian machine could choose to swap the byte order of the value at resolve time.
</p>
<p>
    Entries of type <code>CONSTANT_Utf8_info</code> and <code>CONSTANT_NameAndType_info</code> are never referred to directly by instructions.
    They are only referred to via other types of entries, and resolved when those referring entries are resolved.
</p>



<h2 id="compile_time_resolution_of_constant">Compile-Time Resolution of Constants</h2>
<p>
    As mentioned in Chapter 7, "The Lifetime of a Class,"
    references to static final variables initialized to a compile-time constant are resolved at compile-time to a local copy of the constant value.
    This is true for constants of all the primitive types and of type <code>java.lang.String</code>.
</p>
<p>
    This special treatment of constants facilitates two features of the Java language.
    First, local copies of constant values enable static final variables to be used as <code>case</code> expressions in <code>switch</code> statements.
    The two virtual machine instructions that implement <code>switch</code> statements in bytecodes, <code>tableswitch</code> and <code>lookupswitch</code>,
    require the <code>case</code> values in-line in the bytecode stream.
    These instructions do not support run-time resolution of <code>case</code> values.
    See Chapter 16, "Control Flow," for more information about these instructions.
</p>
<p>
    The other motivation behind the special treatment of constants is conditional compilation.
    Java supports conditional compilation via <code>if</code> statements whose expressions resolve to a compile-time constant. Here's an example:
</p>


<pre>begin
// On CD-ROM in file linking/ex2/AntHill.java
class AntHill {
    static final boolean debug = true;
}

// On CD-ROM in file linking/ex2/Example2.java
class Example2 {
    public static void main(String[] args) {
        if (AntHill.debug) {
            System.out.println("Debug is true!");
        }
    }
}
end
</pre>


<p>
    Because of the special treatment of primitive constants,
    the Java compiler can decide whether or not to include the body of the <code>if</code> statement in <code>Example2.main()</code> depending upon the value of <code>AntHill.debug</code>.
    Because <code>AntHill.debug</code> is <code>true</code> in this case,
    <code>javac</code> generates bytecodes for <code>Example2</code>'s <code>main()</code> method that include the body of the <code>if</code> statement,
    but not a check of <code>AntHill.debug</code>'s value.
    The constant pool of <code>Example2</code> has no symbolic reference to class <code>AntHill</code>.
    Here are the bytecodes for <code>main()</code> :
</p>

<pre>begin
               // Push objref from System.out
0 getstatic #8 &lt;Field java.io.PrintStream out
               // Push objref to literal string "Debug is true!"
3 ldc #1 &lt;String "Debug is true!"
               // Pop objref (to a String), pop objref(to
               // System.out), invoke println() on System.out
               // passing the string as the only parameter:
               // System.out.println("Debug is true!");
5 invokevirtual #9 &lt;Method void println(java.lang.String)
8 return       // return void
end
</pre>

<p>
    If the reference to <code>AntHill.debug</code> were resolved at run-time,
    the compiler would always need to include a check of <code>AntHill.debug</code>'s value and the body of the <code>if</code> statement just in case value of <code>AntHill.debug</code> ever changed.
    The value of <code>AntHill.debug</code> can't change after it is compiled, of course, because it is declared as final.
    Still, you could change the source code of <code>AntHill</code> and recompile <code>AntHill</code>, but not recompile <code>Example2</code>.
</p>

<p>
    Because the reference to <code>AntHill.debug</code> is resolved at compile-time,
    the compiler can conditionally compile out the body of the <code>if</code> statement if <code>AntHill.debug</code> is discovered to be <code>false</code>.
    Note that this means you can't change the behavior of the <code>Example2</code> application just be setting <code>AntHill</code> to <code>false</code> and recompiling only <code>AntHill</code>.
    You have to recompile <code>Example2</code> as well.
</p>

<p>
    <code>Example3</code>, shown below, is <code>Example2</code> with its name changed to <code>Example3</code>
    and compiled with an <code>AntHill</code> that has <code>debug</code> set to <code>false</code>:
</p>


<pre>begin
// On CD-ROM in file linking/ex3/AntHill.java
class AntHill {
    static final boolean debug = false;
}

// On CD-ROM in file linking/ex3/Example3.java
class Example3 {
    public static void main(String[] args) {
        if (AntHill.debug) {
            System.out.println("Debug is true!");
        }
    }
}
end
</pre>

<p>Here are the bytecodes generated by <code>javac</code> for <code>Example3</code>'s <code>main()</code> method:</p>

<pre>begin
0 return     // return void
end
</pre>


<p>
    As you can see, the Java compiler has brazenly eliminated the entire <code>if</code> statement found in <code>Example3.main()</code>.
    There is not even a hint of the <code>println()</code> invocation in this very short bytecode sequence.
</p>



<h2 id="direct_references">Direct References</h2>
<p>
    The ultimate goal of constant pool resolution is to replace a symbolic reference with a direct reference.
    The form of symbolic references is well-defined in Chapter 6, "The Java Class File," but what form do direct references take?
    As you might expect, the form of direct references is yet another decision of the designers of individual Java Virtual Machine implementations.
    Nevertheless, there are some characteristics likely to be common among most implementations.
</p>
<p>
    Direct references to types, class variables, and class methods are likely native pointers into the method area.
    A direct reference to a type can simply point to the implementation-specific data structure in the method area that holds the type data.
    A direct reference to a class variable can point to the class variable's value stored in the method area.
    A direct reference to a class method can point to a data structure in the method area that contains the data needed to invoke the method.
    For example, the data structure for a class method could include information such as whether or not the method is native.
    If the method is native, the data structure could include a function pointer to the dynamically linked native method implementation.
    If the method is not native, the data structure could include the method's bytecodes, max_stack, max_locals, and so on.
    If there is a just-in-time-compiled version of the method, the data structure could include a pointer to that just-in-time-compiled native code.
</p>
<p>
    Direct references to instance variables and instance methods are offsets.
    A direct reference to an instance variable is likely the offset from the start of the object's image to the location of the instance variable.
    A direct reference to an instance method is likely an offset into a method table.
</p>
<p>
    Using offset to represent direct references to instance variables and instance methods depends on a predictable ordering of the fields in a class's object image and the methods in a class's method table.
    Although implementation designers may choose any way of placing instance variables into an object image or methods into a method table,
    they will almost certainly use the same way for all types.
    Therefore, in any one implementation, the ordering of fields in an object and methods in a method table is defined and predictable.
</p>
<p>As an example, consider this hierarchy of three classes and one interface:</p>
<pre>begin
// On CD-ROM in file linking/ex4/Friendly.java
interface Friendly {
    void sayHello();
    void sayGoodbye();
}

// On CD-ROM in file linking/ex4/Dog.java
class Dog {
    // How many times this dog wags its tail when
    // saying hello.
    private int wagCount = ((int) (Math.random() * 5.0)) + 1;

    void sayHello() {
        System.out.print("Wag");
        for (int i = 0; i &lt; wagCount; ++i) {
            System.out.print(", wag");
        }
        System.out.println(".");
    }

    public String toString() {
        return "Woof!";
    }
}
</code>

// On CD-ROM in file linking/ex4/CockerSpaniel.java
class CockerSpaniel extends Dog implements Friendly {
    // How many times this Cocker Spaniel woofs when saying hello.
    private int woofCount = ((int) (Math.random() * 4.0)) + 1;

    // How many times this Cocker Spaniel wimpers when saying
    // goodbye.
    private int wimperCount = ((int) (Math.random() * 3.0)) + 1;

    public void sayHello() {
        // Wag that tail a few times.
        super.sayHello();

        System.out.print("Woof");
        for (int i = 0; i &lt; woofCount; ++i) {
            System.out.print(", woof");
        }
    }

    public void sayGoodbye() {
        System.out.print("Wimper");
        for (int i = 0; i &lt; wimperCount; ++i) {
            System.out.print(", wimper");
        }
        System.out.println(".");
    }
}

// On CD-ROM in file linking/ex4/Cat.java
class Cat implements Friendly {
    public void eat() {
        System.out.println("Chomp, chomp, chomp.");
    }

    public void sayHello() {
        System.out.println("Rub, rub, rub.");
    }

    public void sayGoodbye() {
        System.out.println("Scamper.");
    }

    protected void finalize() {
        System.out.println("Meow!");
    }
}
end
</pre>

<p>
    Assume these types are loaded into a Java Virtual Machine that organizes objects by placing the instance variables declared in superclasses into the object image before those declared in subclasses,
    and by placing the instance variables for each individual class in their order of appearance in the class file.
    Assuming there are no instance variables in class <code>Object</code>, the object images for <code>Dog</code>, <code>CockerSpaniel</code>, and <code>Cat</code> would appear as shown in Figure 8-1.
</p>
<p><img src="images/fig8-1.gif" alt= "figure 8-1"></p>
<p>
    In this figure, the object image for <code>CockerSpaniel</code> best illustrates this particular virtual machine's approach to laying out objects.
    The instance variable for <code>Dog</code>, the superclass, appears before the instance variables for <code>CockerSpaniel</code>, the subclass.
    The instance variables of <code>CockerSpaniel</code> appear in order of declaration: <code>woofCount</code> first, then <code>wimperCount</code>.
</p>
<p>
    Note that the <code>wagCount</code> instance variable appears at offset 1 in both <code>Dog</code> and <code>CockerSpaniel</code>.
    In this implementation of the Java Virtual Machine, a symbolic reference to the <code>wagCount</code> field of class <code>Dog</code> would be resolved to direct reference that is an offset of 1.
    Regardless of whether the actual object being referred to was a <code>Dog</code>, a <code>CockerSpaniel</code>, or any other subclass of <code>Dog</code>,
    the <code>wagCount</code> instance variable would always appear at offset 1 in the object image.
</p>
<p>
    A similar pattern emerges in method tables.
    A method table entry is associated in some way with data structures in the method area that contain sufficient data to enable the virtual machine to invoke the method.
    Assume that in the Java Virtual Machine implementation being described here, method tables are arrays of native pointers into the method area.
    The data structures that the method table entries point to are similar to the data structures described above for class methods.
    Assume that the particular Java Virtual Machine implementation that loads these types organizes its method tables by placing methods for superclasses into the method table before those for subclasses,
    and by placing pointers for each class in the order the methods appear in the class file.
    The exception to the ordering is that methods overridden by a subclass appear in the slot where the overridden method first appears in a superclass.
</p>
<p>
    The way this virtual machine would organize the method table for class <code>Dog</code> is shown in Figure 8-2.
    In this figure, the method table entries that point to methods defined in class <code>Object</code> are shown in dark gray.
    Entries that point to methods defined in <code>Dog</code> are shown in light gray.
</p>
<p><img src="images/fig8-2.gif" alt= "figure 8-2"></p>
<p>
    Note that only non-private instance methods appear in this method table.
    Class methods, which are invoked via the <code>invokestatic</code> instruction, need not appear here, because they are statically bound and don't need the extra indirection of a method table.
    Private methods and instance initialization methods need not appear here because they are invoked via the <code>invokespecial</code> instruction and are therefore statically bound.
    Only methods that are invoked with <code>invokevirtual</code> or <code>invokeinterface</code> appear in this method table.
    See Chapter 19, "Method Invocation and Return," for a discussion of the different invocation instructions.
</p>
<p>
    By looking at the source code, you can see that <code>Dog</code> overrides the <code>toString()</code> method defined in class <code>Object</code>.
    In <code>Dog</code>'s method table, the <code>toString()</code> method appears only once, in the same slot (offset 7) in which it appears in the method table for <code>Object</code>.
    The pointer residing at offset 7 in <code>Dog</code>'s method table points to the data for <code>Dog</code>'s implementation of <code>toString()</code>.
    In this implementation of the Java Virtual Machine, the pointer to the method data for <code>toString()</code> will appear at offset 7 for every method table of every class.
</p>
<p>
    Below the methods declared in <code>Object</code>, which appear first in this method table, come the methods declared in <code>Dog</code> that don't override any method in <code>Object</code>.
    There is only one such method, <code>sayHello()</code>, which has the method table offset 11.
    All of <code>Dog</code>'s subclasses will either inherit or override this implementation of <code>sayHello()</code>,
    and some version of <code>sayHello()</code> will always appear at offset 11 of any subclass of <code>Dog</code>.
</p>
<p>
    Figure 8-3 shows the method table for <code>CockerSpaniel</code>.
    Note that because <code>CockerSpaniel</code> declares <code>sayHello()</code> and <code>sayGoodbye()</code>,
    the pointers for those methods point to the data for <code>CockerSpaniel</code>'s implementation of those methods.
    Because <code>CockerSpaniel</code> inherits <code>Dog</code>'s implementation of <code>toString()</code>,
    the pointer for that method (which is still at offset 7) points the data for <code>Dog</code>'s implementation of that method.
    <code>CockerSpaniel</code> inherits all other methods from <code>Object</code>, so the pointers for those methods point directly into <code>Object</code>'s type data.
    Note also that <code>sayHello()</code> is sitting at offset 11, the same offset it has in <code>Dog</code>'s method table.
</p>
<p><img src="images/fig8-3.gif" alt= "figure 8-3"></p>
<p>
    When the virtual machine resolves a symbolic reference (a <code>CONSTANT_Methodref_info</code> entry) to the <code>toString()</code> method of any class, the direct reference is method table offset 7.
    When the virtual machine resolves a symbolic reference to the <code>sayHello()</code> method of <code>Dog</code> or any of its subclasses, the direct reference is method table offset 11.
    When the virtual machine resolves a symbolic reference to the <code>sayGoodbye()</code> method of <code>CockerSpaniel</code> or any of its subclasses, the direct reference is the method table offset 12.
</p>
<p>
    Once a symbolic reference to an instance method is resolved to a method table offset, the virtual machine must still actually invoke the method.
    To invoke an instance method, the virtual machine goes through the object to get at the method table for the object's class.
    As mentioned in Chapter 5, "The Java Virtual Machine," given a reference to an object, every virtual machine implementation must have some way to get at the type data for that object's class.
    In addition, given a reference to an object, the method table (a part of the type data for the object's class) is usually very quickly accessible.
    (One potential scheme is shown in Figure 5-7.)
    Once the virtual machine has the method table for the object's class, it uses the offset to find the actual method to invoke. Voila!
</p>
<p>
    The virtual machine can always depend on method table offsets when it has a reference of a class type (a <code>CONSTANT_Methodref_info</code> entry).
    If the <code>sayHello()</code> method appears in offset 11 in class <code>Dog</code>, it will appear in offset 11 in any subclass of <code>Dog</code>.
    The same is not true, however, if the reference is of an interface type (a <code>CONSTANT_InterfaceMethodref_info</code> entry).
    With direct references to instance methods accessed through an interface reference there is no guaranteed method table offset.
    Consider the method table for class <code>Cat</code>, shown in Figure 8-4.
</p>
<p><img src="images/fig8-4.gif" alt= "figure 8-4"></p>
<p>
    Note that both <code>Cat</code> and <code>CockerSpaniel</code> implement the <code>Friendly</code> interface.
    A variable of type <code>Friendly</code> could hold a reference to a <code>Cat</code> object or a <code>CockerSpaniel</code> object.
    With that reference, your program could invoke <code>sayHello()</code> or <code>sayGoodbye()</code> on a <code>Cat</code>, a <code>CockerSpaniel</code>,
    or any other object whose class implements the <code>Friendly</code> interface.
    The <code>Example4</code> application demonstrates this:
</p>

<pre>begin
// On CD-ROM in file linking/ex4/Example4.java
class Example4 {
    public static void main(String[] args) {
        Dog dog = new CockerSpaniel();
        dog.sayHello();

        Friendly fr = (Friendly) dog;

        // Invoke sayGoodbye() on a CockerSpaniel object through a
        // reference of type Friendly.
        fr.sayGoodbye();

        fr = new Cat();
        // Invoke sayGoodbye() on a Cat object through a reference
        // of type Friendly.
        fr.sayGoodbye();
    }
}
end
</pre>

<p>
    In <code>Example4</code>, local variable <code>fr</code> invokes <code>sayGoodbye()</code> on both a <code>CockerSpaniel</code> object and a <code>Cat</code> object.
    The same constant pool entry, a <code>CONSTANT_InterfaceMethodref_info</code> entry, is used to invoke this method on both objects.
    But when the virtual machine resolves the symbolic reference to <code>sayHello()</code>,
    it can't just save a method table offset and expect that offset to always work in future uses of the constant pool entry.
</p>
<p>
    The trouble is that classes that implement the <code>Friendly</code> interface aren't guaranteed to have a common superclass that also implements <code>Friendly</code>.
    As a result, the methods declared in <code>Friendly</code> aren't guaranteed to be in the same place in all method tables.
    If you compare the method table for <code>CockerSpaniel</code> against the method table for <code>Cat</code>,
    for example, you'll see that in <code>CockerSpaniel</code>, <code>sayHello()</code>'s pointer occupies offset 11.
    But in <code>Cat</code>, <code>sayHello()</code> occupies offset 12.
    Likewise, <code>CockerSpaniel</code>'s <code>sayGoodbye()</code> method pointer resides in offset 12, but <code>Cat</code>'s <code>sayGoodbye()</code> method pointer resides at offset 13.
</p>
<p>
    Thus, whenever the Java Virtual Machine invokes a method from an interface reference, it must search the method table of the object's class until it finds the appropriate method.
    This is why invoking instance methods on interface references can be significantly slower than invoking instance methods on class references.
    Virtual machine implementations can attempt to be smart, of course, about how they search through a method table.
    For example, an implementation could save the last index at which they found the method and try there first the next time.
    Or an implementation could build data structures during preparation that help them search through method tables given an interface reference.
    Nevertheless, invoking a method given an interface reference will almost certainly be to some extent slower than invoking a method given a class reference.
</p>



<h2 id="quick_instructions">_quick Instructions</h2>
<p>
    The Java Virtual Machine specification describes a technique used by Sun's Java Virtual Machine implementation to speed up the interpretation of bytecodes.
    This technique is likely common to many Java Virtual Machine implementations, because many implementations are based on Sun's code.
    In this scheme, opcodes that refer to constant pool entries are replaced by a "<code>_quick</code>" opcode when the constant pool entry is resolved.
    When the virtual machine encounters a <code>_quick</code> instruction, it knows the constant pool entry is already resolved and can therefore execute the instruction faster.
</p>
<p>
    The core instruction set of the Java Virtual Machine consists of 200 single-byte opcodes, all of which are described in Appendix A, "Instruction Set by Opcode Mnemonic."
    These 200 opcodes are the only opcodes you will ever see in class files.
    Sun's virtual machine implementation uses another 25 single-byte opcodes internally, the "<code>_quick</code>" opcodes.
</p>
<p>
    For example, when Sun's virtual machine resolves a constant pool entry referred to by an <code>ldc</code> instruction (opcode value 0x12),
    it replaces the <code>ldc</code> opcode byte in the bytecode stream with an <code>ldc_quick</code> instruction (opcode value 0xcb).
    This technique is part of the process of replacing a symbolic reference with a direct reference in Sun's virtual machine.
</p>
<p>
    For some instructions, in addition to overwriting the normal opcode with a <code>_quick</code> opcode,
    the virtual machine overwrites the operands of the instruction with data that represents the direct reference.
    For example, in addition to replacing an <code>invokevirtual</code> opcode with an <code>invokevirtual_quick</code>,
    the virtual machine also puts the method table offset and the number of arguments into the two operand bytes that follow every <code>invokevirtual</code> instruction.
    Placing the method table offset in the bytecode stream following the <code>invokevirtual_quick</code> opcode
    saves the virtual machine the time it would take to look up the offset in the resolved constant pool entry.
</p>



<h2 id="salutation_application">Example: The Linking of the Salutation Application</h2>
<p>As an example of Java's linking model, consider the <code>Salutation</code> application shown below:</p>

<pre>begin
// On CD-ROM in file linking/ex5/Salutation.java
class Salutation {
    private static final String hello = "Hello, world!";
    private static final String greeting = "Greetings, planet!";
    private static final String salutation = "Salutations, orb!";

    private static int choice = (int) (Math.random() * 2.99);

    public static void main(String[] args) {
        String s = hello;
        if (choice == 1) {
            s = greeting;
        }
        else if (choice == 2) {
            s = salutation;
        }
        System.out.println(s);
    }
}
end
</pre>

<p>
    Assume that you have asked a Java Virtual Machine to run <code>Salutation</code>.
    When the virtual machine starts, it attempts to invoke the <code>main()</code> method of <code>Salutation</code>.
    It quickly realizes, however, that it can't invoke <code>main()</code>.
    The invocation of a method declared in a class is an active use of that class, which is not allowed until the class is initialized.
    Thus, before the virtual machine can invoke <code>main()</code>, it must initialize <code>Salutation</code>.
    And before it can initialize <code>Salutation</code>, it must load and link <code>Salutation</code>.
    So, the virtual machine hands the fully qualified name of <code>Salutation</code> to the primordial class loader,
    which retrieves the binary form of the class, parses the binary data into internal data structures, and creates an instance of <code>java.lang.Class</code>.
    The constant pool for <code>Salutation</code> is shown in Table 8-1.
</p>
<p>Table 8-1. Class <code>Salutation</code>'s constant pool</p>
<table border="1" style="width:100%;">
    <tbody>
    <tr>
        <td><strong> Index </strong></td>
        <td><strong> Type </strong></td>
        <td><strong> Value </strong></td>
    </tr>
    <tr>
        <td>1</td>
        <td><code>CONSTANT_String_info</code></td>
        <td>30</td>
    </tr>
    <tr>
        <td>2</td>
        <td><code>CONSTANT_String_info</code></td>
        <td>31</td>
    </tr>
    <tr>
        <td>3</td>
        <td><code>CONSTANT_String_info</code></td>
        <td>39</td>
    </tr>
    <tr>
        <td>4</td>
        <td><code>CONSTANT_Class_info</code></td>
        <td>37</td>
    </tr>
    <tr>
        <td>5</td>
        <td><code>CONSTANT_Class_info</code></td>
        <td>44</td>
    </tr>
    <tr>
        <td>6</td>
        <td><code>CONSTANT_Class_info</code></td>
        <td>45</td>
    </tr>
    <tr>
        <td>7</td>
        <td><code>CONSTANT_Class_info</code></td>
        <td>46</td>
    </tr>
    <tr>
        <td>8</td>
        <td><code>CONSTANT_Class_info</code></td>
        <td>47</td>
    </tr>
    <tr>
        <td>9</td>
        <td><code>CONSTANT_Methodref_info</code></td>
        <td>7, 16</td>
    </tr>
    <tr>
        <td>10</td>
        <td><code>CONSTANT_Fieldref_info</code></td>
        <td>4, 17</td>
    </tr>
    <tr>
        <td>11</td>
        <td><code>CONSTANT_Fieldref_info</code></td>
        <td>8, 18</td>
    </tr>
    <tr>
        <td>12</td>
        <td><code>CONSTANT_Methodref_info</code></td>
        <td>5, 19</td>
    </tr>
    <tr>
        <td>13</td>
        <td><code>CONSTANT_Methodref_info</code></td>
        <td>6, 20</td>
    </tr>
    <tr>
        <td>14</td>
        <td><code>CONSTANT_Double_info</code></td>
        <td>2.99</td>
    </tr>
    <tr>
        <td>16</td>
        <td><code>CONSTANT_NameAndType_info</code></td>
        <td>26, 22</td>
    </tr>
    <tr>
        <td>17</td>
        <td><code>CONSTANT_NameAndType_info</code></td>
        <td>41, 32</td>
    </tr>
    <tr>
        <td>18</td>
        <td><code>CONSTANT_NameAndType_info</code></td>
        <td>49, 34</td>
    </tr>
    <tr>
        <td>19</td>
        <td><code>CONSTANT_NameAndType_info</code></td>
        <td>50, 23</td>
    </tr>
    <tr>
        <td>20</td>
        <td><code>CONSTANT_NameAndType_info</code></td>
        <td>51, 21</td>
    </tr>
    <tr>
        <td>21</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"()D"</code></td>
    </tr>
    <tr>
        <td>22</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"()V"</code></td>
    </tr>
    <tr>
        <td>23</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"(Ljava/lang/String;)V"</code></td>
    </tr>
    <tr>
        <td>24</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"([Ljava/lang/String;)V"</code></td>
    </tr>
    <tr>
        <td>25</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"&lt;clinit&gt;</code> "</td>
    </tr>
    <tr>
        <td>26</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"&lt;init&gt;</code> "</td>
    </tr>
    <tr>
        <td>27</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Code"</code></td>
    </tr>
    <tr>
        <td>28</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"ConstantValue"</code></td>
    </tr>
    <tr>
        <td>29</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Exceptions"</code></td>
    </tr>
    <tr>
        <td>30</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Greetings, planet!"</code></td>
    </tr>
    <tr>
        <td>31</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Hello, world!"</code></td>
    </tr>
    <tr>
        <td>32</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"I"</code></td>
    </tr>
    <tr>
        <td>33</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"LineNumberTable"</code></td>
    </tr>
    <tr>
        <td>34</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Ljava/io/PrintStream;"</code></td>
    </tr>
    <tr>
        <td>35</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Ljava/lang/String;"</code></td>
    </tr>
    <tr>
        <td>36</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"LocalVariables"</code></td>
    </tr>
    <tr>
        <td>37</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Salutation"</code></td>
    </tr>
    <tr>
        <td>38</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Salutation.java"</code></td>
    </tr>
    <tr>
        <td>39</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"Salutations, orb!"</code></td>
    </tr>
    <tr>
        <td>40</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"SourceFile"</code></td>
    </tr>
    <tr>
        <td>41</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"choice"</code></td>
    </tr>
    <tr>
        <td>42</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"greeting"</code></td>
    </tr>
    <tr>
        <td>43</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"hello"</code></td>
    </tr>
    <tr>
        <td>44</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"java/io/PrintStream"</code></td>
    </tr>
    <tr>
        <td>45</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"java/lang/Math"</code></td>
    </tr>
    <tr>
        <td>46</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"java/lang/Object"</code></td>
    </tr>
    <tr>
        <td>47</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"java/lang/System"</code></td>
    </tr>
    <tr>
        <td>48</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"main"</code></td>
    </tr>
    <tr>
        <td>49</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"out"</code></td>
    </tr>
    <tr>
        <td>50</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"println"</code></td>
    </tr>
    <tr>
        <td>51</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"random"</code></td>
    </tr>
    <tr>
        <td>52</td>
        <td><code>CONSTANT_Utf8_info</code></td>
        <td><code>"salutation"</code></td>
    </tr>
    </tbody>
</table>
<br/>
<p>
    As part of the loading process for <code>Salutation</code>, the Java Virtual Machine must make sure all of <code>Salutation</code>'s superclasses have been loaded.
    To start this process, the virtual machine looks into <code>Salutation</code>'s type data at the <code>super_class</code> item, which is a 7.
    The virtual machine looks up entry 7 in the constant pool, and finds a <code>CONSTANT_Class_info</code> entry that serves as a symbolic reference to class <code>java.lang.Object</code>.
    See Figure 8-5 for a graphical depiction of this symbolic reference.
    The virtual machine resolves this symbolic reference, which causes it to load class <code>Object</code>.
    Because <code>Object</code> is the top of <code>Salutation</code>'s inheritance hierarchy, the virtual machine and links and initializes <code>Object</code> as well.
</p>
<p><img src="images/fig8-5.gif" alt= "figure 8-5"></p>
<p>
    Now that the Java Virtual Machine has loaded the <code>Salutation</code> class and loaded, linked and initialized all its superclasses, the virtual machine is ready to link <code>Salutation</code>.
    As the first step in the linking process, the virtual machine verifies the integrity of the binary representation of class <code>Salutation</code>.
    Assume this implementation of the Java Virtual Machine performs all verification up front, except for the verification of symbolic references.
    So by the time this official verification phase of linking is completed, the virtual machine will have verified:
</p>
<ol>
    <li>that <code>Salutation</code>'s binary data is structurally correct</li>
    <li>that <code>Salutation</code> correctly implements the semantics of the Java language</li>
    <li>that <code>Salutation</code>'s bytecodes won't crash the virtual machine</li>
</ol>
<p>
    After the Java Virtual Machine has verified <code>Salutation</code>, it must prepare for <code>Salutation's</code> use by allocating any memory needed by the class.
    At this stage, the virtual machine allocates memory for <code>Salutation</code>'s class variable, <code>choice</code>, and gives it a default initial value.
    Because the <code>choice</code> class variable is an <code>int</code>, it receives the default initial value of zero.
</p>
<p>
    The three literal <code>String</code> s-- <code>hello</code>, <code>greeting</code>, and <code>salutation</code> --are constants, not class variables.
    They do not occupy memory space as class variables in the method area. They don't receive default initial values.
    Because they are declared static and final, they appear as <code>CONSTANT_String_info</code> entries in <code>Salutation</code>'s constant pool.
    The constant pool for <code>Salutation</code> that was generated by <code>javac</code> is shown in Table 8-1.
    The entries that represent <code>Salutation</code>'s constant strings are: for <code>greeting</code>, entry 1; for <code>hello</code>, entry 2; and for <code>salutation</code>, entry 3.
</p>
<p>
    After the processes of verification and preparation have successfully completed, the class is ready for resolution.
    As mentioned above, different implementations of the Java Virtual Machine may perform the resolution phase of linking at different times.
    Resolution of <code>Salutation</code> is optional at this point in its lifetime.
    Java Virtual Machines are not required to perform resolution until each symbolic reference is actually used by the program.
    If a symbolic reference is never actually used by a program, the virtual machine is not required to resolve it.
</p>
<p>
    A Java Virtual Machine implementation could perform the recursive resolution process, described above for <code>Salutation</code>, at this point in the lifetime of a program.
    If so, the program would be completely linked before <code>main()</code> is ever invoked.
    A different Java Virtual Machine implementation could perform none of the resolution process at this point.
    Instead, it could resolve each symbolic reference the first time it is actually used by the running program.
    Other implementations could choose a resolution strategy between these two extremes.
    Although different implementations may perform resolution at different times, all implementations will ensure that a type is loaded, verified, prepared, and initialized before it is used.
</p>
<p>
    Assume this implementation of the Java Virtual Machine uses late resolution.
    As each symbolic reference is used for the first time by the program, it will be checked for accuracy and converted into a direct reference.
    Assume also that this implementation uses the technique of replacing the opcode that refers to the constant pool with <code>_quick</code> equivalents.
</p>
<p>
    Once this Java Virtual Machine implementation has loaded, verified, and prepared <code>Salutation</code>, it is ready to initialize it.
    As mentioned above, the Java Virtual Machine must initialize all superclasses of a class before it can initialize the class.
    In this case, the virtual machine has already initialized <code>Object</code>, the superclass of <code>Salutation</code>.
</p>
<p>
    After the virtual machine has made sure all of <code>Salutation</code>'s superclasses have been initialized (in this case, just class <code>Object</code> ),
    it is ready to invoke <code>Salutation</code>'s <code>&lt;clinit&gt;</code> () method.
    Because <code>Salutation</code> contains a class variable, <code>choice</code>, that has an initializer that doesn't resolve at compile-time to a constant,
    the compiler does place a <code>&lt;clinit&gt;</code> () method into <code>Salutation</code>'s class file.
</p>
<p>Here's the <code>&lt;clinit&gt;</code> () method for <code>Salutation</code>:</p>
<pre>begin
                   // Invoke class method Math.random(), passing no
                   // parameters. Push double result.
0 invokestatic #13 &lt;Method double random()
                   // Push double constant 2.99 from constant pool.
3 ldc2_w #14 &lt;Double 2.99
6 dmul             // Pop two doubles, multiple, push double result.
7 d2i              // Pop double, convert to int, push int result.
                   // Pop int, store int Salutation.choice
8 putstatic #10 &lt;Field int choice
11 return          // Return void from &lt;clinit&gt;()
end
</pre>
<p>
    The Java Virtual Machine executes <code>Salutation</code>'s <code>&lt;clinit&gt;</code>() method to set the <code>choice</code> field to its proper initial value.
    Before executing <code>&lt;clinit&gt;</code>(), <code>choice</code> has its default initial value of zero.
    After executing <code>&lt;clinit&gt;</code>(), it has one of three values chosen pseudo-randomly: zero, one, or two.
</p>
<p>
    The first instruction of the <code>&lt;clinit&gt;</code>() method, <code>invokestatic #13</code>, refers to constant pool entry 13,
    a <code>CONSTANT_Methodref_info</code> that represents a symbolic reference to the <code>random()</code> method of class <code>java.lang.Math</code>.
    You can see a graphical depiction of this symbolic reference in Figure 8-6.
    The Java Virtual Machine resolves this symbolic reference, which causes it to load, link, and initialize class <code>java.lang.Math</code>.
    It places a direct reference to the <code>random()</code> method into constant pool entry 13, marks the entry as resolved, and replaces the <code>invokestatic</code> opcode with <code>invokestatic_quick</code>.
</p>
<p><img src="images/fig8-6.gif" alt= "figure 8-6"></p>
<p>
    Having completed the resolution process for constant pool entry 13, the Java Virtual Machine is ready to invoke the method.
    When the virtual machine actually invokes the <code>random()</code> method,
    it will load, link, and initialize any types referenced symbolically from <code>Math</code>'s constant pool and <code>random()</code>'s code.
    When this method returns, the virtual machine will push the returned <code>double</code> value onto the <code>main()</code> method's operand stack.
</p>
<p>
    To execute the next instruction, <code>ldc2_w #14</code>, the virtual machine looks into constant pool entry 14 and finds an unresolved <code>CONSTANT_Double_info</code> entry.
    The virtual machine resolves this entry to the double value 2.99, marks the entry as resolved, and replaces the <code>ldc2_w</code> opcode with <code>ldc2_w_quick</code>.
    Once the virtual machine has resolved constant pool entry 14, it pushes the constant <code>double</code> value, 2.99, onto the operand stack.
</p>
<p>
    Note that this entry, a <code>CONSTANT_Double_info</code>, does not refer to any other constant pool entry or item outside this class.
    The eight bytes of the <code>double</code> value 2.99 are specified within the entry itself.
</p>
<p>
    Note also that in this constant pool, there is no entry with an index of 15.
    As mentioned in Chapter 6, "The Java Class File," entries of type <code>CONSTANT_Double_info</code> and <code>CONSTANT_Long_info</code> occupy two slots in the constant pool.
    Thus, the <code>CONSTANT_Double_info</code> at index 14 is considered to occupy both indices 14 and 15.
</p>
<p>
    To execute the next instruction, <code>dmul</code>, the virtual machine pops two <code>double</code>s, multiplies them, and pushes the <code>double</code> result.
    For the next instruction, the virtual machine pops the <code>double</code>, converts it to <code>int</code>, and pushes the <code>int</code> result.
    Assume that for this particular execution of <code>Salutation</code>, the result of this operation is the <code>int</code> value two.
</p>
<p>
    The next instruction, <code>putstatic #10</code>, uses another symbolic reference from the constant pool, this one refers to the <code>choice</code> variable of <code>Salutation</code> itself.
    This instruction illustrates that a class's bytecodes use symbolic references to refer not only to fields and methods of other types, but also to its own fields and methods. When the virtual machine executes this instruction, it looks up constant pool entry 10 and finds an as yet unresolved <code>CONSTANT_Fieldref_info</code> item. See Figure 8-7 For a graphical depiction of this symbolic reference. The virtual machine resolves the reference by locating the <code>choice</code> class variable in <code>Salutation</code>'s type data in the method area, and placing a pointer to the actual variable data in constant pool entry 10. It marks the entry as resolved and replaces the <code>putstatic</code> opcode with <code>putstatic_quick</code>.
</p>
<p><img src="images/fig8-7.gif" alt= "figure 8-7"></p>
<p>
    Once it has resolved the <code>CONSTANT_Fieldref_info</code> entry for <code>choice</code>,
    the virtual machine pops an <code>int</code> (in this case a two) from the operand stack and places it into the <code>choice</code> variable.
    The execution of the <code>putstatic</code> instruction is now complete.
</p>
<p>
    Lastly, the virtual machine executes the return instruction, which signals to the virtual machine that the <code>&lt;clinit&gt;</code>() method,
    and hence the initialization of class <code>Salutation</code>, is complete.
</p>
<p>
    Now that class <code>Salutation</code> has been initialized, it is finally ready for use.
    The Java Virtual Machine invokes <code>main()</code>, and the program begins.
    Here's the bytecode sequence for <code>Salutation</code>'s <code>main()</code> method:
</p>
<pre>begin
                // Push objref to literal string from constant pool 
                // entry 2
0 ldc #2 &lt;String "Hello, world!"
2 astore_1      // Pop objref into loc var 1: String s = hello;
                // Push int from static field Salutation.choice. Note
                // that by this time, choice has definitely been
                // given its proper initial value.
3 getstatic #10 &lt;Field int choice
6 iconst_1      // Push int constant 1
                // Pop two ints, compare, if not equal branch to 16:
7 if_icmpne 16  // if (choice == 1) {
                // Here, choice does equal 1. Push objref to string
                // literal from constant pool:
10 ldc #1 &lt;String "Greetings, planet!"
12 astore_1     // Pop objref into loc var 1: s = greeting;
13 goto 26      // Branch unconditionally to offset 26
                // Push int from static field Salutation.choice
16 getstatic #10 &lt;Field int choice
19 iconst_2     // Push int constant 2
                // Pop two ints, compare, if not equal branch to 26:
20 if_icmpne 26 // if (choice == 2) {
                // Here, choice does equal 2. Push objref to string
                // literal from constant pool:
23 ldc #3 &lt;String "Salutations, orb!"
25 astore_1     // Pop objref into loc var 1: String s = salutation;
                // Push objref from System.out
26 getstatic #11 &lt;Field java.io.PrintStream out
29 aload_1      // Push objref (to a String) from loc var 1
                // Pop objref (to a String), pop objref(to
                // System.out), invoke println() on System.out
                // passing the string as the only parameter:
                // System.out.println(s);
30 invokevirtual #12 &lt;Method void println(java.lang.String)
33 return       // Return void from main()
end
</pre>
<p>
    The first instruction in <code>main()</code>, <code>ldc #2</code>, uses a symbolic reference to the string literal <code>"Hello, world!"</code>.
    When the virtual machine executes this instruction, it looks up constant pool entry 2 and finds a <code>CONSTANT_String_info</code> item that hasn't yet been resolved.
    See Figure 8-8 For a graphical depiction of the symbolic reference to this string literal.
</p>
<p><img src="images/fig8-8.gif" alt= "figure 8-8"></p>
<p>
    As part of executing the <code>ldc</code> instruction, the virtual machine resolves the constant pool entry.
    It creates and interns a new <code>String</code> object with the value <code>"Hello, world!"</code>,
    places a reference to the string object in the constant pool entry, marks the entry as resolved,
    and replaces the <code>ldc</code> opcode with an <code>ldc_quick</code>.
</p>
<p>
    Now that the virtual machine has resolved the <code>"Hello, world!"</code> string literal, it pushes the reference to that <code>String</code> object onto the stack.
    The next instruction, <code>astore_1</code>, pops the reference and stores it into local variable position 1, the <code>s</code> variable.
</p>
<p>
    To execute the next instruction, <code>getstatic #10</code>, the virtual machine looks up constant pool entry 10 and discovers a <code>CONSTANT_Fieldref_info</code> entry that has already been resolved.
    This entry, a symbolic reference to <code>Salutation</code>'s own <code>choice</code> field, was resolved by the <code>putstatic #10</code> instruction in the <code>&lt;clinit&gt;</code>() method.
    The virtual machine simply replaces the <code>getstatic</code> opcode with <code>getstatic_quick</code>, and pushes the <code>int</code> value of <code>choice</code> onto the stack.
</p>
<p>
    To execute <code>main()</code>'s next instruction, <code>iconst_1</code>, the virtual machine simply pushes <code>int</code> one onto the operand stack.
    For the next instruction, <code>ificmpne 16</code>, the virtual machine pops the top two <code>int</code>s and subtracts one from the other.
    In this case, since the value of <code>choice</code> was set by the <code>&lt;clinit&gt;</code> () method to be two, the result of the subtraction is not zero.
    As a consequence, the virtual machine takes the branch.
    It updates the pc register so that the next instruction it executes is the <code>getstatic</code> instruction at offset 16.
</p>
<p>
    The <code>getstatic</code> instruction at offset 16 refers to the same constant pool entry referred to by the <code>getstatic</code> instruction at offset three: constant pool entry 10.
    When the virtual machine executes the <code>getstatic</code> at offset 16,
    it looks up constant pool entry 10 and finds a <code>CONSTANT_Fieldref_info</code> entry that is already resolved.
    It replaces the <code>getstatic</code> opcode with <code>getstatic_quick</code>,
    and pushes the <code>int</code> value of <code>Salutation</code>'s <code>choice</code> class variable (a two) onto the operand stack.
</p>
<p>
    To execute the next instruction, <code>iconst_2</code>, the virtual machine pushes an <code>int</code> two onto the stack.
    For the next instruction, another <code>ificmpne 26</code>, the virtual machine again pops two <code>int</code>s and subtracts one from the other.
    This time, however, both <code>int</code>s equal two, so the result of the subtraction is zero.
    As a consequence, the virtual machine does not take the branch and continues on to execute the next instruction in the bytecode array, another <code>ldc</code>.
</p>
<p>
    The <code>ldc</code> instruction at offset 23 refers to constant pool entry 3,
    a <code>CONSTANT_String_info</code> entry that serves as a symbolic reference to the string literal <code>"Salutations, orb!"</code>.
    The virtual machine looks up this entry in the constant pool and discovers it is as yet unresolved.
    To resolve the entry, the virtual machine creates and interns a new <code>String</code> object with the value <code>"Salutations, orb!"</code>,
    places a reference to the new object in the data for constant pool entry 3,
    and replaces the <code>ldc</code> opcode with <code>ldc_quick</code>.
    Having resolved the string literal, the virtual machine pushes the reference to the <code>String</code> object onto the stack.
</p>
<p>
    To execute the next instruction, <code>astore_1</code>,
    the virtual machine pops the object reference to the <code>"Salutations, orb!"</code> string literal off the stack and stores it into local variable slot 1,
    overwriting the reference to <code>"Hello, world!"</code> written there by the <code>astore_1</code> instruction at offset 2.
</p>
<p>
    The next instruction, <code>getstatic #11</code>,
    uses a symbolic reference to a public static class variable of <code>java.lang.System</code> with the name <code>out</code> and the type <code>java.io.PrintStream</code>.
    This symbolic reference occupies the <code>CONSTANT_Fieldref_info</code> entry at index 11 in the constant pool.
    See Figure 8-9 For a graphical depiction of this symbolic reference.
</p>
<p><img src="images/fig8-9.gif" alt= "figure 8-9"></p>
<p>
    To resolve the reference to <code>System.out</code>,
    the Java Virtual Machine must load, link, and initialize <code>java.lang.System</code> to make sure it has a public static field, named <code>out</code>, of type <code>java.io.PrintStream</code>.
    Then, the virtual machine will replace the symbolic reference with a direct reference, such as a native pointer,
    so that any future uses of <code>System.out</code> by <code>Saluation</code> won't require resolution and will be faster.
    Lastly, the virtual machine will replace the <code>getstatic</code> opcode with <code>getstatic_quick</code>.
</p>
<p>
    Once the virtual machine has successfully resolved the symbolic reference, it will push the reference to <code>System.out</code> onto the stack.
    To execute the next instruction, <code>aload_1</code>, the virtual machine simply pushes onto the stack the object reference from local variable 1,
    which is the reference to the <code>"Salutations, orb!"</code> string literal.
</p>
<p>
    To execute the next instruction, <code>invokevirtual #12</code>,
    the Java Virtual Machine looks up constant pool entry 12 and finds an unresolved <code>CONSTANT_Methodref_info</code> entry,
    a symbolic reference to the <code>println()</code> method of <code>java.io.PrintStream</code>.
    See Figure 8-10 for a graphical depiction of this symbolic reference.
    The virtual machine loads, links, and initializes <code>java.io.PrintStream</code>,
    and makes sure it has a <code>println()</code> method that is <code>public</code>, returns <code>void</code>, and takes a <code>String</code> argument.
    It marks the entry as resolved and puts a direct reference (an index into <code>PrintStream</code>'s method table) into the data for the resolved constant pool entry.
    Lastly, the virtual machine replaces the <code>invokevirtual</code> opcode with <code>invokevirtual_quick</code>,
    and places the method table index and the number of arguments accepted by the method as operands to the <code>invokevirtual_quick</code> opcode.
</p>
<p><img src="images/fig8-10.gif" alt= "figure 8-10"></p>
<p>
    When the virtual machine actually invokes the <code>println()</code> method,
    it will load, link, and initialize any types referenced symbolically from <code>PrintStream</code>'s constant pool and <code>println()</code>'s code.
</p>
<p>
    The next instruction is the last instruction the <code>main()</code> method: <code>return</code>.
    Because <code>main()</code> was being executed by the only non-daemon thread running in the <code>Salutation</code> application,
    executing the <code>return</code> instruction will cause the virtual machine to exit.
    Note that constant pool entry 1, which contained a symbolic reference to the <code>"Greetings, planet!"</code> string literal,
    was never resolved during this execution of the <code>Salutation</code> application.
    Because <code>choice</code> happened to be initialized with a value of two,
    the instruction that referred to constant pool entry 1, the <code>ldc #1</code> instruction at offset 10, was never executed.
    As a result, the virtual machine never created a <code>String</code> object with the value <code>"Greetings, planet!"</code>.
</p>



<h2 id="greet_application">Example: The Dynamic Extension of the Greet Application</h2>
<p>
    As an example of an application that performs dynamic extension through class loader objects, consider the following class:
</p>
<pre>begin
// On CD-ROM in file linking/ex6/Greet.java
import COM.artima.greeter.*;

public class Greet {

    // Arguments to this application:
    //     args[0] - path name of directory in which class files
    //               for greeters are stored
    //     args[1], args[2],... - class names of greeters to load
    //               and invoke the greet() method on.
    //
    // All greeters must implement the COM.artima.greeter.Greeter
    // interface.
    //
    public static void main(String[] args) {

        if (args.length &lt;= 1) {
            System.out.println("Enter base path and greeter class names as args.");
            return;
        }

        GreeterClassLoader gcl = new GreeterClassLoader(args[0]);

        for (int i = 1; i &lt; args.length; ++i) {
            try {

                // Load the greeter specified on the command line
                Class c = gcl.loadClass(args[i], true);

                // Instantiate it into a greeter object
                Object o = c.newInstance();

                // Cast the Object ref to the Greeter interface type
                // so greet() can be invoked on it
                Greeter greeter = (Greeter) o;

                // Greet the world in this greeter's special way
                greeter.greet();
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
end
</pre>
<p>
    The <code>Greet</code> application is a fancy incarnation of the typical "Hello, world!" program.
    <code>Greet</code> uses a class loader object to dynamically extend itself with classes--called "greeters"--that do the actual work of telling the world hello.
</p>
<p>A greeter is any class that implements the <code>COM.artima.greeter.Greeter</code> interface:</p>

<pre>begin
// On CD-ROM in file linking/ex6/COM/artima/greeter/Greeter.java
package COM.artima.greeter;

public interface Greeter {
    void greet();
}
end
</pre>

<p>
    As you can see from the code above, the <code>Greeter</code> interface declares only one method: <code>greet()</code>.
    When a greeter object's <code>greet()</code> method is invoked, the object should say hello to the world in its own unique way. Here are a few examples of greeters:
</p>

<pre>begin
// On CD-ROM in file linking/ex6/greeters/Hello.java <p>import COM.artima.greeter.Greeter;
public class Hello implements Greeter {
    public void greet() {
        System.out.println("Hello, world!");
    }
}

// On CD-ROM in file linking/ex6/greeters/Greetings.java
import COM.artima.greeter.Greeter;
public class Greetings implements Greeter {
    public void greet() {
        System.out.println("Greetings, planet!");
    }
}

// On CD-ROM in file linking/ex6/greeters/Salutations.java
import COM.artima.greeter.Greeter;

public class Salutations implements Greeter {
    public void greet() {
        System.out.println("Salutations, orb!");
    }
}

// On CD-ROM in file linking/ex6/greeters/HowDoYouDo.java
import COM.artima.greeter.Greeter;

public class HowDoYouDo implements Greeter {
    public void greet() {
        System.out.println("How do you do, globe!");
    }
}
end
</pre>

<p>Greeters can be more complex than the above four examples. Here's an example of a greeter that chooses a greeting based on the time of day:</p>

<pre>begin
// On CD-ROM in file linking/ex6/greeters/HiTime.java
import COM.artima.greeter.Greeter;
import java.util.Date;

public class HiTime implements Greeter {
    public void greet() {
        // Date's no-arg constructor initializes itself to the
        // current date and time
        Date date = new Date();
        int hours = date.getHours();

        // Some hours: midnight, 0; noon, 12; 11PM, 23;
        if (hours &gt;= 4 &amp;&amp; hours &lt;= 11) {
            System.out.println("Good morning, world!");
        }
        else if (hours &gt;= 12 &amp;&amp; hours &lt;= 16) {
            System.out.println("Good afternoon, world!");
        }
        else if (hours &gt;= 17 &amp;&amp; hours &lt;= 21) {
            System.out.println("Good evening, world!");
        }
        else if (hours &gt;= 22  hours &lt;= 3) {
            System.out.println("Good night, world!");
        }
        else {
            // This should never happen.
            System.out.println("Oh oh, the clock is broken, world!");
        }
    }
}
end
</pre>

<p>
    The <code>Greet</code> application doesn't know at compile-time what greeter classes it will load and where those classes will be stored.
    At run-time it takes a directory path as its first command-line argument and greeter class names as subsequent arguments.
    It attempts to load the greeters using the path name as a base directory.
</p>
<p>For example, imagine you invoke the <code>Greet</code> application with the following command line:</p>

<pre>begin
java Greet greeters Hello
end
</pre>

<p>
    In this command line, <code>java</code> is the name of the Java Virtual Machine executable.
    <code>Greet</code> is the class name of the <code>Greet</code> application.
    <code>greeters</code> is the name of a directory relative to the current directory in which the <code>Greet</code> application should look for greeters.
    <code>Hello</code> is the name of the greeter.
</p>
<p>
    When the <code>Greet</code> application is invoked with the above command line,
    it attempts to load <code>greeters/Hello.class</code> and invoke <code>Hello</code>'s <code>greet()</code> method.
    If the <code>Hello.class</code> file is indeed sitting in a directory named <code>greeters</code>, the application will print:
</p>

<pre>begin
Hello, world!
end
</pre>

<p>The <code>Greet</code> application can handle more than one greeter. If you invoke the it with the following command line:</p>

<pre>begin
java Greet greeters Hello Greetings Salutations HowDoYouDo
end
</pre>

<p>The <code>Greet</code> application will load each of the four greeters listed and invoke their <code>greet()</code> methods, yielding the following output:</p>

<pre>begin
Hello, world!
Greetings, planet!
Salutations, orb!
How do you do, globe!
end
</pre>

<p>
    The <code>Greet</code> application works by first checking to make sure there are at least two command-line arguments: a directory path and at least one greeter class name.
    It then instantiates a new <code>GreeterClassLoader</code> object, which will be responsible for loading the greeters.
    (The inner workings of class <code>GreeterClassLoader</code>, a subclass of <code>java.lang.ClassLoader</code>, will be described later in this section.)
    The constructor for <code>GreeterClassLoader</code> accepts a <code>String</code> that it uses as a directory path in which to look for greeters.
</p>
<p>
    After it has created the <code>GreeterClassLoader</code> object,
    the <code>Greet</code> application invokes its <code>loadClass()</code> method for each greeter name that appears on the command line.
    When it invokes <code>loadClass()</code>, it passes the greeter class name in <code>name</code> and sets the <code>resolve</code> flag to <code>true</code>:
</p>

<pre>begin
// Load the greeter specified on the command line
Class c = gcl.loadClass(args[i], true);
end
</pre>

<p>
    If the <code>loadClass()</code> method is unsuccessful, it throws an exception or error.
    If the <code>loadClass()</code> method is successful, it returns the <code>Class</code> instance for the newly loaded, linked, and initialized type.
</p>
<p>
    Once <code>loadClass()</code> has returned a <code>Class</code> instance,
    the <code>Greet</code> application's <code>main()</code> method instantiates a new instance of the greeter by calling <code>newInstance()</code> on the <code>Class</code> instance:
</p>

<pre>begin
// Instantiate it into a greeter object
Object o = c.newInstance();
end
</pre>

<p>
    When the <code>newInstance()</code> method is invoked on a <code>Class</code> object,
    the virtual machine creates and initializes a new instance of the class represented by the <code>Class</code> object.
    To initialize the new instance, the the virtual machine invokes its no-arg constructor.
</p>
<p>The <code>Greet</code> application then casts the <code>Object</code> reference that points to the greeter object to a <code>Greeter</code> reference:</p>

<pre>begin
// Cast the Object ref to the Greeter interface type
// so greet() can be invoked on it
Greeter greeter = (Greeter) o;
end
</pre>

<p>Finally, armed with a <code>Greeter</code> reference, the <code>main()</code> method invokes the <code>greet()</code> method on the greeter object:</p>

<pre>begin
// Greet the world in this greeter's special way
greeter.greet();
end
</pre>

<p>Here's the code for <code>GreeterClassLoader</code> :</p>

<pre>begin
// On CD-ROM in file
// linking/ex6/COM/artima/greeter/GreeterClassLoader.java
package COM.artima.greeter;

import java.io.*;
import java.util.Hashtable;

public class GreeterClassLoader extends ClassLoader {

    // types is this class loader object's private
    // cache of type names it has loaded. For each type
    // name, the Hashtable stores a reference to the
    // Class instance for that type
    private Hashtable types = new Hashtable();

    // basePath gives the path to which this class
    // loader appends "/typename.class" to get the
    // full path name of the class file to load
    private String basePath;

    public GreeterClassLoader(String basePath) {
        this.basePath = basePath;
    }

    public synchronized Class loadClass(String className, boolean resolveIt) throws ClassNotFoundException {
        Class result;
        byte classData[];

        // Check the local cache
        result = (Class) types.get(className);
        if (result != null) {
            // Return a cached class
            return result;
        }

        // Check with the primordial class loader
        try {
            result = super.findSystemClass(className);
            // Return a system class
            return result;
        }
        catch (ClassNotFoundException e) {
        }

        // Don't attempt to load a system file except through
        // the primordial class loader
        if (className.startsWith("java.")) {
            throw new ClassNotFoundException();
        }

        // Try to load it from the basePath directory.
        classData = getTypeFromBasePath(className);
        if (classData == null) {
            System.out.println("GCL - Can't load class: " + className);
            throw new ClassNotFoundException();
        }

        // Parse it
        result = defineClass(className, classData, 0, classData.length);
        if (result == null) {
            System.out.println("GCL - Class format error: " + className);
            throw new ClassFormatError();
        }

        if (resolveIt) {
            resolveClass(result);
        }

        // Add newly loaded type to private name cache
        types.put(className, result);

        // Return class from basePath directory
        return result;
    }

    private byte[] getTypeFromBasePath(String className) {
        InputStream in = null;
        String fileName = basePath + "/" + className + ".class";

        try {
            in = new FileInputStream(fileName);
        } catch (FileNotFoundException e) {
            return null;
        }

        ByteArrayOutputStream out = new ByteArrayOutputStream();

        try {
            int c = in.read();
            while (c != -1) {
                out.write(c);
                c = in.read();
            }
        }
        catch (IOException e) {
            System.out.println("GCL: Error reading bytes of:" + className);
            e.printStackTrace();
            return null;
        }

        return out.toByteArray();
    }
}
end
</pre>

<p>
    The <code>GreeterClassLoader</code> declares two instance variables, <code>types</code> and <code>basePath</code>.
    The <code>types</code> variable, a <code>Hashtable</code>, is used to store for each type this class loader object loads the type's name and a reference to its <code>Class</code> instance.
    The <code>basePath</code> variable, a <code>String</code>, is used to store the directory path (passed to <code>GreetingClassLoader</code>'s constructor)
    in which the <code>loadClass()</code> method should look for the class file of the type it has been requested to load.
</p>
<p>
    The <code>loadClass()</code> method begins by checking to see if the requested type has already been loaded by this class loader.
    It does this by looking up the type name passed in parameter <code>name</code> in the <code>Hashtable</code>.
    If the name exists in the <code>Hashtable</code>, <code>loadClass()</code> retrieves and returns the <code>Class</code> instance for that name:
</p>

<pre>begin
// Check the local cache
result = (Class) classes.get(className);
if (result != null) {
    // Return a cached class
    return result;
}
end
</pre> 

<p>
    Why does <code>GreeterClassLoader</code> maintain a list of the types it has loaded?
    As mentioned earlier in this chapter, the virtual machine maintains its own list of type names that have already been requested of each class loader.
    When loading superclasses in Step 1 of resolution, the virtual machine always checks its own internal list before automatically invoking <code>loadClass()</code>.
    As a result, the virtual machine will never automatically invoke <code>loadClass()</code> on a class loader object with the name of a type already loaded by that class loader object.
    Nevertheless, <code>GreeterClassLoader</code> maintains its own list of the names of the types it has already loaded.
    Why? Because even though the virtual machine will never ask a class loader object to load the same type twice, the application just might.
</p>
<p>As an example, imagine the <code>Greet</code> application were invoked with this command line:</p>

<pre>begin
java Greet greeters Hello Hello Hello Hello Hello
end
</pre> 

<p>
    Given this command line, the <code>Greet</code> application would invoke <code>loadClass()</code> with the name <code>Hello</code> five times on the same <code>GreeterClassLoader</code> object.
    The first time, the <code>GreeterClassLoader</code> would load the class and add its name and <code>Class</code> instance to the <code>Hashtable</code>.
    The next four times, however, the <code>GreeterClassLoader</code> would simply extract the <code>Class</code> instance for <code>Hello</code> from its <code>Hashtable</code> and return that.
    It would only load class <code>Hello</code> once.
</p>
<p>
    If the <code>loadClass()</code> method determines that the requested type has not been loaded into its name space,
    it next passes the name of the requested type to <code>findSystemClass()</code>:
</p>

<pre>begin
// Check with the primordial class loader
try {
    result = super.findSystemClass(className);
    // Return a system class
    return result;
}
catch (ClassNotFoundException e) {
}
end
</pre> 

<p>
    When the <code>findSystemClass()</code> method is invoked, the primordial class loader attempts to load the type.
    If it successfully loads the type, the primordial class loader also links and initializes the type.
    (As mentioned earlier in this chapter, if the type is a class, the primordial class loader makes sure all the class's superclasses are loaded, linked, and initialized as well.)
    <code>findSystemClass()</code> returns the <code>Class</code> instance created by the primordial class loader when it successfully loaded the type,
    and <code>loadClass()</code> returns that same <code>Class</code> instance.
    Note that classes loaded via <code>findSystemClass()</code> are marked as having been loaded by the primordial class loader.
    The <code>loadClass()</code> method of <code>GreeterClassLoader</code> does not add the name of such types to its <code>Hashtable</code>.
</p>
<p>
    If the primordial class loader is unable to load the type, <code>findSystemClass()</code> throws <code>ClassNotFoundError</code>.
    In this case, the <code>loadClass()</code> method next checks to make sure the requested class is not part of the <code>java</code> package:
</p>

<pre>begin
// Don't attempt to load a system file except through
// the primordial class loader
if (className.startsWith("java.")) {
    throw new ClassNotFoundException();
}
end
</pre> 

<p>
    This check prevents members of the standard <code>java</code> packages ( <code>java.lang</code>, <code>java.io</code>, etc.) from being loaded by anything but the primordial class loader.
    As mentioned in Chapter 3, "Security," class loader objects should not attempt to custom load types that declare themselves to be part of the Java API (or any other "restricted" packages)
    but which can't be loaded by the primordial class loader.
</p>
<p>
    If the type name doesn't begin with "<code>java</code>," the <code>loadClass()</code> method next invokes <code>getTypeFromBasePath()</code>,
    which attempts to import the binary data in the class loader object's custom way:
</p>

<pre>begin
// Try to load it from the basePath directory.
classData = getTypeFromBasePath(className);
if (classData == null) {
    System.out.println("GCL - Can't load class: " + className);
    throw new ClassNotFoundException();
}
end
</pre>

<p>
    The <code>getTypeFromBasePath()</code> method looks for a file with the type name plus a "<code>.class</code>" extension in the base directory passed to the <code>GreeterClassLoader</code>'s constructor.
    If the <code>getTypeFromBasePath()</code> method is unable to find the file, it returns a <code>null</code> result and the <code>loadClass()</code> method throws <code>ClassNotFoundException</code>.
    Otherwise, <code>loadClass()</code> invokes <code>defineClass()</code>, passing the <code>byte</code> array returned by <code>getTypeFromBasePath()</code>:
</p>

<pre>begin
// Parse it
result = defineClass(className, classData, 0, classData.length);
if (result == null) {
    System.out.println("GCL - Class format error: " + className);
    throw new ClassFormatError();
}
end
</pre> 

<p>
    The <code>defineClass()</code> method uses the primordial class loader to complete the loading process:
    to parse the binary data into internal data structures and create a <code>Class</code> instance.
    The <code>defineClass()</code> method does not link and initialize the type.
    (As mentioned earlier in this chapter, if the type is a class,
    the <code>defineClass()</code> method also make sure all the class's superclass are loaded.
    It does this by invoking <code>loadClass()</code> on this class loader object for each superclass in the hierarchy
    that hasn't yet been loaded by this class loader, with the <code>resolve</code> flag set to <code>false</code>.)
</p>
<p>
    If <code>defineClass()</code> is successful, it returns the newly created <code>Class</code> instance.
    The <code>loadClass()</code> method checks to see if <code>resolve</code> were set to <code>true</code>.
    If so, it invokes <code>resolveClass()</code>, passing the <code>Class</code> instance returned by <code>defineClass()</code>.
    The <code>resolveClass()</code> method links and initializes the class.
    (As mentioned earlier in this chapter, <code>resolveClass()</code> also makes sure that, if the type is a class, all its superclasses are linked and initialized as well.)
</p>

<pre>begin
if (resolveIt) {
    resolveClass(result);
}
end
</pre> 

<p>Finally, the <code>loadClass()</code> method adds the name and <code>Class</code> instance for the newly loaded type into the class loader's <code>Hashtable</code>, and returns the <code>Class</code> instance:</p>

<pre>begin
// Add newly loaded type to private name cache
classes.put(className, result);

// Return class from basePath directory
return result;
end
</pre>

<p>
    The <code>Greet</code> application demonstrates the flexibility inherent in Java's linking model.
    The <code>Greet</code> application does not know at compile time what greeters it will be loading and dynamically linking to at run-time.
    In the examples above, class <code>Greet</code> invokes the <code>greet()</code> method in classes <code>Hello</code>, <code>Greetings</code>, <code>Salutations</code>, and <code>HowDoYouDo</code>.
    But if you look at <code>Greet</code>'s constant pool, there is no symbolic reference to any of these classes.
    There is only a symbolic reference to their shared superinterface, <code>COM.artima.greeter.Greeter</code>.
    Greeters themselves, so long as they implement the <code>COM.artima.greeter.Greeter</code> interface,
    can be anything and can be written and compiled anytime, even after the <code>Greet</code> application itself is compiled.
</p>



<h2 id="unloading_greeters">Example: Unloading Unreachable Greeters</h2>
<p>As an example of dynamically loaded types becoming unreachable and getting unloaded by the virtual machine, consider the following application:</p>

<pre>begin
// On CD-ROM in file linking/ex6/GreetAndForget.java
import COM.artima.greeter.*;

public class GreetAndForget {

    // Arguments to this application:
    //     args[0] - path name of directory in which class files
    //               for greeters are stored
    //     args[1], args[2],... - class names of greeters to load
    //               and invoke the greet() method on.
    //
    // All greeters must implement the COM.artima.greeter.Greeter
    // interface.
    //
    public static void main(String[] args) {
        if (args.length &lt;= 1) {
            System.out.println("Enter base path and greeter class names as args.");
            return;
        }

        for (int i = 1; i &lt; args.length; ++i) {
            try {
                GreeterClassLoader gcl = new GreeterClassLoader(args[0]);

                // Load the greeter specified on the command line
                Class c = gcl.loadClass(args[i], true);

                // Instantiate it into a greeter object
                Object o = c.newInstance();

                // Cast the Object ref to the Greeter interface type
                // so greet() can be invoked on it
                Greeter greeter = (Greeter) o;

                // Greet the world in this greeter's special way
                greeter.greet();

                // Forget the class loader object, Class
                // instance, and greeter object
                gcl = null;
                c = null;
                o = null;
                greeter = null;

                // At this point, the types loaded through the
                // GreeterClassLoader object created at the top of
                // this for loop are unreferenced and can be unloaded
                // by the virtual machine.
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
end
</pre>

<p>
    The <code>GreetAndForget</code> application accepts the same command line arguments as the <code>Greet</code> application of the previous example.
    The first argument is a base directory path name where the <code>GreetAndForget</code> application will look for greeters.
    Subsequent arguments are greeter names.
    To understand this example you should be familiar with the <code>Greet</code> application of the previous example.
</p>
<p>Imagine you invoke the <code>GreetAndForget</code> application with the following command line:</p>

<pre>begin
java GreetAndForget greeters Surprise HiTime Surprise
end
</pre>

<p>
    The code for the <code>HiTime</code> greeter, which selects a different greeting based on the time of day, is shown above in the previous section of this chapter.
    The code for the <code>Surprise</code> greeter,
    which pseudo-randomly selects one of four helper greeters-- <code>Hello</code>, <code>Greetings</code>, <code>Salutations</code>, or <code>HowDoYouDo</code> --and
    invokes its <code>greet()</code> method, is shown here:
</p>

<pre>begin
// On CD-ROM in file linking/ex6/greeters/Surprise.java
import COM.artima.greeter.Greeter;

public class Surprise implements Greeter {

    public void greet() {
        // Choose one of four greeters pseudo-randomly and
        // invoke its greet() method.
        int choice = (int) (Math.random() * 3.99);

        Greeter g;

        switch(choice) {
            case 0:
                g = new Hello();
                g.greet();
                break;

            case 1:
                g = new Greetings();
                g.greet();
                break;

            case 2:
                g = new Salutations();
                g.greet();
                break;

            case 3:
                g = new HowDoYouDo();
                g.greet();
                break;
        }
    }
}
end
</pre>

<p>
    Given the command line shown above, the <code>GreetAndForget</code> application invokes the <code>greet()</code> method of the <code>Surprise</code> greeter first,
    then the <code>HiTime</code> greeter,
    then the <code>Surprise</code> greeter again.
    <code>GreetAndForget</code>'s actual output would vary depending on the time of day and <code>Surprise</code>'s pseudo-random mood.
    For the purposes of this example, assume that you typed in the above command, hit return, and got the following output:
</p>

<pre>begin
How do you do, globe!
Good afternoon, world!
Greetings, planet!
end
</pre>

<p>
    This output indicates <code>Surprise</code> chose to execute <code>HowDoYouDo</code>'s <code>greet()</code> method the first time around and
    <code>Greetings</code>'s <code>greet()</code> method the second time around.
</p>
<p>
    The first pass through <code>GreetAndForget</code>'s for loop, the virtual machine loads the <code>Surprise</code> class and invokes its <code>greet()</code> method.
    The constant pool for <code>Surprise</code> includes a symbolic reference to each the four helper greeters that it may choose:
    <code>Hello</code>, <code>Greetings</code>, <code>Salutations</code>, and <code>HowDoYouDo</code>.
    Assuming the Java Virtual Machine that you used to run the <code>GreetAndForget</code> application uses late resolution,
    only one of these four symbolic references will be resolved during the first pass of <code>GreetAndForget</code>'s for loop:
    the symbolic reference to <code>HowDoYouDo</code>.
    The virtual machine resolves this symbolic reference when it executes the bytecodes that correspond to the following statement in <code>Surprise</code>'s <code>greet()</code> method:
</p>

<pre>begin
g = new HowDoYouDo();
end
</pre>

<p>
    To resolve the symbolic reference from <code>Surprise</code>'s constant pool to <code>HowDoYouDo</code>,
    the virtual machine invokes the <code>GreeterClassLoader</code> object's <code>loadClass()</code> method,
    passing the string "<code>HowDoYouDo</code>" in the <code>name</code> parameter and setting the <code>resolve</code> flag to <code>true</code>.
    The virtual machine uses the <code>GreeterClassLoader</code> object to load <code>HowDoYouDo</code>
    because <code>Surprise</code> was loaded through the <code>GreeterClassLoader</code> object.
    As mentioned earlier in this chapter,
    when the Java Virtual Machine resolves a symbolic reference,
    it uses the same class loader that loaded the referencing type (in this case, <code>Surprise</code> ) to load the referenced type (in this case, <code>HowDoYouDo</code> ).
</p>
<p>Once <code>Surprise</code>'s <code>greet()</code> method has created a new <code>HowDoYouDo</code> instance, it invokes its <code>greet()</code> method:</p>

<pre>begin
g.greet();
end
</pre>

<p>
    As the virtual machine executes <code>HowDoYouDo</code>'s <code>greet()</code> method,
    it must resolve two symbolic references from <code>HowDoYouDo</code>'s constant pool--one to class <code>java.lang.System</code> and another to class <code>java.io.PrintStream</code>.
    To resolve these symbolic references, the virtual machine invokes the <code>GreeterClassLoader</code> object's <code>loadClass()</code> method,
    once with the name <code>java.lang.System</code> and once with the name <code>java.io.PrintStream</code>.
    As before, the virtual machine uses the <code>GreeterClassLoader</code> object to load these classes
    because the referencing class--in this case, <code>HowDoYouDo</code> --was loaded through the <code>GreeterClassLoader</code> object.
    But these two classes, both members of the Java API, will end up being loaded by the primordial class loader anyway.
</p>

<p>
    Remember that before the <code>loadClass()</code> method of <code>GreeterClassLoader</code> attempts to look for a requested type in the base directory (in this case, directory <code>greeters</code> ),
    it invokes <code>findSystemClass()</code>.
    Because <code>findSystemClass()</code>, which uses the primordial class loader to try and load the requested type,
    is able to load both <code>java.lang.System</code> and <code>java.io.PrintStream</code>,
    the <code>loadClass()</code> method will simply return the <code>Class</code> instance returned by <code>findSystemClass()</code>.
    These classes will be marked not as having been loaded by the <code>GreeterClassLoader</code> object, but as having been loaded by the primordial class loader.
    To resolve any references from <code>java.lang.System</code> or <code>java.io.PrintStream</code>,
    the virtual machine will not invoke the <code>loadClass()</code> method of the <code>GreeterClassLoader</code> object.
    It will just use the primordial class loader directly.
</p>
<p>
    As a result, after <code>Surprise</code>'s <code>greet()</code> method has returned,
    there will be two types marked as having been loaded by the <code>GreeterClassLoader</code> object:
    class <code>Surprise</code> and class <code>HowDoYouDo</code>.
    These two types will be in the virtual machine's internal list of the types loaded by the <code>GreeterClassLoader</code> object and
    will appear in the <code>Hashtable</code> pointed to by the <code>GreeterClassLoader</code> object's <code>types</code> instance variable.
</p>
<p>
    Just after <code>Surprise</code>'s <code>greet()</code> method returns,
    the <code>Class</code> instances for <code>Surprise</code> and <code>HowDoYouDo</code> are reachable by the application.
    The garbage collector will not reclaim the space occupied by these <code>Class</code> instances,
    because there are ways for the application's code to access and use them.
    See Figure 8-11 for a graphical depiction of the reachability of these two <code>Class</code> instances.
</p>
<p><img src="images/fig8-11.gif" alt= "figure 8-11"></p>
<p>
    The <code>Class</code> instance for <code>Surprise</code> can be reached in three ways.
    First, it can be reached directly from local variable <code>c</code> of <code>GreetAndForget</code>'s <code>main()</code> method.
    Second, it can be reached from local variables <code>o</code> and <code>greeter</code>, which both point to the same <code>Surprise</code> object.
    From the <code>Surprise</code> object, the virtual machine can get at <code>Surprise</code>'s type data, which includes a reference to <code>Surprise</code>'s <code>Class</code> object.
    The third way the <code>Class</code> instance for <code>Surprise</code> can be reached is through the <code>gcl</code> local variable of <code>GreetAndForget</code>'s <code>main()</code> method.
    This local variable points to the <code>GreeterClassLoader</code> object, which includes a reference to a <code>HashTable</code> object
    in which a reference to <code>Surprise</code>'s <code>Class</code> instance is stored.
</p>
<p>
    The <code>Class</code> instance for <code>HowDoYouDo</code> can be reached in two ways.
    One way is identical to the one of the paths to the <code>Class</code> instance for <code>Surprise</code>:
    the <code>gcl</code> local variable of <code>GreetAndForget</code>'s <code>main()</code> method points to the <code>GreeterClassLoader</code> object,
    which includes a reference to a <code>HashTable</code> object.
    The <code>Hashtable</code> contains a reference to <code>HowDoYouDo</code>'s <code>Class</code> instance.
    The other way to reach <code>HowDoYouDo</code>'s class instance is through <code>Surprise</code>'s constant pool.
</p>
<p>
    When the virtual machine resolved the symbolic reference from <code>Surprise</code>'s constant pool to <code>HowDoYouDo</code>,
    it replaced the symbolic reference with a direct reference.
    The direct reference points to <code>HowDoYouDo</code>'s type data,
    which includes a reference to <code>HowDoYouDo</code>'s <code>Class</code> instance.
</p>
<p>
    Thus, starting from <code>Surprise</code>'s constant pool, the <code>Class</code> instance to <code>HowDoYouDo</code> is reachable.
    But why would the garbage collector look at direct references emanating from <code>Surprise</code>'s constant pool in the first place?
    Because <code>Surprise</code>'s <code>Class</code> instance is reachable.
    When the garbage collector finds that it can reach <code>Surprise</code>'s <code>Class</code> instance,
    it makes sure it marks the <code>Class</code> instances for any types that are directly referenced from <code>Surprise</code>'s constant pool as reachable.
    If <code>Surprise</code> is still live, the virtual machine can't unload any types <code>Surprise</code> may need to use.
</p>
<p>
    Note that of the three ways, described above, that <code>Surprise</code>'s <code>Class</code> instance can be reached, none of them involve a constant pool of another type.
    <code>Surprise</code> does not appear as a symbolic reference in the constant pool for <code>GreetAndForget</code>.
    Class <code>GreetAndForget</code> did not know about <code>Surprise</code> at compile-time.
    Instead, the <code>GreetAndForget</code> application decided at run-time to load and link to class <code>Surprise</code>.
    Thus, the <code>Class</code> instance for class <code>Surprise</code> is only reachable by starting from the local variables of <code>GreetAndForget</code>'s <code>main()</code> method.
    Unfortunately for <code>Surprise</code> (and ultimately for <code>HowDoYouDo)</code>, this does not constitute a very firm grasp on life.
</p>
<p>The next four statements in <code>GreetAndForget</code>'s <code>main()</code> method, will change the reachability situation completely:</p>

<pre>begin
// Forget the class loader object, Class
// instance, and greeter object
gcl = null;
c = null;
o = null;
greeter = null;
end
</pre>

<p>
    These statements null out all four starting places from which <code>Surprise</code>'s <code>Class</code> instance is reachable.
    As a result, after these statements have been executed, the <code>Class</code> instance for <code>Surprise</code> is no longer reachable.
    These statements also render unreachable the <code>Class</code> instance for <code>HowDoYouDo</code>,
    the <code>Surprise</code> instance that was formerly pointed to by the <code>o</code> and <code>greeter</code> variables,
    the <code>GreeterClassLoader</code> instance that was formerly pointed to by the <code>gcl</code> variable,
    and the <code>Hashtable</code> instance that was pointed to by the <code>types</code> variable of the <code>GreeterClassLoader</code> object.
    All five of these objects are now available for garbage collection.
</p>
<p>
    When (and if) the garbage collector gets around to freeing the unreferenced <code>Class</code> instances for <code>Surprise</code> and <code>HowDoYouDo</code>,
    it can also free up all the associated type data in the method area for <code>Surprise</code> and <code>HowDoYouDo</code>.
    Because these class's <code>Class</code> instances are unreachable, the types themselves are unreachable and can be unloaded by the virtual machine.
</p>
<p>
    Note that two iterations of the for loop later (given the command line shown above), the <code>GreetAndForget</code> application will again load class <code>Surprise</code>.
    Keep in mind that the virtual machine will not reuse the type data for <code>Surprise</code> that was loaded during the first pass of the for loop.
    Granted, that type data became available for unloading at the end of the first pass.
    But even if the <code>Class</code> instance for <code>Surprise</code> hadn't become unreferenced at the end of the first pass,
    the type data from the first pass wouldn't be reused during the third pass.
</p>
<p>
    With each pass of the for loop, the <code>main()</code> method of <code>GreetAndForget</code> creates a new <code>GreeterClassLoader</code> object.
    Thus, every greeter that <code>GreetAndForget</code> loads is loaded through a different class loader object.
    For example, if you invoke the <code>GreetAndForget</code> application with the <code>Hello</code> greeter listed five times on the command line,
    the application will create five instances of class <code>GreeterClassLoader</code>.
    The <code>Hello</code> greeter will be loaded five times by five different class loader objects.
    The method area will contain five different copies of the type data for <code>Hello</code>.
    The heap will contain five <code>Class</code> instances that represent the <code>Hello</code> class--one for each name space into which <code>Hello</code> is loaded.
    When one of the <code>Class</code> instances for <code>Hello</code> becomes unreferenced,
    only the <code>Hello</code> type data associated with that particular <code>Class</code> instance would be available for unloading.
</p>



<h2 id="on_the_cd">On the CD-ROM</h2>
<p>The CD-ROM contains the source code examples from this chapter in the <code>linking</code> directory.</p>



<h2 id="resources_page">The Resources Page</h2>
<p>For more information about the material presented in this chapter, visit the resources page: <code>https://www.artima.com/insidejvm/ed2/linking.html</code>.</p>

</div>

</div>
<br/>
<div class="u-cf"></div>

<div class="row">
    <div class="one-third column value">
        <a class="button button-primary mod" href="07.html">Previous page</a>
    </div>
    <div class="one-third column value" style="text-align:center;">
        <a class="button button-primary mod" href="index.html">Table of content</a>
    </div>
    <div class="one-third column value">
        <a class="button button-primary mod u-pull-right" href="09.html">Next page</a>
    </div>
</div>
<hr/>
</div>
</div>
</div>

</body>
</html>


