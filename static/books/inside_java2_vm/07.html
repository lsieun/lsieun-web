<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>07 The Lifetime of a Class | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
<div class="row">
<div class="twelve columns">

<div class="row test">
    <h1>07 The Lifetime of a Class</h1>
</div>
<div class="u-cf"></div>

<div class="row">
    <div class="one-third column value">
        <a class="button button-primary mod" href="06.html">Previous page</a>
    </div>
    <div class="one-third column value" style="text-align:center;">
        <a class="button button-primary mod" href="index.html">Table of content</a>
    </div>
    <div class="one-third column value">
        <a class="button button-primary mod u-pull-right" href="08.html">Next page</a>
    </div>
</div>

<div class="content index ">
<div class="u-cf"></div>

<div class="waka">
<hr/>
<ul>
    <li>
        <a href="#class_loading_linking_and_initialization">Class Loading, Linking, and Initialization</a>
        <ul>
            <li><a href="#loading">Loading</a></li>
            <li><a href="#verification">Verification</a></li>
            <li><a href="#preparation">Preparation</a></li>
            <li><a href="#resolution">Resolution</a></li>
            <li>
                <a href="#initialization">Initialization</a>
                <ul>
                    <li><a href="#class_initialization_method">The Class Initialization Method</a></li>
                    <li><a href="#active_versus_passive_use">Active versus Passive Use</a></li>
                </ul>
            </li>
        </ul>
    </li>
    <li>
        <a href="#lifetime_of_an_object">The Lifetime of an Object</a>
        <ul>
            <li><a href="#class_initialization">Class Instantiation</a></li>
            <li><a href="#garbage_collection_and_finalization">Garbage Collection and Finalization of Objects</a></li>
        </ul>
    </li>
    <li><a href="#unloading_and_finalization">Unloading and Finalization of Classes</a></li>
    <li><a href="#on_the_cd">On the CD-ROM</a></li>
    <li><a href="#resources_page">The Resources Page</a></li>
</ul>
<hr>
<p>
    The previous chapter described in detail the format of the Java class file, the standard binary form for representing Java types.
    This chapter looks at what happens when binary type data is imported into a Java Virtual Machine.
    The chapter follows the lifetime of a type (class or interface) from the type's initial entrance into the virtual machine to its ultimate exit.
    It discusses the processes of loading, linking, and initialization that occur at the beginning of a class's lifetime;
    the processes of object instantiation, garbage collection, and finalization that can occur in the prime of a class's lifetime;
    and the finalization and unloading of types that can occur at the end of a class's lifetime.
</p>



<h2 id="class_loading_linking_and_initialization">Class Loading, Linking, and Initialization</h2>
<p>
    The Java Virtual Machine makes types available to the running program through a process of <em>loading</em>, <em>linking</em>, and <em>initialization</em>.
    Loading is the process of bringing a binary form for a type into the Java Virtual Machine.
    Linking is the process of incorporating the binary type data into the runtime state of the virtual machine.
    Linking is divided into three sub-steps: <em>verification</em>, <em>preparation</em>, and <em>resolution</em>.
    Verification ensures the type is properly formed and fit for use by the Java Virtual Machine.
    Preparation involves allocating memory needed by the type, such as memory for any class variables.
    Resolution is the process of transforming symbolic references in the constant pool into direct references.
    Implementations may delay the resolution step until each symbolic reference is actually used by the running program.
    After verification, preparation, and (optionally) resolution are completed, the type is ready for initialization.
    During initialization, the class variables are given their proper initial values.
    See Figure 7-1 for a graphical depiction of this process.
</p>
<p><img src="images/fig7-1.gif" alt="figure 7-1"></p>
<p>
    As you can see from Figure 7-1, the processes of (1) loading, (2) linking, and (3) initialization must take place in that order.
    The only exception to this required ordering is the third phase of linking, resolution, which may optionally take place after initialization.
</p>
<p>
    The Java Virtual Machine specification gives implementations flexibility in the timing of class and interface loading and linking, but strictly defines the timing of initialization.
    All implementations must initialize each class and interface on its first <em>active use</em>.
</p>
<p>An active use of a class is:</p>
<ul>
    <li>The invocation of a constructor on a new instance of the class</li>
    <li>The creation of an array that has the class as its an element type</li>
    <li>The invocation of a method declared by the class (not inherited from a superclass)</li>
    <li>The use or assignment of a field declared by the class (not inherited from a superclass or superinterface), except for fields that are both <code>static</code> and <code>final</code>, and are initialized by a compile-time constant expression</li>
</ul>
<p>An active use of an interface is:</p>
<ul>
    <li>The use or assignment of a field declared by the interface (not inherited from a superinterface), except for fields that are initialized by a compile-time constant expression </li>
</ul>
<p>All other uses of a type besides the five listed above are <em>passive uses</em> of the type. Several examples illustrating the difference between active and passive uses are given later in this chapter.</p>
<p>Aside from its own initial active use, there is one other situation that will cause the initialization of a class: the initial active use of one of its subclasses. Initialization of a class requires prior initialization of all its superclasses.</p>
<p>The same is not true of interfaces, however. An interface is initialized only because a non-constant field declared by the interface is used, never because a subinterface or class that implements the interface needs to be initialized. Thus, initialization of a class requires prior initialization of all its superclasses, but not its superinterfaces. Initialization of an interface does not require initialization of its superinterfaces.</p>
<p>The "initialize on first active use" rule drives the mechanism that loads, links, and initializes classes. On its first active use, a type must be initialized. Before it can be initialized, however, it must be linked. And before it can be linked, it must be loaded. At their option, implementations may load and link types early. They need not wait until the type's first active use to load and link the type. If a type hasn't been loaded and linked before its first active use, however, it must be loaded and linked at that time, so that it can be initialized.</p>



<h3 id="loading">Loading</h3>
                    <p>The loading process consists of three basic activities. To load a type, the Java Virtual Machine must:</p>
                    <ul>
                        <li>produce a stream of binary data that represents the type </li>
                        <li>parse the stream of binary data into internal data structures in the method area </li>
                        <li>create an instance of class <code>java.lang.Class</code> that represents the type </li>
                    </ul>
                    <p>The stream of binary data may adhere to the Java class file format, but could alternatively follow some other format. As mentioned in previous chapters, all Java Virtual Machine implementations must recognize the Java class file format, but individual implementations may also recognize other binary formats.</p>
                    <p>The Java Virtual Machine specification does not say how the binary data for a type must be produced. Some potential ways to produce binary data for a type are:</p>
                    <ul>
                        <li>load a Java class file from the local file system </li>
                        <li>download a Java class file across a network </li>
                        <li>extract a Java class file from a ZIP, JAR, CAB, or other archive file </li>
                        <li>extract a Java class file from a proprietary database </li>
                        <li>compile a Java source file on the fly into the class file format </li>
                        <li>compute the class file data for a type on the fly </li>
                        <li>any of the above, but using a binary file format other than the Java class file </li>
                    </ul>
                    <p>Given the binary data for a type, the Java Virtual Machine must process that data to a great enough extent that it can create an instance of class <code>java.lang.Class</code>. The virtual machine must parse the binary data into implementation-dependent internal data structures. (See Chapter 5, "The Java Virtual Machine," for a discussion of potential internal data structures for storing class data.) The <code>Class</code> instance, the end product of the loading step, serves as an interface between the program and the internal data structures. To access information about a type that is stored in the internal data structures, the program invokes methods on the <code>Class</code> instance for that type.</p>
                    <p>As described in previous chapters, types are loaded either through the primordial class loader or through class loader objects. The primordial class loader, a part of the virtual machine implementation, loads types (including the classes and interfaces of the Java API) in an implementation-dependent way. Class loader objects, instances of subclasses of <code>java.lang.ClassLoader</code>, load classes in custom ways. The inner workings of class loader objects are described in more detail later in Chapter 8, "The Linking Model."</p>
                    <p>Class loaders (primordial or object) need not wait until a type's first active use before they load the type. Class loaders are allowed to cache binary representations of types, load types early in anticipation of eventual use, or load types together in related groups. If a class loader encounters a problem during early loading, however, it must report that problem (by throwing a subclass of <code>LinkageError</code> ) only upon the type's first active use. In other words, if a class loader encounters a missing or malformed class file during early loading, it must wait to report that error until the class's first active use by the program. If the class is never actively used by the program, the class loader will never report the error.</p>



<h3 id="verification">Verification</h3>
                    <p>After a type is loaded, it is ready to be linked. The first step of the linking process is verification--ensuring that the type obeys the semantics of the Java language and that it won't violate the integrity of the virtual machine.</p>
                    <p>Verification is another area in which implementations of the Java Virtual Machine have some flexibility. Implementation designers can decide how and when to verify types. The Java Virtual Machine specification lists all the exceptions that a virtual machine can throw and under what circumstances it must throw them. No matter what kind of trouble a Java Virtual Machine might encounter, there is an exception or error it is supposed to throw. The specification says what exception or error should be thrown in each situation. In some cases, the specification says exactly when the exception or error should be thrown, but usually doesn't dictate precisely how or when the error condition should be detected.</p>
                    <p>Nevertheless, certain kinds of checks are very likely to take place at certain times in most Java Virtual Machine implementations. For example, during the loading process, the virtual machine must parse the stream of binary data that represents the type and build internal data structures. At this point, certain checks will have to be done just to ensure the initial act of parsing the binary data won't crash the virtual machine. During this parsing, implementations will likely check the binary data to make sure it has the expected overall format. Parsers of the Java class file format might check the magic number, make sure each component is in the right place and of the proper length, verify that the file isn't too short or too long, and so on. Although these checks take place during loading, before the official verification phase of linking, they are still logically part of the verification phase. The entire process of detecting any kind of problem with loaded types is placed under the category of verification.</p>
                    <p>Another check that likely occurs during loading is making sure that every class except <code>Object</code> has a superclass. This may be done during loading because when the virtual machine loads a class, it must also make sure all of the class's superclasses are loaded also. The only way a virtual machine can know the name of a given class's superclass is by peering into the binary data for the class. Since the virtual machine is looking at every class's superclass data during loading anyway, it may as well make this check during the loading phase.</p>
                    <p>Another check--one that likely occurs after the official verification phase in most implementations--is the verification of symbolic references. As described in earlier chapters, the process of dynamic linking involves locating classes, interfaces, fields, and methods referred to by symbolic references stored in the constant pool, and replacing the symbolic references with direct references. When the virtual machine searches for a symbolically referenced entity (type, field, or method), it must first make sure the entity exists. If the virtual machine finds that the entity exists, it must further check that the referencing type has permission to access the entity, given the entity's access permissions. These checks for existence and access permission are logically a part of verification, the first phase of linking, but most likely happen during resolution, the third phase of linking. Resolution itself can be delayed until each symbolic reference is first used by the program, so these checks may even take place after initialization.</p>
                    <p>So what gets checked during the official verification phase? Anything that hasn't already been checked before the official verification phase and that won't get checked after it. Here two lists of some of the things that are good candidates for checking during the official verification phase. This first list is composed of checks that ensure classes are binary compatible with each other:</p>
                    <ul>
                        <li>checking that final classes are not subclassed </li>
                        <li>checking that final methods are not overridden </li>
                        <li>if the type being checked is a non-abstract class, checking that all the methods declared in any interfaces implemented by the class are indeed implemented by the class </li>
                        <li>making sure no incompatible method declarations (such as two methods that have the same name, the same number, order, and types of parameters, but different return types) appear between the type and its supertypes </li>
                    </ul>
                    <p>Note that while these checks require looking at other types, they only require looking at supertypes. Superclasses need to be initialized before subclasses, so these classes are likely already loaded. Superinterfaces do not need to be initialized when a class that implements them is initialized. However, this verification step will require their loading. (They won't be initialized, just loaded and possibly linked at the option of the virtual machine implementation.) All a class's supertypes will have to be loaded to make sure they are all still binary compatible.</p>
                    <ul>
                        <li>checking that all constant pool entries are consistent with each other. (For example, the <code>string_index</code> item of a <code>CONSTANT_String_info</code> entry must be the index of a <code>CONSTANT_Utf8_info</code> entry.) </li>
                        <li>checking that all special strings contained in the constant pool (class names, field and method names, field and method descriptors) are well-formed </li>
                        <li>verifying the integrity of the bytecodes </li>
                    </ul>
                    <p>The most complicated task in the above list is the last one: bytecode verification. All Java Virtual Machines must in some way verify the integrity of the bytecodes for every method they execute. For example, implementations are not allowed to crash because a jump instruction sends the virtual machine beyond the end of a method. They must detect that the jump instruction is invalid through some process of bytecode verification, and throw an error.</p>
                    <p>Java Virtual Machine implementations are not required to verify bytecodes during the official verification phase of linking. Implementations are free, for example, to verify individual instructions as each instruction is executed. One of the design goals of the Java Virtual Machine instruction set, however, was that it yield bytecodes streams that can be verified all at once by a data flow analyzer. The ability to verify bytecode streams all at once during linking, rather than on the fly as the program runs, gives a big boost to the potential execution speed of Java programs.</p>
                    <p>When verifying bytecodes via a data flow analyzer, the virtual machine may have to load other classes to ensure that the semantics of the Java language are being followed. For example, imagine a class contained a method that assigned a reference to an instance of <code>java.lang.Float</code> to a field of type <code>java.lang.Number</code>. In this case, the virtual machine would have to load class <code>Float</code> during bytecode verification to make sure it was a subclass of class <code>Number</code>. It would have to load <code>Number</code> to make sure it wasn't declared final. The virtual machine must not initialize class <code>Float</code> at this time, just load it. <code>Float</code> will be initialized only upon its first active use.</p>
                    <p>For more information on the class verification process, see Chapter 3, "Security."</p>



<h3 id="preparation">Preparation</h3>
                    <p>After a Java Virtual Machine has loaded a class and performed whatever verification it chooses to do up front, the class is ready for preparation. During the preparation phase, the Java Virtual Machine allocates memory for the class variables and sets them to default initial values. The class variables are not initialized to their proper initial values until the initialization phase. (No Java code is executed during the preparation step.) During preparation, the Java Virtual Machine sets the newly allocated memory for the class variables to a default value determined by the type of the variable. The default values for the various types are shown in Table 7-1.</p>
                    <p>Table 7-1. Default initial values for the primitive and reference types</p>
                    <table>
                        <tbody>
                        <tr>
                            <td><code>int</code></td>
                            <td><code>0</code></td>
                     </tr>
                        <tr>
                            <td><code>long</code></td>
                            <td><code>0L</code></td>
                     </tr>
                        <tr>
                            <td><code>short</code></td>
                            <td><code>(short) 0</code></td>
                     </tr>
                        <tr>
                            <td><code>char</code></td>
                            <td><code>'\u0000'</code></td>
                     </tr>
                        <tr>
                            <td><code>byte</code></td>
                            <td><code>(byte) 0</code></td>
                     </tr>
                        <tr>
                            <td><code>reference</code></td>
                            <td><code>null</code></td>
                     </tr>
                        <tr>
                            <td><code>float</code></td>
                            <td><code>0.0f</code></td>
                     </tr>
                        <tr>
                            <td><code>double</code></td>
                            <td><code>0.0d</code></td>
                     </tr>
                        </tbody>
                    </table>
                    <p>There is no <code>boolean</code> in Table 7-1, because <code>boolean</code> is not a primitive type in the Java Virtual Machine. Internally, <code>boolean</code> is implemented as an <code>int</code>, which gets set to zero (boolean <code>false</code> ) by default. Therefore, <code>boolean</code> class variables are in effect initialized to boolean <code>false</code>.</p>
                    <p>During the preparation phase, Java Virtual Machine implementations may also allocate memory for data structures that are intended to improve the performance of the running program. An example of such a data structure is a method table, which contains a pointer to the data for every method in a class, including those inherited from its superclasses. A method table enables an inherited method to be invoked on an object without a search of superclasses at the point of invocation. Method tables are described in more detail in Chapter 8, "The Linking Model."</p>



<h3 id="resolution">Resolution</h3>
                    <p>After a type has been through the first two phases of linking: verification and preparation, it is ready for the third and final phase of linking: resolution. Resolution is the process of locating classes, interfaces, fields, and methods referenced symbolically from a type's constant pool, and replacing those symbolic references with direct references. As mentioned above, this phase of linking is optional until (and unless) each symbolic reference is first used by the program. Constant pool resolution is described in detail in Chapter 8, "The Linking Model."</p>



<h3 id="initialization">Initialization</h3>
                    <p>The final step required to ready a class or interface for its first active use is initialization, the process of setting class variables to their proper initial values. As used here, a "proper" initial value is the programmer's desired starting value for a class variable. A proper initial value contrasts with the default initial value given to class variables during preparation. As described above, the virtual machine assigns default values based only on each variable's type. Proper initial values, by contrast, are based on some master plan known only to the programmer.</p>
                    <p>In Java code, a proper initial value is specified via a class variable initializer or static initializer. A class variable initializer is an equals sign and expression next to a class variable declaration, as in:</p>
                    <pre> <p><code>begin</code></p>  <p/> <code>// On CD-ROM in file classlife/ex1/Example1a.java <p>class Example1a {</p> <p></p> <p>// "= 3 * (int) (Math.random() * 5.0)" is the class variable</p> <p>// initializer</p> <p>static int size = 3 * (int) (Math.random() * 5.0);</p> <p>}</p></code>  <p></p></code> <code>end</code> </pre> <p>A static initializer is a block of code introduced by the <code>static</code> keyword, as in:</code></p> <pre> <p><code>begin</code></p>  <p/>  <code>// On CD-ROM in file classlife/ex1/Example1b.java <p>class Example1b {</p> <p></p> <p>static int size;</p> <p></p> <p>// This is the static initializer</p> <p>static {</p> <p></p> <p>size = 3 * (int) (Math.random() * 5.0);</p> <p>}</p> <p>}</p>   <p></p>  <code>end</code></pre>
                    <p>All the class variable initializers and static initializers of a class are collected by the Java compiler and placed into one special method, the <em>class initialization method</em>. In the Java class file, the class initialization method is named " <code>&lt;clinit&gt;</code> ". Regular methods of a Java application cannot invoke a class initialization method. This kind of method can only be invoked by the Java Virtual Machine, which invokes it to set a class's static variables to their proper initial values.</p>
                    <p>Initialization of a class consists of two steps:</p>
                    <ol>
                        <li>Initializing the class's direct superclass (if any), if the direct superclass hasn't already been initialized   </li>
                        <li>Executing the class's class initialization method, if it has one   </li>
                    </ol>
                    <p>When initializing a class's direct superclass, the same two steps listed above must be followed. As a result, the first class that will be initialized will always be <code>Object</code>, then all the classes on down the inheritance hierarchy to the class being actively used. Superclasses will be initialized before subclasses.</p>
                    <p>Initialization of an interface does not require initialization of its superinterfaces. Initialization of an interface consists of only one step:</p>
                    <ul>
                        <li>Executing the interface's class initialization method, if it has one   </li>
                    </ul>
                    <p>The code of a <code>&lt;clinit&gt;</code> () method does not explicitly invoke a superclass's <code>&lt;clinit&gt;</code> () method. Before a Java Virtual Machine invokes the <code>&lt;clinit&gt;</code> () method of a class, therefore, it must make certain the <code>&lt;clinit&gt;</code> () methods of superclasses have been executed.</p>
                    <p>Java Virtual Machines must also make sure the initialization process is properly synchronized. If multiple threads need to initialize a class, only one thread should be allowed to perform the initialization while the other threads wait. After the active thread completes the initialization process, it must notify any waiting threads. See Chapter 20, "Thread Synchronization," for information about synchronization, wait and notify.</p>



<h4 id="class_initialization_method">The Class Initialization Method</h4>
                    <p>As mentioned above, Java compilers place the code for class variable initializers and static initializers into the <code>&lt;clinit&gt;</code> () method of the class file in the order in which they appear in the class declaration. For example, given this class:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex1/Example1c.java <p>class Example1c {</p> <p></p> <p>static int width;</p> <p>static int height = (int) (Math.random() * 2.0);</p> <p></p> <p>// This is the static initializer</p> <p>static {</p> <p></p> <p>width = 3 * (int) (Math.random() * 5.0);</p> <p>}</p> <p>}</p></code>  <p></p>  <code>end</code></pre>
                    <p>The Java compiler generates the following <code>&lt;clinit&gt;</code> () method:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// The code for height's class variable initializer begins here <p>// Invoke Math.random(), which will push</p> <p>// a double return value</p> <p>0 invokestatic #6 &lt;Method double random()</p></code> <p>3 ldc2_w #8 &lt;Double 2.0  // Push double constant 2.0</p> <p>6 dmul                    // Pop two doubles, multiply, push result</p> <p>7 d2i                     // Pop double, convert to int, push int</p> <p>// Pop int, store into class variable</p> <p>// height</p> <p>8 putstatic #5 &lt;Field int height</p> <p></p> <p>// The code for the static initializer begins here</p> <p>11 iconst_3                // Push int constant 3</p> <p>// Invoke Math.random(), which will push</p> <p>// a double return value</p> <p>12 invokestatic #6 &lt;Method double random()</p> <p>15 ldc2_w #10 &lt;Double 5.0  // Push double constant 5.0</p> <p>18 dmul                    // Pop two doubles, multiply, push result</p> <p>19 d2i                     // Pop double, convert to int, push int</p> <p>20 imul                    // Pop two ints, multiply, push int result</p> <p>// Pop int, store into class variable</p> <p>// width</p> <p>21 putstatic #7 &lt;Field int width</p> <p>24 return                  // Return void from &lt;clinit&gt; method</p>  <p></p>  <code>end</code>  </pre>
                    <p>This <code>&lt;clinit&gt;</code> () method first executes the code for <code>Example1c</code>'s only class variable initializer, which initializes <code>height</code>, then executes the code for the static initializer, which initializes <code>width</code>. The initialization is done in this order because the class variable initializer appears textually before the static initializer in the source code of the <code>Example1c</code> class.</p>
                    <p>
                        Not all classes will necessarily have a <code>&lt;clinit&gt;</code>() method in their class file.
                        If a class declares no class variables or static initializers, it won't have a <code>&lt;clinit&gt;</code>() method.
                        If a class declares class variables, but doesn't explicitly initialize them with class variable initializers or static initializers, it won't have a <code>&lt;clinit&gt;</code>() method.
                        If a class contains only class variable initializers for static final variables, and those class variable initializers use compile-time constant expressions, that class won't have a <code>&lt;clinit&gt;</code>() method.
                        Only those classes that actually require Java code to be executed to initialize class variables to proper initial values will have a class initialization method.
                    </p>
                    <p>Here's an example of a class that won't be awarded a <code>&lt;clinit&gt;</code> () method by the Java compiler:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex1/Example1d.java <p>class Example1d {</p> <p></p> <p>static final int angle = 35;</p> <p>static final int length = angle * 2;</p> <p>}</p></code>  <p></p>  <code>end</code></pre>
                    <p>Class <code>Example1d</code> declares two constants, <code>angle</code> and <code>length</code>, and initializes them with expressions that are compile-time constants. The compiler knows that <code>angle</code> represents the value 35 and <code>length</code> represents the value 70. When the <code>Example1d</code> class is loaded by a Java Virtual Machine, <code>angle</code> and <code>length</code> are not stored as class variables in the method area. As a result, no <code>&lt;clinit&gt;</code> () method is needed to initialize them. The <code>angle</code> and <code>length</code> fields are not class variables, they are constants, which are treated specially by the Java compiler.</p>
                    <p>Instead of treating <code>Example1d</code>'s <code>angle</code> and <code>length</code> fields as class variables, the Java compiler places the constant <code>int</code> values they represent into the constant pool or bytecode streams of any class that uses them. For example, if a class uses <code>Example1d</code>'s <code>angle</code> field, that class will not have in its constant pool a symbolic reference to the <code>angle</code> field of class <code>Example1d</code>. Instead, the class will have operands embedded in its bytecode streams that have the value 35. If the constant value of <code>angle</code> were outside the range of a <code>short</code> (-32,768 to 32,767), say 35,000, the class would have a <code>CONSTANT_Integer_info</code> entry in its constant pool with the value of 35,000.</p>
                    <p>Here's a class that uses both a constant and a class variable from other classes:</p>
                    <pre> <p><code>begin</code></p>  <p/> // On CD-ROM in file classlife/ex1/Example1e.java <p>class Example1e {</p> <p></p> <p>// The class variable initializer for symbolicRef uses a symbolic</p> <p>// reference to the size class variable of class Example1a</p> <p>static int symbolicRef = Example1a.size;</p> <p></p> <p>// The class variable initializer for localConst doesn't use a</p> <p>// symbolic reference to the length field of class Example1d.</p> <p>// Instead, it just uses a copy of the constant value 70.</p> <p>static int localConst = Example1d.length * (int) (Math.random()</p> <p>* 3.0);</p> <p>}</p></code>  <p></p>  <code>end</code></pre>
                    <p>The Java compiler generates the following <code>&lt;clinit&gt;</code> () method for class Example1e:</p>
                    <pre> <p><code>begin</code></p>  <p/> // The code for symbolicRef's class variable initializer begins here: <p>// Push int value from Example1a.size.</p> <p>// This getstatic instruction refers to a</p> <p>// symbolic reference to Example1a.size.</p> <p>0 getstatic #9 &lt;Field int size</p></code> <p>// Pop int, store into class variable</p> <p>// symbolicRef</p> <p>3 putstatic #10 &lt;Field int symbolicRef</p> <p></p> <p>// The code for localConst's class variable intializer begins here:</p> <p>// Expand byte operand to int, push int</p> <p>// result. This is the local copy of</p> <p>6 bipush 70               // Example1d's length constant, 70.</p> <p>// Invoke Math.random(), which will push</p> <p>// a double return value</p> <p>8 invokestatic #8 &lt;Method double random()</p> <p>11 ldc2_w #11 &lt;Double 3.0 // Push double constant 3.0</p> <p>14 dmul                    // Pop two doubles, multiply, push result</p> <p>15 d2i                     // Pop double, convert to int, push int</p> <p>16 imul                    // Pop two ints, multiply, push int result</p> <p>// Pop int, store into class variable</p> <p>// localConst</p> <p>17 putstatic #7 &lt;Field int localConst</p> <p>20 return                  // Return void from &lt;clinit&gt; method</p>  <p></p>  <code>end</code></pre>
                    <p>The <code>getstatic</code> instruction at offset zero uses a symbolic reference (in constant pool entry nine) to the <code>size</code> field of class <code>Example1a</code>. The <code>bipush</code> instruction at offset six is followed by a byte that contains the constant value represented by <code>Example1d.length</code>. <code>Example1e</code>'s constant pool contains no symbolic reference to anything in class <code>Example1d</code>.</p>
                    <p>Interfaces may also be awarded a <code>&lt;clinit&gt;</code> () method in the class file. All fields declared in an interface are implicitly public, static, and final and must be initialized with a field initializer. If an interface has any field initializers that don't resolve at compile-time to a constant, that interface will have a <code>&lt;clinit&gt;</code> () method. Here's an example:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex1/Example1f.java <p>interface Example1f {</p> <p></p> <p>int ketchup = 5;</p> <p>int mustard = (int) (Math.random() * 5.0);</p> <p>}</p></code>  <p></p></code> <code>end</code> </pre> <p>The Java compiler generates the following <code>&lt;clinit&gt;</code> () method for interface <code>Example1f</code> :</code></p> <pre> <p><code>begin</code></p>  <p/>  <code>// The code for mustard's class variable initializer begins here <p>// Invoke Math.random(), which will push</p> <p>// a double return value</p> <p>0 invokestatic #6 &lt;Method double random()</p>  <p>3 ldc2_w #7 &lt;Double 5.0 // Push double constant 2.0</p> <p>6 dmul                   // Pop two doubles, multiply, push result</p> <p>7 d2i                    // Pop double, convert to int, push int</p> <p>// Pop int, store into class variable</p> <p>// mustard</p> <p>8 putstatic #5 &lt;Field int mustard</p> <p>11 return                 // Return void from &lt;clinit&gt; method</p>  <p></p>  <code>end</code> </code></pre>
                             Note that only the <code>mustard</code> field is initialized by this <code>&lt;clinit&gt;</code> () method. Because the <code>ketchup</code> field is initialized to a compile-time constant, it is treated specially by the compiler. Although types that use <code>Example1f.mustard</code> will contain a symbolic reference to the field, types that use <code>Example1f.ketchup</code> will contain a local copy of <code>ketchup</code>'s constant value, 5.</p>



<h4 id="active_versus_passive_use">Active versus Passive Use</h4>
                    <p>As mentioned above, the Java Virtual Machine initializes types on their first active use or, in the case of classes, upon the first active use of a subclass. Only four activities constitute an active use: invoking an instance initialization method on a new instance of a class, creating an array whose element type is the class, invoking a method declared in a class, and accessing a non-constant field declared in a class or interface.</p>
                    <p>A use of a non-constant field is an active use of only the class or interface that actually declares the field. For example, a field declared in a class may be referred to via a subclass. A field declared in an interface may be referred to via a subinterface or class that implements the interface. These are passive uses of the subclass, subinterface, or class that implements the interface--uses that won't trigger their initialization. They are an active use only of the class or interface in which the field is actually declared. Here's an example that illustrates this principle:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex2/NewParent.java <p>class NewParent {</p> <p></p> <p>static int hoursOfSleep = (int) (Math.random() * 3.0);</p> <p></p> <p>static {</p> <p>System.out.println("NewParent was initialized.");</p> <p>}</p> <p>}</p></code>  <p></p> <p/></code> <code>// On CD-ROM in file classlife/ex2/NewbornBaby.java <p>class NewbornBaby extends NewParent {</p> <p></p> <p>static int hoursOfCrying = 6 + (int) (Math.random() * 2.0);</p> <p></p> <p>static {</p> <p>System.out.println("NewbornBaby was initialized.");</p> <p>}</p> <p>}</p></code>  <p></p> <p/>  <code>// On CD-ROM in file classlife/ex2/Example2.java <p>class Example2 {</p> <p></p> <p>// Invoking main() is an active use of Example2</p> <p>public static void main(String[] args) {</p> <p></p> <p>// Using hoursOfSleep is an active use of NewParent, but a</p> <p>// passive use of NewbornBaby</p> <p>int hours = NewbornBaby.hoursOfSleep;</p> <p>System.out.println(hours);</p> <p>}</p> <p></p> <p>static {</p> <p>System.out.println("Example2 was initialized.");</p> <p>}</p> <p>}</p>   <p></p>  <code>end</code></code> </pre>
                    <p>In the above example, executing <code>main()</code> of <code>Example2</code> causes only <code>Example2</code> and <code>Parent</code> to be initialized. <code>NewbornBaby</code> is not initialized and need not be loaded. The following text is printed to the standard output:</p>
                    <pre> <p><code>begin</code></p> <code><p>Example2 was initialized.</p> <p>NewParent was initialized.</p> <p>2</p></code> <p><code>end</code></p> </pre>
                    <p>A use of a field that is both <code>static</code> and <code>final</code>, and initialized by a compile-time constant expression, is not an active use of the type that declares the field. As mentioned above, the Java compiler resolves references to such fields to a local copy of the constant value that resides either in the referring class's constant pool, in its bytecode streams, or both. Here's an example that illustrates this special treatment of static final fields:</p>
                    <pre> <p><code>begin</code></p>  <p/> <code>// On CD-ROM in file classlife/ex3/Angry.java <p>interface Angry {</p> <p></p> <p>String greeting = "Grrrr!";</p> <p></p> <p>int angerLevel = Dog.getAngerLevel();</p> <p>}</p></code>  <p></p> <p/></code> <code>// On CD-ROM in file classlife/ex3/Dog.java <p>class Dog {</p> <p></p> <p>static final String greeting = "Woof, woof, world!";</p> <p></p> <p>static {</p> <p>System.out.println("Dog was initialized.");</p> <p>}</p> <p></p> <p>static int getAngerLevel() {</p> <p></p> <p>System.out.println("Angry was initialized");</p> <p>return 1;</p> <p>}</p> <p>}</p></code>  <p></p> <p/>  <code>// On CD-ROM in file classlife/ex3/Example3.java <p>class Example3 {</p> <p></p> <p>// Invoking main() is an active use of Example3</p> <p>public static void main(String[] args) {</p> <p></p> <p>// Using Angry.greeting is a passive use of Angry</p> <p>System.out.println(Angry.greeting);</p> <p></p> <p>// Using Dog.greeting is a passive use of Dog</p> <p>System.out.println(Dog.greeting);</p> <p>}</p> <p></p> <p>static {</p> <p>System.out.println("Example3 was initialized.");</p> <p>}</p> <p>}</p>   <p></p>  <code>end</code></code> </pre>
                    <p>Running the <code>Example3</code> application yields the following output:</p>
                    <pre> <p><code>begin</code></p> <code><p>Example3 was initialized.</p> <p>Grrrr!</p> <p>Woof, woof, world!</p></code> <p><code>end</code></p> </pre>
                    <p>Had <code>Angry</code> been initialized, the string <code>"Angry was initialized."</code> would have been written to the standard output. Likewise, had <code>Dog</code> been initialized, the string <code>"Dog was initialized."</code> would have been written to the standard output. As you can see from the above output, neither interface <code>Angry</code> or class <code>Dog</code> were ever initialized during the execution of the <code>Example3</code> application.</p>
                    <p>For more information about this special treatment of static final variables, see Chapter 8, "The Linking Model."</p>




<h2 id="lifetime_of_an_object">The Lifetime of an Object</h2>
<p>Once a class has been loaded, linked, and initialized, it is ready for use. The program can access its static fields, invoke its static methods, or create instances of it. This section describes class instantiation and initialization, activities that take place at the beginning of an object's lifetime, and garbage collection and finalization, activities that mark the end of an object's lifetime.</p>



<h3 id="class_initialization">Class Instantiation</h3>
                    <p>In Java programs, classes can be instantiated explicitly or implicitly. The three ways a class can be instantiated explicitly are with the <code>new</code> operator, by invoking <code>newInstance()</code> on a <code>Class</code> object, or by invoking <code>clone()</code> on any existing object. Here is an example showing each way to create a new class instance:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex4/Example4.java <p>class Example4 implements Cloneable {</p> <p></p> <p>Example4() {</p> <p>System.out.println("Created by invoking newInstance()");</p> <p>}</p> <p></p> <p>Example4(String msg) {</p> <p>System.out.println(msg);</p> <p>}</p> <p></p> <p>public static void main(String[] args)</p> <p>throws ClassNotFoundException, InstantiationException,</p> <p>IllegalAccessException, CloneNotSupportedException {</p> <p></p> <p>// Create a new Example4 object with the new operator</p> <p>Example4 obj1 = new Example4("Created with new.");</p> <p></p> <p>// Get a reference to the Class instance for Example4, then</p> <p>// invoke newInstance() on it to create a new Example4 object</p> <p>Class myClass = Class.forName("Example4");</p> <p>Example4 obj2 = (Example4) myClass.newInstance();</p> <p></p> <p>// Make an identical copy of the the second Example4 object</p> <p>Example4 obj3 = (Example4) obj2.clone();</p> <p>}</p> <p>}</p></code>  <p></p></code> <code>end</code> </pre> <p>When executed, the <code>Example4</code> application prints this output:</code></p>
                    <pre> <p><code>begin</code></p>  <p/>  <code>Created with new.</code> <p>Created by invoking newInstance()</p>   <p></p>  <code>end</code> </pre>
                    <p>Besides the three ways listed above to explicitly instantiate objects in Java source code, there are several situations in which objects will be instantiated implicitly--without an explicit <code>new</code>, <code>newInstance()</code>, or <code>clone()</code> appearing in the source.</p>
                    <p>Possibly the first implicitly instantiated objects of any Java application are the <code>String</code> objects that hold the command line arguments. References to these objects, one for each command-line argument, are delivered in the <code>String</code> array passed as the sole parameter to the <code>main()</code> method of every application.</p>
                    <p>Two other ways a class can be instantiated implicitly involve the process of class loading. First, for every type a Java Virtual Machine loads, it implicitly instantiates a new <code>Class</code> object to represent that type. Second, when the Java Virtual Machine loads a class that contains <code>CONSTANT_String_info</code> entries in its constant pool, it may instantiate new <code>String</code> objects to represent those constant string literals. The process of transforming a <code>CONSTANT_String_info</code> entry in the method area to a <code>String</code> instance on the heap is part of the process of constant pool resolution. This process is described in detail in Chapter 8, "The Linking Model."</p>
                    <p>Another way objects can be created implicitly is through the process of evaluating an expression that involves the string concatenation operator. If such an expression is not a compile-time constant, intermediate <code>String</code> and <code>StringBuffer</code> objects will be created in the process of evaluating the expression. Here's an example:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex5/Example5.java <p>class Example5 {</p> <p></p> <p>public static void main(String[] args) {</p> <p></p> <p>if (args.length &lt; 2) {</p> <p>System.out.println("Must enter any two args.");</p> <p>return;</p> <p>}</p> <p></p> <p>System.out.println(args[0] + args[1]);</p> <p>}</p> <p>}</p></code>  <p></p>  <code>end</code> </pre>
                    <p><code>javac</code> generates these bytecodes for <code>Example5</code>'s <code>main()</code> method:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>0 aload_0      // Push the objref from loc var 0 (args) <p>1 arraylength  // Pop arrayref, calc array length, push int length</p> <p>2 iconst_2     // Push int constant 2</p> <p>// Pop 2 ints, compare, branch if (length</p></code> 2) to <p>3 if_icmpge 15 // offset 15.</p> <p>// Push objref from System.out</p> <p>6 getstatic #11 &lt;Field java.io.PrintStream out</p> <p>// Push objref of string literal</p> <p>9 ldc #1 &lt;String "Must enter any two args."</p> <p>// Pop objref to String param, objref to System.out,</p> <p>// invoke println()</p> <p>11 invokevirtual #12 &lt;Method void println(java.lang.String)</p> <p>14 return       // Return void from main()</p> <p>// Push objref from System.out</p> <p>15 getstatic #11 &lt;Field java.io.PrintStream out</p> <p></p> <p>// The string concatenation operation begins here</p> <p>// Allocate mem for new StringBuffer object, and</p> <p>// initialize mem to default initial values, push</p> <p>// objref to new object</p> <p>18 new #6 &lt;Class java.lang.StringBuffer</p> <p>21 dup          // Duplicate objref to StringBuffer object</p> <p>22 aload_0      // Push ref from loc var 0 (args)</p> <p>23 iconst_0     // Push int constant 0</p> <p>// Pop int, arrayref, push String at arrayref[int],</p> <p>24 aaload       // which is args[0]</p> <p>// Pop objref, invoke String's class method</p> <p>// valueOf(), passing it the objref to the args[0]</p> <p>// String object. valueOf() calls toString() on the</p> <p>// ref, and returns (and pushes) the result, which</p> <p>// happens to be the original args[0] String. In this</p> <p>// case, the stack will look precisely the same</p> <p>// before and after this instruction is executed.</p> <p>// Thus here, the 1.1 javac compiler has</p> <p>// over-enthusiastically generated an unnecessary</p> <p>// instruction.</p> <p>25 invokestatic #14 &lt;Method java.lang.String valueOf(</p> <p>java.lang.Object)</p> <p>// Pop objref to args[0] String, objref of the</p> <p>// StringBuffer object, invoke &lt;init&gt;() method on the</p> <p>// StringBuffer object passing the args[0] objref as</p> <p>// the only parameter.</p> <p>28 invokespecial #9 &lt;Method java.lang.StringBuffer(java.lang.String)</p> <p>31 aload_0      // Push objref from loc var 0 (args)</p> <p>32 iconst_1     // Push int constant 1</p> <p>// Pop int, arrayref, push String at arrayref[int],</p> <p>33 aaload       // which is args[1]</p> <p>// Pop objref to args[1] String, objref of the</p> <p>// StringBuffer object (there's still another objref</p> <p>// to this same object on the stack because of the</p> <p>// dup instruction above), invoke append() method on</p> <p>// StringBuffer object, passing args[1] as the only</p> <p>// parameter. append() will return an objref to this</p> <p>// StringBuffer object, which will be pushed back</p> <p>// onto the stack.</p> <p>34 invokevirtual #10 &lt;Method java.lang.StringBuffer append(java.lang.String)</p> <p>// Pop objref to StringBuffer (pushed by append()),</p> <p>// invoke toString() on it, which returns the value</p> <p>// of the StringBuffer as a String object. Push</p> <p>// objref of String object.</p> <p>37 invokevirtual #13 &lt;Method java.lang.String toString()</p> <p>// The string concatenation operation is now complete</p> <p></p> <p>// Pop objref of concatenated String, objref of</p> <p>// System.out that was pushed by the getstatic</p> <p>// instruction at offset 15. Invoke println() on</p> <p>// System.out, passing the concatenated String as</p> <p>// the only parameter.</p> <p>40 invokevirtual #12 &lt;Method void println(java.lang.String)</p> <p>43 return       // Return void from main()</p>  <p></p>  <code>end</code>  </pre>
                    <p>The bytecodes for <code>Example5</code>'s <code>main()</code> method contain three implicitly generated <code>String</code> objects and one implicitly generated <code>StringBuffer</code> object. References to two of the <code>String</code> objects appear as arguments passed to <code>main()</code> in the <code>args</code> array, which are pushed onto the stack by the <code>aaload</code> instructions at offset 24 and 33. The <code>StringBuffer</code> is created with the <code>new</code> instruction at offset 18 and initialized with the <code>invokespecial</code> instruction at offset 28. The final <code>String</code>, which represents the concatenation of <code>args[0]</code> and <code>args[1]</code>, is created by calling <code>toString()</code> on the <code>StringBuffer</code> object via the <code>invokevirtual</code> instruction at offset 37.</p>
                    <p>When the Java Virtual Machine creates a new instance of a class, either implicitly or explicitly, it first allocates memory on the heap to hold the object's instance variables. Memory is allocated for all variables declared in the object's class and in all its superclasses, including instance variables that are hidden. As described in Chapter 5, "The Java Virtual Machine," memory for other implementation-dependent components of an object's image on the heap, such as a pointer to class data in the method area, are also likely allocated at this point. As soon as the virtual machine has set aside the heap memory for a new object, it immediately initializes the instance variables to default initial values. These are the same values shown above in Table 7-1 as default initial values for class variables.</p>
                    <p>Once the virtual machine has allocated memory for the new object and initialized the instance variables to default values, it is ready to give the instance variables their proper initial values. The Java Virtual Machine uses two techniques to do this, depending upon whether the object is being created because of a <code>clone()</code> invocation. If the object is being created because of a <code>clone()</code>, the virtual machine copies the values of the instance variables of the object being cloned into the new object. Otherwise, the virtual machine invokes an <em>instance initialization method</em> on the object. The instance initialization method initializes the object's instance variables to their proper initial values.</p>
                    <p>The Java compiler generates at least one instance initialization method for every class it compiles. In the Java class file, the instance initialization method is named " <code>&lt;init&gt;</code>." For each constructor in the source code of a class, the Java compiler generates one <code>&lt;init&gt;</code> () method. If the class declares no constructors explicitly, the compiler generates a default no-arg constructor that just invokes the superclass's no-arg constructor. As with any other constructor, the compiler creates an <code>&lt;init&gt;</code> () method in the class file that corresponds to this default constructor.</p>
                    <p>An <code>&lt;init&gt;</code> () method can contain three kinds of code: an invocation of another <code>&lt;init&gt;</code> () method, code that implements any instance variable initializers, and code for the body of the constructor. If a constructor begins with an explicit invocation of another constructor in the same class (a <code>this()</code> invocation) its corresponding <code>&lt;init&gt;</code> () method will be composed of two parts :</p>
                    <ul>
                        <li>an invocation of the same-class <code>&lt;init&gt;</code> () method                    </li>
                        <li>the bytecodes that implement the body of the corresponding constructor                    </li>
                    </ul>
                    <p>If a constructor does not begin with a <code>this()</code> invocation and the class is not <code>Object</code>, the <code>&lt;init&gt;</code> () method will have three components:</p>
                    <ul>
                        <li>an invocation of a superclass <code>&lt;init&gt;</code> () method                    </li>
                        <li>the bytecodes for any instance variable initializers                    </li>
                        <li>the bytecodes that implement the body of the corresponding constructor                    </li>
                    </ul>
                    <p>If a constructor does not begin with a <code>this()</code> invocation and the class <em>is</em> <code>Object</code>, the first component in the above list is missing. Because <code>Object</code> has no superclass, its <code>&lt;init&gt;</code> () method's can't begin with a superclass <code>&lt;init&gt;</code> () method invocation.</p>
                    <p>If a constructor begins with an explicit invocation of a superclass constructor (a <code>super()</code> invocation), its <code>&lt;init&gt;</code> () method will invoke the corresponding superclass <code>&lt;init&gt;</code> () method. For example, if a constructor begins with an explicit invocation of the " <code>super(int, String)</code> constructor," the corresponding <code>&lt;init&gt;</code> () method will begin by invoking the superclass's " <code>&lt;init&gt;</code> (int, String)" method. If a constructor does not begin with an explicit <code>this()</code> or <code>super()</code> invocation, the corresponding <code>&lt;init&gt;</code> () method will invoke the superclass's no-arg <code>&lt;init&gt;</code> () method by default.</p>
                    <p>Here's an example with three constructors, numbered one through three:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex6/Example6.java <p>class Example6 {</p> <p></p> <p>private int width = 3;</p> <p></p> <p>// Constructor one:</p> <p>// This constructor begins with a this() constructor invocation,</p> <p>// which gets compiled to a same-class &lt;init&gt;</p></code> () method <p>// invocation.</p> <p>Example6() {</p> <p>this(1);</p> <p>System.out.println("Example6(), width = " + width);</p> <p>}</p> <p></p> <p>// Constructor two:</p> <p>// This constructor begins with no explicit invocation of another</p> <p>// constructor, so it will get compiled to an &lt;init&gt;() method</p> <p>// that begins with an invocation of the superclass's no-arg</p> <p>// &lt;init&gt;() method.</p> <p>Example6(int width) {</p> <p>this.width = width;</p> <p>System.out.println("Example6(int), width = " + width);</p> <p>}</p> <p></p> <p>// Constructor three:</p> <p>// This constructor begins with super(), an explicit invocation</p> <p>// of the superclass's no-arg constructor. Its &lt;init&gt;() method</p> <p>// will begin with an invocation of the superclass's no-arg</p> <p>// &lt;init&gt;() method.</p> <p>Example6(String msg) {</p> <p>super();</p> <p>System.out.println("Example6(String), width = " + width);</p> <p>System.out.println(msg);</p> <p>}</p> <p></p> <p>public static void main(String[] args) {</p> <p>String msg</p> <p>= "The Agapanthus is also known as Lilly of the Nile.";</p> <p>Example6 one = new Example6();</p> <p>Example6 two = new Example6(2);</p> <p>Example6 three = new Example6(msg);</p> <p>}</p> <p>}</p>  <p></p>  <code>end</code> </pre>
                    <p>When executed, the <code>Example6</code> application prints this output:</p>
                    <pre> <p><code>begin</code></p>  <p/> <code>Example6(int), width = 1 <p>Example6(), width = 1</p> <p>Example6(int), width = 2</p> <p>Example6(String), width = 3</p> <p>The Agapanthus is also known as Lilly of the Nile.</p></code>  <p></p>  <code>end</code>  </pre>
                    <p>The bytecodes for <code>Example6</code>'s no-arg <code>&lt;init&gt;</code> () method (the <code>&lt;init&gt;</code> () method that corresponds to constructor one) are:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// The first component, the same-class &lt;init&gt;</code> () invocation, begins <p>// here:</p> <p>0 aload_0      // Push the objref from loc var 0 (this)</p> <p>1 iconst_1     // Push int constant 1</p> <p>// Pop int and objref, invoke &lt;init&gt;() method on</p> <p>// objref (this), passing the int (a 1) as the</p> <p>// only parameter.</p> <p>2 invokespecial #12 &lt;Method Example6(int)</p> <p></p> <p>// The second component, the body of the constructor, begins</p> <p>// here:</p> <p>// Push objref from System.out</p> <p>5 getstatic #16 &lt;Field java.io.PrintStream out</p> <p>// Allocate mem for new StringBuffer object, and</p> <p>// initialize mem to default initial values, push</p> <p>// objref to new object</p> <p>8 new #8 &lt;Class java.lang.StringBuffer</p> <p>11 dup          // Duplicate objref to StringBuffer object</p> <p>// Push objref to String literal from constant pool</p> <p>12 ldc #1 &lt;String "Example6(), width = "</p> <p>// Pop objref to literal String, pop objref of the</p> <p>// StringBuffer object, invoke &lt;init&gt;() method on the</p> <p>// StringBuffer object passing the args[0] objref as</p> <p>// the only parameter.</p> <p>14 invokespecial #14 &lt;Method java.lang.StringBuffer(</p> <p>java.lang.String)</p> <p>17 aload_0      // Push objref from loc var 0 (this)</p> <p>// Pop this reference, Push int value of width field</p> <p>18 getfield #19 &lt;Field int width</p> <p>// Pop int (width), pop objref (StringBuffer object),</p> <p>// invoke append() on StringBuffer object passing the</p> <p>// width int as the only parameter. append() will add</p> <p>// the string representation of the int to the end of</p> <p>// the buffer, and return an objref to the same</p> <p>// StringBuffer object.</p> <p>21 invokevirtual #15 &lt;Method java.lang.StringBuffer append(int)</p> <p>// Pop objref to StringBuffer (pushed by append()),</p> <p>// invoke toString() on it, which returns the value</p> <p>// of the StringBuffer as a String object. Push</p> <p>// objref of String object.</p> <p>24 invokevirtual #18 &lt;Method java.lang.String toString()</p> <p>// Pop objref of String, pop objref of System.out</p> <p>// that was pushed by the getstatic instruction at</p> <p>// offset 5. Invoke println() on System.out,</p> <p>// passing the String as the only parameter:</p> <p>// System.out.println("Example6(), width = "</p> <p>//     + width);</p> <p>27 invokevirtual #17 &lt;Method void println(java.lang.String)</p> <p>30 return       // Return void from &lt;init&gt;()</p>  <p></p>  <code>end</code> </pre>
                    <p>Note that the <code>&lt;init&gt;</code> () method for constructor one begins with an invocation of a same-class <code>&lt;init&gt;</code> () method, then executes the body of the corresponding constructor. Because the constructor begins with a <code>this()</code> invocation, its corresponding <code>&lt;init&gt;</code> () method doesn't contain bytecodes for the instance variable initializer.</p>
                    <p>The bytecodes for <code>Example6</code>'s <code>&lt;init&gt;</code> () method that takes an <code>int  parameter (the <code>&lt;init&gt;  () method that corresponds to constructor two) is:</code></p>
                    <pre> <p><code>begin</code></p>  <p/> <code>// The first component, the superclass &lt;init&gt;</code> () invocation, begins <p>// here:</p> <p>0 aload_0      // Push the objref from loc var 0 (this)</p> <p>// Pop objref (this), invoke the superclass's</p> <p>// no-arg&lt;init&gt;() method on objref.</p> <p>1 invokespecial #11 &lt;Method java.lang.Object()</p> <p></p> <p>// The second component, the instance variable initializers, begins</p> <p>// here:</p> <p>4 aload_0      // Push the objref from loc var 0 (this)</p> <p>5 iconst_3     // Push int constant 3</p> <p>// Pop int (3), pop objref (this), store 3 into</p> <p>// width instance variable of this object</p> <p>6 putfield #19 &lt;Field int width</p> <p></p> <p>// The third component, the body of the constructor, begins</p> <p>// here:</p> <p>9 aload_0      // Push the objref from loc var 0 (this)</p> <p>10 iload_1      // Push int from loc var 1 (int param width)</p> <p>// Pop int (param width), pop objref (this), store</p> <p>// int param value into width field of this object:</p> <p>// this.width = width</p> <p>11 putfield #19 &lt;Field int width</p> <p>// Push objref from System.out</p> <p>14 getstatic #16 &lt;Field java.io.PrintStream out</p> <p>// Allocate mem for new StringBuffer object, and</p> <p>// initialize mem to default initial values, push</p> <p>// objref to new object</p> <p>17 new #8 &lt;Class java.lang.StringBuffer</p> <p>20 dup          // Duplicate objref to StringBuffer object</p> <p>// Push objref to String literal from constant pool</p> <p>21 ldc #3 &lt;String "Example6(int), width = "</p> <p>// Pop objref to literal String, pop objref of the</p> <p>// StringBuffer object, invoke &lt;init&gt;() method on the</p> <p>// StringBuffer object passing the args[0] objref as</p> <p>// the only parameter.</p> <p>23 invokespecial #14 &lt;Method java.lang.StringBuffer(</p> <p>java.lang.String)</p> <p>26 iload_1      // Push int from loc var 1 (int param width)</p> <p>// Pop int (width), pop objref (StringBuffer object),</p> <p>// invoke append() on StringBuffer object passing the</p> <p>// width int as the only parameter. append() will add</p> <p>// the string representation of the int to the end of</p> <p>// the buffer, and return an objref to the same</p> <p>// StringBuffer object.</p> <p>27 invokevirtual #15 &lt;Method java.lang.StringBuffer append(int)</p> <p>// Pop objref to StringBuffer (pushed by append()),</p> <p>// invoke toString() on it, which returns the value</p> <p>// of the StringBuffer as a String object. Push</p> <p>// objref of String object.</p> <p>30 invokevirtual #18 &lt;Method java.lang.String toString()</p> <p>// Pop objref of String, pop objref of System.out</p> <p>// that was pushed by the getstatic instruction at</p> <p>// offset 14. Invoke println() on System.out,</p> <p>// passing the String as the only parameter:</p> <p>// System.out.println("Example6(int), width = "</p> <p>//     + width);</p> <p>33 invokevirtual #17 &lt;Method void println(java.lang.String)</p> <p>36 return       // Return void from &lt;init&gt;()</p>  <p></p>  <code>end</code> </pre>
                    <p>The <code>&lt;init&gt;</code> () method for constructor two has three components. First it has an invocation of the superclass's ( <code>Object</code>'s) no-arg <code>&lt;init&gt;</code> () method. The compiler generated this invocation by default, because no explicit <code>super()</code> invocation appears as the first statement in the body of constructor two. Following the superclass <code>&lt;init&gt;</code> () invocation is the second component: the bytecodes for width's instance variable initializer. Third, the <code>&lt;init&gt;</code> () method contains the bytecodes for the body of constructor two.</p>
                    <p>The bytecodes for <code>Example6</code>'s <code>&lt;init&gt;</code> () method that takes a <code>String</code> parameter (the <code>&lt;init&gt;</code> () method that corresponds to constructor three) are:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// The first component, the superclass &lt;init&gt;</code> () invocation, begins <p>// here:</p> <p>0 aload_0      // Push the objref from loc var 0 (this)</p> <p>// Pop objref (this), invoke the superclass's</p> <p>// no-arg&lt;init&gt;() method on objref.</p> <p>1 invokespecial #11 &lt;Method java.lang.Object()</p> <p></p> <p>// The second component, the instance variable initializers, begins</p> <p>// here:</p> <p>4 aload_0      // Push the objref from loc var 0 (this)</p> <p>5 iconst_3     // Push int constant 3</p> <p>// Pop int (3), pop objref (this), store 3 into</p> <p>// width instance variable of this object</p> <p>6 putfield #19 &lt;Field int width</p> <p></p> <p>// The third component, the body of the constructor, begins</p> <p>// here:</p> <p>// Push objref from System.out</p> <p>9 getstatic #16 &lt;Field java.io.PrintStream out</p> <p>// Allocate mem for new StringBuffer object, and</p> <p>// initialize mem to default initial values, push</p> <p>// objref to new object</p> <p>12 new #8 &lt;Class java.lang.StringBuffer</p> <p>15 dup          // Duplicate objref to StringBuffer object</p> <p>// Push objref to String literal from constant pool</p> <p>16 ldc #2 &lt;String "Example6(String), width = "</p> <p>// Pop objref to literal String, pop objref of the</p> <p>// StringBuffer object, invoke &lt;init&gt;() method on the</p> <p>// StringBuffer object passing the args[0] objref as</p> <p>// the only parameter.</p> <p>18 invokespecial #14 &lt;Method java.lang.StringBuffer(</p> <p>java.lang.String)</p> <p>21 aload_0      // Push objref from loc var 0 (this)</p> <p>// Pop this reference, Push int value of width field</p> <p>22 getfield #19 &lt;Field int width</p> <p>// Pop int (width), pop objref (StringBuffer object),</p> <p>// invoke append() on StringBuffer object passing the</p> <p>// width int as the only parameter. append() will add</p> <p>// the string representation of the int to the end of</p> <p>// the buffer, and return an objref to the same</p> <p>// StringBuffer object.</p> <p>25 invokevirtual #15 &lt;Method java.lang.StringBuffer append(int)</p> <p>// Pop objref to StringBuffer (pushed by append()),</p> <p>// invoke toString() on it, which returns the value</p> <p>// of the StringBuffer as a String object. Push</p> <p>// objref of String object.</p> <p>28 invokevirtual #18 &lt;Method java.lang.String toString()</p> <p>// Pop objref of String, pop objref of System.out</p> <p>// that was pushed by the getstatic instruction at</p> <p>// offset 9. Invoke println() on System.out,</p> <p>// passing the String as the only parameter:</p> <p>// System.out.println("Example6(String), width = "</p> <p>//     + width);</p> <p>31 invokevirtual #17 &lt;Method void println(java.lang.String)</p> <p>// Push objref from System.out</p> <p>34 getstatic #16 &lt;Field java.io.PrintStream out</p> <p>37 aload_1      // Push objref from loc var 1 (param msg)</p> <p>// Pop objref of String, pop objref of System.out</p> <p>// that was pushed by the getstatic instruction at</p> <p>// offset 37. Invoke println() on System.out,</p> <p>// passing the String as the only parameter:</p> <p>// System.out.println(msg);</p> <p>38 invokevirtual #17 &lt;Method void println(java.lang.String)</p> <p>41 return       // Return void from &lt;init&gt;()</p>  <p></p>  <code>end</code> </pre>
                    <p>The <code>&lt;init&gt;</code> () method for constructor three has the same three components as the <code>&lt;init&gt;</code> () method for constructor two: a superclass <code>&lt;init&gt;</code> () invocation, the bytecodes for width's initializer, and the bytecodes for the constructor body. One difference between constructor two and three is that constructor two does not begin with an explicit <code>this()</code> or <code>super()</code> invocation. As a result, the compiler places an invocation of the superclass's no-arg <code>&lt;init&gt;</code> () method in constructor two's <code>&lt;init&gt;</code> () method. By contrast, constructor three begins with an explicit <code>super()</code> invocation, which the compiler converts into the corresponding superclass <code>&lt;init&gt;</code> () invocation in constructor three's <code>&lt;init&gt;</code> () method.</p>
                    <p>For every class except <code>Object</code>, an <code>&lt;init&gt;</code> () method must begin with an invocation of another <code>&lt;init&gt;</code> () method belonging either to the same class or to the direct superclass. <code>&lt;init&gt;</code> () methods are not allowed to catch exceptions thrown by the <code>&lt;init&gt;</code> () method they invoke. If a subclass <code>&lt;init&gt;</code> () method invokes a superclass <code>&lt;init&gt;</code> () method that completes abnormally, for example, the subclass <code>&lt;init&gt;</code> () method must also complete abruptly.</p>



<h3 id="garbage_collection_and_finalization">Garbage Collection and Finalization of Objects</h3>
                    <p>As mentioned in earlier chapters, implementations of the Java Virtual Machine must have some kind of automatic storage management strategy for the heap, most likely a garbage collector. Applications can allocate memory for objects via the explicit and implicit ways described earlier in this chapter, but cannot explicitly free that memory. When an object becomes unreferenced by the application, the virtual machine may reclaim (garbage collect) that memory. Implementations can decide when to garbage collect unreferenced objects--even whether to garbage collect them at all. Java Virtual Machine implementations are not required to free memory occupied by unreferenced objects.</p>
                    <p>If a class declares a method named <code>finalize()</code> that returns <code>void</code>, the garbage collector will execute that method (called a "finalizer") once on an instance of that class, before it frees the memory space occupied by that instance. Here's an example of a class that declares a finalizer:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex7/Finale.java <p>class Finale {</p> <p>protected void finalize() {</p> <p>System.out.println("A Finale object was finalized.");</p> <p>//...</p> <p>}</p> <p>//...</p> <p>}</p></code>  <p></p>  <code>end</code>  </pre>
                    <p>Because a finalizer is a regular Java method, it may be invoked directly by the application. Such a direct invocation will not affect the automatic invocation of the finalizer by the garbage collector. The garbage collector may invoke an object's finalizer at most once, sometime after the object becomes unreferenced and before the memory it occupies is reused. If the object becomes referenced again (resurrected) as a result of executing the finalizer code, and then becomes unreferenced again later, the garbage collector must not automatically invoke the finalizer a second time.</p>
                    <p>Any exceptions thrown by the <code>finalize()</code> method during its automatic invocation by the garbage collector are ignored. The garbage collector may invoke <code>finalize()</code> methods in any order, using any thread, or even concurrently via multiple threads. Finalization is described in more detail in Chapter 9, "Garbage Collection."</p>



<h2 id="unloading_and_finalization">Unloading and Finalization of Classes</h2>
                    <p>In many ways, the lifetime of a class in the Java Virtual Machine is similar to the lifetime of an object. The virtual machine creates and initializes objects, allows the program to use the objects, and optionally garbage collects the objects after they are no longer referenced by the program. Similarly, the virtual machine loads, links, and initializes classes, allows the program to use the classes, and optionally unloads the classes after they are no longer referenced by the program. Just as the Java Virtual Machine will run an object's <code>finalize()</code> method (if its class declares one) before it garbage collects the object, the Java Virtual Machine will run a class's <code>classFinalize()</code> method (if the class declares one) before it unloads the class.</p>
                    <p>Garbage collection and unloading of classes is important in the Java Virtual Machine because Java programs can be dynamically extended at runtime by loading types through class loader objects. All loaded types occupy memory space in the method area. If a Java application continuously loads types through class loader objects, the memory footprint of the method area will continuously grow. If some of the dynamically loaded types are needed only temporarily, the memory space occupied by those types can be freed by unloading the types after they are no longer needed.</p>
                    <p>The way in which a Java Virtual Machine can tell whether a dynamically loaded type is still needed by the application is similar to the way it tells whether an object is still needed by the program. If the application has no references to the type, then the type can't affect the future course of computation. The type is unreachable and can be garbage collected.</p>
                    <p>Types loaded through the primordial class loader will always be reachable and never be unloaded. Only dynamically loaded types--those loaded through class loader objects--can become unreachable and be unloaded by the virtual machine. A dynamically loaded type is unreachable if its <code>Class</code> instance is found to be unreachable through the normal process of garbage collecting the heap.</p>
                    <p>There are two ways a <code>Class</code> instance of a dynamically loaded type can be reachable through the normal process of garbage collection. First and most obviously, a <code>Class</code> instance will be reachable if the application holds an explicit reference to it. Second, a <code>Class</code> instance will be reachable if there is a reachable object on the heap whose type data in the method area refers to the <code>Class</code> instance. As mentioned in Chapter 5, "The Java Virtual Machine," implementations must be able to locate the type data in the method are for an object's class, given only a reference to the object. For this reason, the image of an object on the heap likely includes some kind of pointer to its type data in the method area. From the type data, the virtual machine must be able to locate the <code>Class</code> instances for the object's class, all its superclasses, and all its superinterfaces. See Figure 7-2 for a graphical depiction of this way of "reaching" <code>Class</code> instances.</p>
                    <p><img src="images/fig7-2.gif" alt= "figure 7-2"></p>
                    <p>Figure 7-2 shows the paths a garbage collector must traverse from a reachable object of class <code>MyThread</code> through the type data in the method area to find reachable <code>Class</code> instances. In this figure, objects on the heap are shown as clear circles; type data in the method are is shown as gray rectangles. The <code>MyThread</code> class has the following declaration:</p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex8/MyThread.java <p>class MyThread extends Thread implements Cloneable {</p> <p>}</p></code>  <p></p>  <code>end</code> </pre>
                    <p>From the reachable <code>MyThread</code> object (shown in the bottom right hand corner of the figure), the garbage collector follows a pointer to <code>MyThread</code>'s type data, where it finds:</p>
                    <ul>
                        <li>A reference to <code>MyThread</code>'s <code>Class</code> instance on the heap</li>
                        <li>A pointer to the type data for <code>MyThread</code>'s direct superinterface, <code>Cloneable</code></li>
                        <li>A pointer to the type data for <code>MyThread</code> 's direct superclass, <code>Thread</code></li> </ul>
                    <p>From the type data for <code>Cloneable</code>, the garbage collector finds:</p>
                    <ul>
                        <li>A reference to <code>Cloneable</code>'s <code>Class</code> instance on the heap</code>                          </li>
                    </ul>
                    <p>From the type data for <code>Thread</code>, the garbage collector finds:</p>
                    <ul>
                        <li>A reference to <code>Thread</code>'s <code>Class</code> instance on the heap</li>
                        <li>A pointer to the type data for <code>Thread</code>'s direct superinterface, <code>Runnable</code></li>
                        <li>A pointer to the type data for <code>Thread</code> 's direct superclass, <code>Object</code></li>
                    </ul>
                    <p>
                        From the type data for <code>Runnable</code>,
                        the garbage collector finds:
</p>
                    <ul>
                        <li>A reference to <code>Runnable</code> 's <code>Class</code> instance on the heap</li>
                    </ul>
                    <p>From the type data for <code>Object</code>, the garbage collector finds:</code>
</p>
                    <ul>
                        <li>
                            A reference to <code>Objects</code>'s <code>Class</code> instance on the heap</code>
                        </li>
                    </ul>
                    <p>
                        Thus, given only a reference to a reachable instance of class <code>MyThread</code>, the garbage collector is able to "reach" the <code>Class</code> instances for <code>MyThread</code> and all its supertypes: <code>Cloneable</code>, <code>Thread</code>, <code>Runnable</code>, and <code>Object</code>.</code></p>
                    <p>If a class declares a method, named <code>classFinalize()</code>, that is static, takes no parameters, and returns <code>void</code>, the Java Virtual Machine will execute that method (called a "class finalizer") before it unloads the class. The class finalizer may have any access permission. Here's an example:</code></p>
                    <pre> <p><code>begin</code></p>  <p/></code> <code>// On CD-ROM in file classlife/ex7/GrandFinale.java <p>class GrandFinale {</p> <p>static void classFinalize() {</p> <p>System.out.println(</p> <p>"Class GrandFinale was finally finalized.");</p> <p>//...</p> <p>}</p> <p>//...</p> <p>}</p></code>  <p></p>  <code>end</code>  </pre>
                    <p>Similar to the <code>finalize()</code> method, the <code>classFinalize()</code> method will be called only once by the Java Virtual Machine. If a class's <code>classFinalize()</code> method resurrects the class (makes it reachable again), the next time the class is unloaded its <code>classFinalize()</code> method won't be invoked.</code></p>
                    <p>An example of dynamically loaded classes becoming unreachable and available for unloading is given at the end of Chapter 8, "The Linking Model."</code></p>




<h2 id="on_the_cd">On the CD-ROM</h2>
<p>The CD-ROM contains the source code examples from this chapter in the <code>classlife</code> directory.</p>



<h2 id="resources_page">The Resources Page</h2>
<p>
    For more information about the material presented in this chapter, visit the resources page:
    <code>http://www.artima.com/insidejvm/classlife.html</code>.
</p>

</div>

</div>
<br/>
<div class="u-cf"></div>

<div class="row">
    <div class="one-third column value">
        <a class="button button-primary mod" href="06.html">Previous page</a>
    </div>
    <div class="one-third column value" style="text-align:center;">
        <a class="button button-primary mod" href="index.html">Table of content</a>
    </div>
    <div class="one-third column value">
        <a class="button button-primary mod u-pull-right" href="08.html">Next page</a>
    </div>
</div>
<hr/>
</div>
</div>
</div>

</body>
</html>


