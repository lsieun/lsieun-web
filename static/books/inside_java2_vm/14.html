<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>14 Floating-Point Arithmetic | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>14 Floating-Point Arithmetic</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="13.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="15.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr/>
                    <ul>
                        <li><a href="#on_the_cd">On the CD-ROM</a></li>
                        <li><a href="#resources_page">The Resources Page</a></li>
                    </ul>
                    <hr>
                    <p>This chapter describes the floating point numbers and the instructions that perform floating point arithmetic inside the Java Virtual Machine. The floating point numbers described here conform to the IEEE 754 floating point standard, which is the standard to which all Java Virtual Machine implementations must adhere.</p> <p>Accompanying this chapter on the CD-ROM are two applets that interactively illustrate the material presented in the chapter. One applet, named <i>Inner Float</i>, allows you to view and manipulate the individual components that make up a floating point number. The other applet, named <i>Circle of Squares</i>, simulates the Java Virtual Machine executing a method that uses several of the floating point opcodes. Within this chapter, you will find descriptions of both of these applets.</p> <p><i>Floating Point Numbers</i></p> <p>The Java Virtual Machine's floating-point support adheres to the IEEE-754 1985 floating-point standard. This standard defines the format of 32-bit and 64-bit floating-point numbers and defines the operations upon those numbers. In the Java Virtual Machine, floating-point arithmetic is performed on 32-bit <code>float</code> s and 64-bit <code>double</code> s. For each opcode that performs arithmetic on <code>float</code> s, there is a corresponding opcode that performs the same operation on <code>double</code> s.</p> <p>A floating-point number has four parts --a sign, a mantissa, a radix, and an exponent. The sign is either a 1 or -1. The mantissa, always a positive number, holds the significant digits of the floating-point number. The exponent indicates the positive or negative power of the radix that the mantissa and sign should be multiplied by. The four components are combined as follows to get the floating-point value:</p> <p><code>begin math formula</code></p> <p>sign * mantissa * radix <sup> exponent </sup></p> <p><code>end math forzmula</code></p> <p>Floating-point numbers have multiple representations, because one can always multiply the mantissa of any floating-point number by some power of the radix and change the exponent to get the original number. For example, as shown in Table 14-1, the number -5 can be represented equally by any of the listed forms in radix 10.</p> <p>Table 14-1. <strong> Forms of -5 </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Sign </strong></td> <td><strong> Mantissa </strong></td> <td><strong> Radix <sup> exponent </sup> </strong></td></tr> <tr><td>-1</td> <td>50</td> <td>10 <sup> -1 </sup></td></tr> <tr><td>-1</td> <td>5</td> <td>10 <sup> </sup></td></tr> <tr><td>-1</td> <td>0.5</td> <td>10 <sup> 1 </sup></td></tr> <tr><td>-1</td> <td>0.05</td> <td>10 <sup> 2 </sup></td></tr> </tbody> </table> <p>For each floating-point number there is one representation that is said to be <em> normalized. </em> A floating-point number is normalized if its mantissa is within the range defined by the following relation:</p> <p><code>begin math formula</code></p> <p>1/radix &lt;= mantissa &lt; 1</p> <p><code>end math formula</code></p> <p>A normalized radix 10 floating-point number has its decimal point just to the left of the first non-zero digit in the mantissa. The normalized floating-point representation of -5 is -1 * 0.5 * 10 <sup> 1 </sup>. In other words, a normalized floating-point number's mantissa has no non-zero digits to the left of the decimal point and a non-zero digit just to the right of the decimal point. Any floating-point number that doesn't fit into this category is said to be <em> denormalized </em>. Note that the number zero has no normalized representation, because it has no non-zero digit to put just to the right of the decimal point. "Why be normalized?" is a common exclamation among zeros.</p> <p>Floating-point numbers in the Java Virtual Machine use a radix of two, so they have the following form:</p> <p><code>begin math formula</code></p> <p>sign * mantissa * 2 <sup> exponent </sup></p> <p><code>end math formula</code></p> <p>The mantissa of a floating-point number in the Java Virtual Machine is expressed as a binary number. A normalized mantissa has its binary point (the base-two equivalent of a decimal point) just to the left of the most significant non-zero digit. Because the binary number system has just two digits--zero and one--the most significant digit of a normalized mantissa is always a one.</p> <p>The most significant bit of a <code>float</code> or <code>double</code> is its sign bit. The mantissa occupies the 23 least significant bits of a <code>float</code> and the 52 least significant bits of a <code>double</code>. The exponent, 8 bits in a <code>float</code> and 11 bits in a <code>double</code>, sits between the sign and mantissa. The format of a <code>float</code> is shown below. The sign bit is shown as an "s," the exponent bits are shown as "e," and the mantissa bits are shown as "m":</p> <p><code>begin math formula</code></p> <p>s eeeeeeee mmmmmmmmmmmmmmmmmmmmmmm</p> <p><code>end math formula</code></p> <p>A sign bit of zero indicates a positive number and a sign bit of one indicates a negative number. The mantissa is always interpreted as a positive base-two number. It is not a twos -complement number. If the sign bit is one, the floating-point value is negative, but the mantissa is still interpreted as a positive number that must be multiplied by -1.</p> <p>The exponent field is interpreted in one of three ways. An exponent of all ones indicates the floating-point number has one of the special values of plus or minus infinity, or "not a number" &nbsp;(NaN). NaN is the result of certain operations, such as the division of zero by zero. An exponent of all zeros indicates a denormalized floating-point number. Any other exponent indicates a normalized floating-point number.</p> <p>The mantissa contains one extra bit of precision beyond those that appear in the mantissa bits. The mantissa of a <code>float</code>, which occupies only 23 bits, has 24 bits of precision. The mantissa of a <code>double</code>, which occupies 52 bits, has 53 bits of precision. The most significant mantissa bit is predictable, and is therefore not included, because the exponent of floating-point numbers in the Java Virtual Machine indicates whether or not the number is normalized. If the exponent is all zeros, the floating-point number is denormalized and the most significant bit of the mantissa is known to be a zero. Otherwise, the floating-point number is normalized and the most significant bit of the mantissa is known to be one.</p> <p>The Java Virtual Machine throws no exceptions as a result of any floating-point operations. Special values, such as positive and negative infinity or NaN, are returned as the result of suspicious operations such as division by zero. An exponent of all ones indicates a special floating-point value. An exponent of all ones with a mantissa whose bits are all zero indicates an infinity. The sign of the infinity is indicated by the sign bit. An exponent of all ones with any other mantissa is interpreted to mean "not a number" (NaN). The Java Virtual Machine always produces the same mantissa for NaN, which is all zeros except for the most significant mantissa bit that appears in the number. These values are shown for a <code>float</code> in Table 14-2.</p> <p>Table 14-2. <strong> Special <code>float</code> values </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Value </strong></td> <td><strong> <code>float</code> bits (sign exponent mantissa) </strong></td></tr> <tr><td>+Infinity</td> <td>0 11111111 00000000000000000000000</td></tr> <tr><td>-Infinity</td> <td>1 11111111 00000000000000000000000</td></tr> <tr><td>NaN</td> <td>1 11111111 10000000000000000000000</td></tr> </tbody> </table> <p>Exponents that are neither all ones nor all zeros indicate the power of two by which to multiply the normalized mantissa. The power of two can be determined by interpreting the exponent bits as a positive number, and then subtracting a bias from the positive number. For a <code>float</code>, the bias is 126. For a <code>double</code>, the bias is 1023. For example, an exponent field in a <code>float</code> of 00000001 yields a power of two by subtracting the bias (126) from the exponent field interpreted as a positive integer (1). The power of two, therefore, is (1 - 126), which is -125. This is the smallest possible power of two for a <code>float</code>. At the other extreme, an exponent field of 11111110 yields a power of two of (254 - 126) or 128. The number 128 is the largest power of two available to a <code>float</code>. Several examples of normalized <code>float</code> s are shown in Table 14-3.</p> <p>Table 14-3. <strong> Normalized <code>float</code> values </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Value </strong></td> <td><strong> <code>float</code> bits (sign exponent mantissa) </strong></td> <td><strong> Unbiased exponent </strong></td></tr> <tr><td>Largest positive (finite) <code>float</code></td> <td>0 11111110 11111111111111111111111</td> <td>128</td></tr> <tr><td>Largest negative (finite) <code>float</code></td> <td>1 11111110 11111111111111111111111</td> <td>128</td></tr> <tr><td>Smallest normalized <code>float</code></td> <td>1 00000001 00000000000000000000000</td> <td>-125</td></tr> <tr><td>Pi</td> <td>0 10000000 10010010000111111011011</td> <td>2</td></tr> </tbody> </table> <p>An exponent of all zeros indicates the mantissa is denormalized, which means the unstated leading bit is a zero instead of a one. The power of two in this case is the same as the lowest power of two available to a normalized mantissa. For the <code>float</code>, this is -125. This means that normalized mantissas multiplied by two raised to the power of -125 have an exponent field of 00000001, while denormalized mantissas multiplied by two raised to the power of -125 have an exponent field of 00000000.</p> <p>The allowance for denormalized numbers at the bottom end of the range of exponents supports gradual underflow. If the lowest exponent was instead used to represent a normalized number, underflow to zero would occur for larger numbers. In other words, leaving the lowest exponent for denormalized numbers allows smaller numbers to be represented. The smaller denormalized numbers have fewer bits of precision than normalized numbers, but this is preferable to underflowing to zero as soon as the exponent reaches its minimum normalized value. Table 14-4 shows several denormalized floating-point values.</p> <p>Table 14-4. <strong> Denormalized <code>float</code> values </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Value </strong></td> <td><strong> <code>float</code> bits (sign exponent mantissa) </strong></td></tr> <tr><td>Smallest positive (non-zero) <code>float</code></td> <td>0 00000000 00000000000000000000001</td></tr> <tr><td>Smallest negative (non-zero) <code>float</code></td> <td>1 00000000 00000000000000000000001</td></tr> <tr><td>Largest denormalized <code>float</code></td> <td>1 00000000 11111111111111111111111</td></tr> <tr><td>Positive zero</td> <td>0 00000000 00000000000000000000000</td></tr> <tr><td>Negative zero</td> <td>1 00000000 00000000000000000000000</td></tr> </tbody> </table> <p><i><strong> Inner Float: A Java float Reveals its Inner Nature </strong></i></p> <p>The applet shown in Figure 14-1 lets you play around with the floating-point format. The value of a <code>float</code> is displayed in several formats. The radix two scientific notation format shows the mantissa and exponent in base ten. Before being displayed, the actual mantissa is multiplied by 2 <sup> 24 </sup>, which yields an integral number, and the unbiased exponent is decremented by 24. Both the integral mantissa and exponent are then easily converted to base ten and displayed. The applet is embedded in a web page on the CD-ROM in file <code>applets/InnerFloat.html</code>. The text of the web page includes several button-press sequences that demonstrate various properties of floating point numbers.</p> <p><img src="images/fig14-1.gif" alt="figure 14-1"></p> <p><i><strong> The Floating Point Opcodes </strong></i></p> <p>Table 14-5 shows the opcodes that pop two floating-point values from the top of the stack, add them, and push the result. The type of the values is indicated by the opcode itself, and the result always has the same type as the numbers being added. No exceptions are thrown by these opcodes. Overflow results in a positive or negative infinity, and underflow results in a positive or negative zero.</p> <p>Table 14-5. <strong> Floating-point addition </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>fadd</code></td> <td>(none)</td> <td>pops two <code>float</code> s, adds them, and pushes the <code>float</code> result</td></tr> <tr><td><code>dadd</code></td> <td>(none)</td> <td>pops two <code>double</code> s, adds them, and pushes the <code>double</code> result</td></tr> </tbody> </table> <p>Subtraction is performed on <code>float</code> s and <code>double</code> s via the opcodes shown in Table 14-6. Each opcode causes the top two values of the appropriate type to be popped off the stack. The topmost value is subtracted from the value just beneath the topmost value. The result is pushed back onto the stack. No exceptions are thrown by either of these opcodes.</p> <p>Table 14-6. <strong> Floating-point subtraction </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>fsub</code></td> <td>(none)</td> <td>pops two <code>float</code> s, subtracts them, and pushes the <code>float</code> result</td></tr> <tr><td><code>dsub</code></td> <td>(none)</td> <td>pops two <code>double</code> s, subtracts them, and pushes the <code>double</code> result</td></tr> </tbody> </table> <p>Multiplication of <code>float</code> s and <code>double</code> s is accomplished via the opcodes shown in Table 14-7. Each opcode causes two values of the same type to be popped off the stack and multiplied. The result, of the same type as the numbers being multiplied, is pushed back onto the stack. No exceptions are thrown.</p> <p>Table 14-7. <strong> Floating-point multiplication </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>fmul</code></td> <td>(none)</td> <td>pops two <code>float</code> s, multiplies them, and pushes the <code>float</code> result</td></tr> <tr><td><code>dmul</code></td> <td>(none)</td> <td>pops two <code>double</code> s, multiplies them, and pushes the <code>double</code> result</td></tr> </tbody> </table> <p>The division is performed on <code>float</code> s and <code>double</code> s by the opcodes shown in Table 14-8. The division opcodes cause the top two values of the appropriate type to be popped off the stack. The value immediately beneath the topmost value is divided by the topmost value. (In other words, the value pushed first is the dividend or numerator. The value pushed second--the top of the stack--is the divisor or denominator.) The result of the division is pushed back onto the stack.</p> <p>Table 14-8. <strong> Floating-point division </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>fdiv</code></td> <td>(none)</td> <td>pops two <code>float</code> s, divides them, and pushes the <code>float</code> result</td></tr> <tr><td><code>ddiv</code></td> <td>(none)</td> <td>pops two <code>double</code> s, divides them, and pushes the <code>double</code> result</td></tr> </tbody> </table> <p>No exception is thrown as a result of any floating-point division. Floating-point division of a finite value by zero yields a positive or negative infinity. Floating-point division of zero by zero yields NaN. A summary of the result of dividing various combinations of infinity, zero, NaN, and finite values is given in Table 14-10.</p> <p>The remainder operation is performed on <code>float</code> s and <code>double</code> s via the opcodes shown in Table 14-9. The following opcodes cause the top two values to be popped from the stack. The value just beneath the topmost value is divided by the topmost value, and the remainder of that division is pushed back onto the stack.</p> <p>Table 14-9. <strong> Floating-point remainder </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>frem</code></td> <td>(none)</td> <td>pops two <code>float</code> s, divides them, and pushes the <code>float</code> remainder</td></tr> <tr><td><code>drem</code></td> <td>(none)</td> <td>pops two <code>double</code> s, divides them, and pushes the <code>double</code> remainder</td></tr> </tbody> </table> <p>No exception is thrown as a result of any floating-point remainder operation. Floating-point remainder of any value divided by zero yields a NaN result. A summary of the result of computing the remainder various combinations of infinity, zero, NaN, and finite values is given in Table 14-10.</p> <p>Table 14-10. Results of various <strong> floating-point divisions </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> <code>a</code> </strong></td> <td><strong> <code>b</code> </strong></td> <td><strong> <code>a/b</code> </strong></td> <td><strong> <code>a%b</code> </strong></td></tr> <tr><td>Finite</td> <td>+-0.0</td> <td>+-Infinity</td> <td>NaN</td></tr> <tr><td>Finite</td> <td>+-Infinity</td> <td>+-0.0</td> <td>a</td></tr> <tr><td>+-0.0</td> <td>+-0.0</td> <td>NaN</td> <td>NaN</td></tr> <tr><td>+-Infinity</td> <td>Finite</td> <td>+-Infinity</td> <td>NaN</td></tr> <tr><td>+-Infinity</td> <td>+Infinity</td> <td>NaN</td> <td>NaN</td></tr> </tbody> </table> <p>The remainder operation provided by <code>frem</code> and <code>drem</code> follows the same rule as the integer remainder operation provided by <code>irem</code> and <code>lrem</code> :</p> <pre> <p><code>begin</code></p> <code><p>(a/b)*b + a%b == a</p></code> <p><code>end</code></p> </pre> <p>In the floating point case, the division <code>(a/b)</code> must be converted to an <code>int</code> or <code>long</code> to remove the fraction, as in:</p> <pre> <p><code>begin</code></p> <code><p>((long)(a/b))*b + a%b == a</p></code> <p><code>end</code></p> </pre> <p>This remainder does not follow to the IEEE 754 standard. To obtain a floating point remainder as defined by IEEE 754, use the <code>IEEEremainder()</code> method of <code>java.lang.Math</code>.</p> <p>The opcodes shown in Table 14-11 perform arithmetic negation on <code>float</code> s and <code>double</code> s. Negation opcodes pop the top value from the stack, negates it, and pushes the result.</p> <p>Table 14-11. <strong> Floating-point negation </strong></p> <table border="1" style="width:100%;"> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>fneg</code></td> <td>(none)</td> <td>pops a <code>float</code>, negates it, and pushes the result</td></tr> <tr><td><code>dneg</code></td> <td>(none)</td> <td>pops a <code>double</code>, negates it, and pushes the result</td></tr> </tbody> </table> <p><i><strong> Circle of Squares: A Simulation </strong></i></p> <p>The <strong> <i>Circle of Squares</i> </strong> applet, shown in Figure 14-2, demonstrates a Java Virtual Machine executing a sequence of bytecodes that perform floating-point arithmetic. This applet is part of a web page on the CD-ROM in file <code>applets/CircleOfSquares.html</code>. The bytecode sequence in the simulation was generated by <tt> javac </tt> for the <code>squareItForever()</code> method of the class shown below:</p> <pre> <p><code>begin</code></p> <code><p/></code> <code>// On CD-ROM in file opcodes/ex1/SquareCircle.java <p>class SquareCircle {</p> <p></p> <p>static void squareItForever() {</p> <p>float f = 2;</p> <p>for (;;) {</p> <p>f *= f;</p> <p>f = 0 - f;</p> <p>}</p> <p>}</p> <p>}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>The bytecodes generated by <tt> javac </tt> for <code>squareItForever()</code> are shown below:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>0 fconst_2  // Push float constant 2. <p>1 fstore_0  // Pop to local variable 0 (float f): float f = 2;</p> <p>2 fload_0   // Push local variable 0 (float f).</p> <p>3 fload_0   // Push local variable 0 (float f).</p> <p>4 fmul      // Pop top two floats, multiply, push float result.</p> <p>5 fstore_0  // Pop to local variable 0 (float f): f *= f;</p> <p>6 fconst_0  // Push float constant 0.</p> <p>7 fload_0   // Push local variable 0 (float f).</p> <p>8 fsub      // Subtract top float from next to top float:</p> <p>// imByte = (byte) imInt;</p> <p>9 fstore_0  // Pop result to local variable 0 (float f): f = 0 - f;</p> <p>10 goto 2    // Jump back to the first fload_0 instruction:</p> <p>// for (;;) {}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>The <code>squareItForever()</code> method repeatedly squares a <code>float</code> value until it hits infinity. Each time the <code>float</code> is squared it is also negated. The <code>float</code> starts out as 2. It only takes seven iterations before infinity is reached, which isn't nearly as long as it takes in real life. The hex representation of the bits that make up the <code>float</code> are shown in the "hex value" column in the applet. The "value" column shows the number as humans are used to seeing it. This human-friendly value is generated by the <code>Float.toString()</code> method.</code></p> <p><code>To drive the <i>Circle of Squares</i> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.</code></p> <p><code><img src="images/fig14-2.gif" alt="figure 14-2"></code></p>




                    <h2 id="on_the_cd">On the CD-ROM</h2>
                    <p><code>The CD-ROM contains the source code examples from this chapter in the <code>opcodes</code> directory.</code></p> <p><code>The <i>Inner Float</i> applet is embedded in a web page on the CD-ROM in file <code>applets/InnerFloat.html</code>. The text of the web page includes several button-press sequences that demonstrate various properties of floating point numbers. The source code for this applet is found alongside its class files in the <code>applets/InnerFloat</code> directory.</code></p> <p><code>The <i>Circle of Squares</i> applet is in a web page on the CD-ROM in file <code>applets/CircleOfSquares.html</code>. The source code for this applet is found alongside its class files, in the <code>applets/JVMSimulators</code> and <code>applets/JVMSimulators/COM/artima/jvmsim</code> directories.</code></p>

                    <h2 id="resources_page">The Resources Page</h2>
                    <p><code>For more information about the material presented in this chapter, visit the resources page: <code>https://www.artima.com/insidejvm/ed2/float.html</code>.</code></p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="13.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="15.html">Next page</a>
                </div>
            </div>
            <hr/>
        </div>

    </div>

</div>

</body>
</html>


