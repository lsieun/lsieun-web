<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Appendix A. Instruction Set by Opcode Mnemonic | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>Appendix A. Instruction Set by Opcode Mnemonic</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="20.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="22.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr> <h2> Instruction Set by Opcode Mnemonic </h2> <p>Appendix A lists Java Virtual Machine instructions in alphabetical order by opcode mnemonic. All 201 instructions that may legally appear in the bytecode streams stored in Java class files are described in detail in Appendix A.</p> <p>Besides the opcodes for the 201 instructions that may appear in class files, the Java Virtual Machine specification describes two other families of opcodes: the reserved opcodes and the " <code>_quick</code> " opcodes. None of these opcodes can legally appear in the bytecode streams of Java class files.</p> <p>The Java Virtual Machine specification lists three reserved opcodes, which are shown in Table A-1. These opcodes are reserved for internal use by Java Virtual Machine  implementations  and tools. The specification  guarantees  that these three opcodes will not be part of any future extension of the Java Virtual Machine's instruction set. As you may have guessed, the intended purpose of the <code>breakpoint</code> opcode is to provide a way for  debuggers  to implement breakpoints. The intended purpose of the other two reserved opcodes, <code>impdep1</code> and <code>impdep2</code>, is to serve as "back doors" to implementation-dependent software functionality or "traps" to implementation-dependent hardware functionality.</p> <p>Table A-1. The reserved opcodes</p> <table> <tbody> <tr><td><strong> mnemonic </strong></td> <td><strong> byte value </strong></td></tr> <tr><td><code>breakpoint</code></td> <td>202 (0xca)</td></tr> <tr><td><code>impdep1</code></td> <td>254 (0xfe)</td></tr> <tr><td><code>impdep2</code></td> <td>255 (0xff)</td></tr> </tbody> </table> <p>The Java Virtual Machine specification also lists 25 " <code>_quick</code> " opcodes, which Sun's virtual machine implementation uses internally to speed up the interpreted execution of bytecodes. This optimization technique is described in general in this book in Chapter 8, "The Linking Model," but the individual " <code>_quick</code> " instructions are not described in detail in Appendix A. (The " <code>_quick</code> " opcodes do appear in Appendix C, which lists their  mnemonics  and corresponding opcode byte values.) Like the reserved opcodes, the " <code>_quick</code> " opcodes may not legally appear in Java class files. But unlike the reserved opcodes, the Java Virtual Machine specification  leaves   open  the possibility that these opcodes will take on new meanings in future extensions of the instruction set.</p> <p>For each instruction listed in Appendix A, you will find the following information:</p> <ul> <li>the mnemonic </li> <li>a short description </li> <li>the opcode's byte value in decimal and hex </li> <li>the format of the instruction </li> <li>the operand stack before and after the instruction is executed </li> <li>a description of any constraints associated with the instruction </li> <li>a description of the execution of the instruction </li> <li>a description of any exceptions or errors that may be thrown by the instruction </li> </ul> <p>The format of each instruction appears as a list of comma-separated items  next  to the label "Instruction Format," with each item representing one byte in the bytecode stream. The opcode mnemonic appears first (in fixed-width font), followed by any operands (shown in italics).</p> <p>For each instruction, Appendix A shows two snapshots of the operand stack. One snapshot, labelled "Before," shows the contents of the current method's operand stack just before the instruction is executed. The other snapshot, labelled "After," shows the operand stack immediately after execution of the instruction. In both snapshots, the operand stack appears as a list of comma-separated items, with each item representing one word. Although everywhere else in this book the operand stack is shown growing downwards (the top of the stack appears at the bottom of the picture), in Appendix A the operand stack is shown growing  sideways , from left to right. In each snapshot, the top of the stack is the rightmost item shown. Unaffected portions of the operand stack are shown as an elipsis, "...".</p> <p>For each instruction, the section labelled "Description" combines three kinds of information: constraints, the process of execution, and exceptions and errors. As mentioned in Chapter 3, "Security," Java Virtual Machine implementations are required to enforce at run-time certain constraints on the bytecodes of every method they execute. Whenever you see the word "must" in an instruction's description in Appendix A, you are reading about a constraint every implementation must enforce when executing the instruction. For example, the <code>goto</code> instruction, which causes an unconditional jump, may only cause a jump to another opcode of the same method. In Appendix A's description for <code>goto</code>, this constraint is stated as, "The target address <em>must</em> be the address of an opcode within the same method as the <code>goto</code> opcode."</p> <p>The designers of each individual Java Virtual Machine implementation can decide how and when to detect violations of the bytecode constraints. If any implementation detects a constraint violation, it must report the violation by throwing a <code>VerifyError</code> when (and if) the running program attempts to execute the instruction.</p> <p>In addition to describing the constraints placed on each instruction, Appendix A describes the process of executing each instruction and lists any errors or exceptions that may be thrown during the course of executing the instruction. Besides the errors and exceptions explicitly listed in the instruction descriptions, one other family of errors, subclasses of <code>VirtualMachineError</code>, can be thrown at any time as the result of executing any instruction. Four subclasses of <code>VirtualMachineError</code>, and the circumstances under which they will be thrown, are:</p> <ul> <li><code>OutOfMemoryError</code> - the virtual machine has run out of real or virtual memory, and the garbage collector can't  reclaim  enough space to enable the thread to continue. </li> <li><code>StackOverflowError</code> - a thread has exhausted its supply of memory for stack space (usually because the application has an unbounded recursion). </li> <li><code>InternalError</code> - the virtual machine has  encountered  a bug in its own implementation that  prevents  it from properly implementing the semantics of the Java language. </li> <li><code>UnknownError</code> - the virtual machine has encountered some error condition, but is unable to report the actual condition by throwing the appropriate exception or error. </li> </ul> <h3> <code>aaload</code> </h3> - Load <code>reference</code> from array <h3> Opcode: </h3> 50 (0x32) <h3> Instruction Format: </h3> <code>aaload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>iaload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>reference</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>reference</code> <em>value</em> specified by <em>index</em> and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>aaload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>aastore</code> </h3> - Store <code>reference</code> into array <h3> Opcode: </h3> 83 (0x53) <h3> Instruction Format: </h3> <code>aastore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>aaload</code> instruction, the Java Virtual Machine first pops three words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>float</code> s. The <em>index</em> word must be an <code>int</code>, and the <em>value</em> word must be a <code>reference</code>. The type of <em>value</em> must be assignment compatible with the component type of the <em>arrayref</em> array. The virtual machine stores <code>reference</code> <em>value</em> into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Else, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>. Otherwise, if the actual type of <em>value</em> is not assignment compatible with the actual type of the  components  of the <em>arrayref</em> array, the virtual machine throws <code>ArrayStoreException</code>.</p> <p>For more information about the <code>aastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>aconst_null</code> </h3> - Push <code>null</code> object reference <h3> Opcode: </h3> 1 (0x1) <h3> Instruction Format: </h3> <code>aconst_null</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., null</em></p> <h3> Description: </h3> <p>To execute the <code>aconst_null</code> instruction, the Java Virtual Machine pushes a <code>null</code> object reference onto the operand stack. (Note that the Java Virtual Machine specification does not  dictate  any actual value for <code>null</code>. The specification leaves that decision to the designers of each individual implementation.)</p> <p>For more information about the <code>aconst_null</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>aload</code> </h3> - Load <code>reference</code> from local variable <h3> Opcode: </h3> 25 (0x19) <h3> Instruction Format: </h3> <code>aload</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The <em>index</em> operand, which serves as an 8-bit unsigned index into the local  variables  of the current frame, must specify a local variable word that contains a <code>reference</code>. To execute the <code>aload</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>reference</code> contained in the local variable word specified by <em>index</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>aload</code> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</p> <p>Note also that even though the <code>astore</code> instruction may be used to pop a <code>returnAddress</code> value off the operand stack and into a local variable, the <code>aload</code> instruction cannot be used to push a <code>returnAddress</code> value back onto the operand stack. For more information about the use of <code>returnAddress</code>, see Chapter 18, "Finally Clauses."</p> <p>For more information about the <code>aload</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>aload_0</code> </h3> - Load <code>reference</code> from local variable 0 <h3> Opcode: </h3> 42 (0x2a) <h3> Instruction Format: </h3> <code>aload_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index zero must contain a <code>reference</code>. To execute the <code>aload_0</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>reference</code> <em>value</em> contained in the local variable word zero.</p> <p>Note that even though the <code>astore_0</code> instruction may be used to pop a <code>returnAddress</code> value off the operand stack and into a local variable, the <code>aload_0</code> instruction cannot be used to push a <code>returnAddress</code> value back onto the operand stack. For more information about the use of <code>returnAddress</code>, see Chapter 18, "Finally Clauses."</p> <p>For more information about the <code>aload_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>aload_1</code> </h3> - Load <code>reference</code> from local variable 1 <h3> Opcode: </h3> 43 (0x2b) <h3> Instruction Format: </h3> <code>aload_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index one must contain a <code>reference</code>. To execute the <code>aload_1</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>reference</code> <em>value</em> contained in the local variable word one.</p> <p>Note that even though the <code>astore_1</code> instruction may be used to pop a <code>returnAddress</code> value off the operand stack and into a local variable, the <code>aload_1</code> instruction cannot be used to push a <code>returnAddress</code> value back onto the operand stack. For more information about the use of <code>returnAddress</code>, see Chapter 18, "Finally Clauses."</p> <p>For more information about the <code>aload_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>aload_2</code> </h3> - Load <code>reference</code> from local variable 2 <h3> Opcode: </h3> 44 (0x2c) <h3> Instruction Format: </h3> <code>aload_2</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index two must contain a <code>reference</code>. To execute the <code>aload_2</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>reference</code> <em>value</em> contained in the local variable word two.</p> <p>Note that even though the <code>astore_2</code> instruction may be used to pop a <code>returnAddress</code> value off the operand stack and into a local variable, the <code>aload_2</code> instruction cannot be used to push a <code>returnAddress</code> value back onto the operand stack. For more information about the use of <code>returnAddress</code>, see Chapter 18, "Finally Clauses."</p> <p>For more information about the <code>aload_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>aload_3</code> </h3> - Load <code>reference</code> from local variable 3 <h3> Opcode: </h3> 45 (0x2d) <h3> Instruction Format: </h3> <code>aload_3</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index three must contain a <code>reference</code>. To execute the <code>aload_3</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>reference</code> <em>value</em> contained in the local variable word three.</p> <p>Note that even though the <code>astore_3</code> instruction may be used to pop a <code>returnAddress</code> value off the operand stack and into a local variable, the <code>aload_3</code> instruction cannot be used to push a <code>returnAddress</code> value back onto the operand stack. For more information about the use of <code>returnAddress</code>, see Chapter 18, "Finally Clauses."</p> <p>For more information about the <code>aload_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>anewarray</code> </h3> - Allocate new array of reference type components <h3> Opcode: </h3> 189 (0xbd) <h3> Instruction Format: </h3> <code>anewarray</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., count</em></p> <p>After: <em>arrayref</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>count</em>, must be an <code>int</code>. To execute the <code>anewarray</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>. The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Class_info</code> entry. If it hasn't already, the virtual machine resolves the entry. The entry may be a class, interface, or array type.</p> <p>If the resolution is successful, the Java Virtual Machine pops <em>count</em> and creates on the heap an array of  size  <em>count</em> of the reference type specified by the resolved <code>CONSTANT_Class_info</code> entry. The virtual machine initializes each array element to its default initial value ( <code>null</code> ) and pushes <em>arrayref</em>, a reference to the new array, onto the operand stack.</p> <p>As a result of executing this instruction, the Java Virtual Machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Class_info</code> entry. If resolution succeeds, but <em>count</em> is less than zero, the virtual machine throws <code>NegativeArraySizeException</code>.</p> <p>For more information about the <code>anewarray</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>areturn</code> </h3> - Return <code>reference</code> from method <h3> Opcode: </h3> 176 (0xb0) <h3> Instruction Format: </h3> <code>areturn</code> <h3> Stack: </h3> <p>Before: <em>..., objectref</em></p> <p>After: <em>[empty]</em></p> <h3> Description: </h3> <p>The return type of the returning method must be <code>reference</code>. The top word of the operand stack, <em>objectref</em>, must be a <code>reference</code> that is assignment compatible with the type represented by the returning method's descriptor. To execute the <code>areturn</code> instruction, the Java Virtual Machine pops <em>objectref</em> from the operand stack of the current frame and pushes it onto the operand stack of the invoking method's frame. The virtual machine discards any other words that may still be on the returning method's frame. If the returning method is synchronized, the monitor that was  acquired  when the method was invoked is released. The invoking method's frame is made current, and the virtual machine continues execution in the invoking method.</p> <p>For more information about  monitors , see Chapter 20, "Thread Synchronization." For more information about the <code>areturn</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>arraylength</code> </h3> - Get length of array <h3> Opcode: </h3> 190 (0xbe) <h3> Instruction Format: </h3> <code>arraylength</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref</em></p> <p>After: <em>..., length</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>arrayref</em>, must be a <code>reference</code> that points to an array. To execute the <code>arraylength</code> instruction, the Java Virtual Machine pops <em>arrayref</em> and pushes the length of the array pointed to by <em>arrayref</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>arraylength</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>astore</code> </h3> - Store <code>reference</code> or <code>returnAddress</code> into local variable <h3> Opcode: </h3> 58 (0x3a) <h3> Instruction Format: </h3> <code>astore</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <em>index</em> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The <em>value</em> on the top of the operand stack must be a <code>reference</code> or a <code>returnAddress</code>. To execute the <code>astore</code> instruction, the Java Virtual Machine pops the <code>reference</code> or <code>returnAddress</code> <em>value</em> from the top of the operand stack and stores it into the local variable word specified by <em>index</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>astore</code> instruction, to enable a <em>value</em> to be stored into a local variable specified by a 16-bit unsigned offset.</p> <p>For more information about the <code>astore</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>astore_0</code> </h3> - Store <code>reference</code> or <code>returnAddress</code> into local variable 0 <h3> Opcode: </h3> 75 (0x4b) <h3> Instruction Format: </h3> <code>astore_0</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index zero must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>reference</code> or a <code>returnAddress</code>. To execute the <code>astore_0</code> instruction, the Java Virtual Machine pops the <code>reference</code> or <code>returnAddress</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index zero.</p> <p>For more information about the <code>astore_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>astore_1</code> </h3> - Store <code>reference</code> or <code>returnAddress</code> into local variable 1 <h3> Opcode: </h3> 76 (0x4c) <h3> Instruction Format: </h3> <code>astore_1</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index one must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>reference</code> or a <code>returnAddress</code>. To execute the <code>astore_1</code> instruction, the Java Virtual Machine pops the <code>reference</code> or <code>returnAddress</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index one.</p> <p>For more information about the <code>astore_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>astore_2</code> </h3> - Store <code>reference</code> or <code>returnAddress</code> into local variable 2 <h3> Opcode: </h3> 77 (0x4d) <h3> Instruction Format: </h3> <code>astore_2</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index two must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>reference</code> or a <code>returnAddress</code>. To execute the <code>astore_2</code> instruction, the Java Virtual Machine pops the <code>reference</code> or <code>returnAddress</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index two.</p> <p>For more information about the <code>astore_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>astore_3</code> </h3> - Store <code>reference</code> or <code>returnAddress</code> into local variable 3 <h3> Opcode: </h3> 78 (0x4e) <h3> Instruction Format: </h3> <code>astore_3</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index three must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>reference</code> or a <code>returnAddress</code>. To execute the <code>astore_3</code> instruction, the Java Virtual Machine pops the <code>reference</code> or <code>returnAddress</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index three.</p> <p>For more information about the <code>astore_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>athrow</code> </h3> - Throw exception or error <h3> Opcode: </h3> 191 (0xbf) <h3> Instruction Format: </h3> <code>athrow</code> <h3> Stack: </h3> <p>Before: <em>..., objectref</em></p> <p>After <em>objectref</em></p> <p>Note that "Before" shows the operand stack of the frame  belonging  to the method containing the <code>athrow</code> instruction being executed. "After" shows the operand stack of the frame belonging to the method in which the catch clause is found, <em>if</em> a catch clause is found. If no catch clause is found, the thread exits and there are no more operand stacks for that thread.</p> <h3> Description: </h3> <p>The top word of the operand stack, <em>objectref</em>, must be a <code>reference</code> that points either to an instance of class <code>java.lang.Throwable</code> or to an instance of some subclass of <code>java.lang.Throwable</code>. To execute the <code>athrow</code> instruction, the Java Virtual Machine pops <em>objectref</em> from the operand stack. The virtual machine "throws" the exception by searching through the current method's exception table for the most recent catch clause that catches either the class of the throwable object pointed to by <em>objectref</em>, or a subclass of the throwable object's class. If the current method's exception table contains a matching entry, the virtual machine  extracts  the address of the handler to jump to from the matching exception table entry. The virtual machine pops any words remaining on the operand stack, pushes the <em>objectref</em>, sets the program counter to the handler address, and continues execution there. If the current method's exception table doesn't have a matching catch clause, the virtual machine pops the current method's entire frame and rethrows the exception in the previous method. This process repeats until either a matching catch clause is found or the stack  frames  for all the  methods  along the current thread's call stack have been popped. If no catch clause is found by this process, the current thread exits.</p> <p>If the <em>objectref</em> word is <code>null</code>, the virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>athrow</code> instruction, see Chapter 17, "Exceptions."</p> <h3> <code>baload</code> </h3> - Load <code>byte</code> or <code>boolean</code> from array <h3> Opcode: </h3> 51 (0x33) <h3> Instruction Format: </h3> <code>baload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>baload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>byte</code> s or <code>boolean</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>byte</code> or <code>boolean</code> <em>value</em> specified by <em>index</em>, sign-extends it to an <code>int</code>, and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>baload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>bastore</code> </h3> - Store into <code>byte</code> or <code>boolean</code> array <h3> Opcode: </h3> 84 (0x54) <h3> Instruction Format: </h3> <code>bastore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>bastore</code> instruction, the Java Virtual Machine first pops three words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>byte</code> s or <code>boolean</code> s. The <em>index</em> and <em>value</em> words must be <code>int</code> s. The virtual machine truncates the <code>int</code> <em>value</em> to a <code>byte</code> and stores it into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>bastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>bipush</code> </h3> - Push 8-bit signed integer <h3> Opcode: </h3> 16 (0x10) <h3> Instruction Format: </h3> <code>bipush</code>, <em>byte</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>bipush</code> instruction, the Java Virtual Machine first sign-extends operand <em>byte</em>, an 8-bit signed integer, to an <code>int</code>. The virtual machine then pushes the resulting <code>int</code> <em>value</em> onto the operand stack.</p> <p>For more information about the <code>bipush</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>caload</code> </h3> - Load <code>char</code> from array <h3> Opcode: </h3> 52 (0x34) <h3> Instruction Format: </h3> <code>caload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>caload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>char</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>char</code> <em>value</em> specified by <em>index</em>, zero-extends it to an <code>int</code>, and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>caload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>castore</code> </h3> - Store into <code>char</code> array <h3> Opcode: </h3> 85 (0x55) <h3> Instruction Format: </h3> <code>castore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>castore</code> instruction, the Java Virtual Machine first pops three words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>char</code> s. The <em>index</em> and <em>value</em> words must be <code>int</code> s. The virtual machine truncates the <code>int</code> <em>value</em> to a <code>char</code> and stores it into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>castore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>checkcast</code> </h3> - Make sure object is of given type <h3> Opcode: </h3> 192 (0xc0) <h3> Instruction Format: </h3> <code>checkcast</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> Stack: </h3> <p>Before: <em>..., objectref</em></p> <p>After: <em>..., objectref</em></p> <h3> Description: </h3> <p>The top word of the stack, <em>objectref</em>, must be a <code>reference</code>. To execute the <code>checkcast</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Class_info</code> entry. If it hasn't already, the virtual machine resolves the entry. The entry may be a class, interface, or array type. If <em>objectref</em> is <code>null</code> or if <em>objectref</em> can be cast to the resolved type, the stack remains unchanged. Otherwise, the virtual machine throws <code>ClassCastException</code>. <p>To determine whether the object pointed to by <em>objectref</em> can be cast to the resolved type, the virtual machine first determines whether the object is a class instance or array. (It can't be an interface instance, because interfaces can't be  instantiated .) If it is a class instance, and the resolved type is a class, not an interface, the object can be cast to the resolved class if the object's class is the resolved class or a subclass of the resolved class. Else, if it is a class instance, and the resolved type is an interface, not an class, the object can be cast to the resolved interface if the object's class implements the resolved interface. Otherwise, the object is an array. If the resolved type is a class, it must be <code>java.lang.Object</code>. Else, if the resolved type is an array of primitive types, the object must be an array of the same primitive type. Otherwise, the resolved type must be an array with a component type of some reference type, and the object must be an array with a component type that can be cast to the component type of the resolved array type. (Note that the dimension of an array doesn't enter into the <code>checkcast</code> check, only the component type of the array.)</p> <p>As a result of executing this instruction, the virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Class_info</code> entry. If resolution succeeds, but the resolved type cannot be cast to the resolved type, the virtual machine throws an <code>ClassCastException</code>.</p> <p>For more information about the <code>checkcast</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>d2f</code> </h3> - Convert <code>double</code> to <code>float</code> <h3> Opcode: </h3> 144 (0x90) <h3> Instruction Format: </h3> <code>d2f</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>double</code>. To execute the <code>d2f</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the operand stack, converts the <code>double</code> to a <code>float</code>, and pushes the <code>float</code> <em>result</em>.</p> <p>To convert the <code>double</code> <em>value</em> to <code>float</code>, the Java Virtual Machine first checks to see if the <em>value</em> equals NaN (Not a Number). If so, the <code>float</code> <em>result</em> is also NaN. Else, if the magnitude of the <code>double</code> <em>value</em> is too small to be represented by a <code>float</code>, the <code>float</code> <em>result</em> is a zero of the same sign. Else, if the magnitude of the <code>double</code> <em>value</em> is too large to be represented by a <code>float</code>, the <code>float</code> <em>result</em> is an infinity of the same sign. Otherwise, the virtual machine converts the <code>double</code> <em>value</em> to <code>float</code> zero using IEEE 754 round-to-  nearest  mode.</p> <p>Note that this instruction  performs  a narrowing primitive conversion. Because not all <code>double</code> values are representable by a <code>float</code>, the conversion may result in a loss of magnitude and precision.</p> <p>For more information about the <code>d2f</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>d2i</code> </h3> - Convert <code>double</code> to <code>int</code> <h3> Opcode: </h3> 142 (0x8e) <h3> Instruction Format: </h3> <code>d2i</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>double</code>. To execute the <code>d2i</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the operand stack, converts the <code>double</code> to an <code>int</code>, and pushes the <code>int</code> <em>result</em>.</p> <p>To convert the <code>double</code> <em>value</em> to <code>int</code>, the Java Virtual Machine first checks to see if the <em>value</em> equals NaN (Not a Number). If so, the <code>int</code> <em>result</em> is zero. Else, if the <code>double</code> <em>value</em> is not a positive or negative infinity, the virtual machine rounds the <em>value</em> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by an <code>int</code>, the <code>int</code> <em>result</em> is that integral value. Otherwise, the magnitude of the <code>double</code> <em>value</em> is too great be represented in an <code>int</code>. If <em>value</em> is positive, the <code>int</code> <em>result</em> is the largest positive integer representable in an <code>int</code>. If <em>value</em> is negative, the <code>int</code> <em>result</em> is the smallest negative integer representable in an <code>int</code>.</p> <p>Note that this instruction performs a narrowing primitive conversion. Because not all <code>double</code> values are representable by an <code>int</code>, the conversion may result in a loss of magnitude and precision.</p> <p>For more information about the <code>d2i</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>d2l</code> </h3> - Convert <code>double</code> to <code>long</code> <h3> Opcode: </h3> 143 (0x8f) <h3> Instruction Format: </h3> <code>d2l</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>double</code>. To execute the <code>d2l</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the operand stack, converts the <code>double</code> to a <code>long</code>, and pushes the <code>long</code> <em>result</em>.</p> <p>To convert the <code>double</code> <em>value</em> to <code>long</code>, the Java Virtual Machine first checks to see if the <em>value</em> equals NaN (Not a Number). If so, the <code>long</code> <em>result</em> is zero. Else, if the <code>double</code> <em>value</em> is not a positive or negative infinity, the virtual machine rounds the <em>value</em> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by a <code>long</code>, the <code>long</code> <em>result</em> is that integral value. Otherwise, the magnitude of the <code>double</code> <em>value</em> is too great be represented in a <code>long</code>. If <em>value</em> is positive, the <code>long</code> <em>result</em> is the largest positive integer representable in a <code>long</code>. If <em>value</em> is negative, the <code>long</code> <em>result</em> is the smallest negative integer representable in an <code>long</code>.</p> <p>Note that this instruction performs a narrowing primitive conversion. Because not all <code>double</code> values are representable by a <code>long</code>, the conversion may result in a loss of magnitude and precision.</p> <p>For more information about the <code>d2l</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>dadd</code> </h3> - Add <code>double</code> s <h3> Opcode: </h3> 99 (0x63) <h3> Instruction Format: </h3> <code>dadd</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>dadd</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, adds them, and pushes the <code>double</code> <em>result</em>. The <em>result</em> produced by the <code>dadd</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>dadd</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>daload</code> </h3> - Load <code>double</code> from array <h3> Opcode: </h3> 49 (0x31) <h3> Instruction Format: </h3> <code>daload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>To execute the <code>daload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>double</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>double</code> <em>value</em> specified by <em>index</em> and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>daload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>dastore</code> </h3> - Store into <code>double</code> array <h3> Opcode: </h3> 82 (0x52) <h3> Instruction Format: </h3> <code>dastore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>daload</code> instruction, the Java Virtual Machine first pops four words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>double</code> s. The <em>index</em> word must be an <code>int</code>, and the <em>value</em> words must be a <code>double</code>. The virtual machine stores <code>double</code> <em>value</em> into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>dastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>dcmpg</code> </h3> - Compare <code>double</code> s (1 on NaN) <h3> Opcode: </h3> 152 (0x98) <h3> Instruction Format: </h3> <code>dcmpg</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>dcmpg</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and  compares  one against the other. If <em>value1</em> equals <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> zero. Else, if <em>value1</em> is greater than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one. Otherwise, if <em>value1</em> is less than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one. If either <em>value1</em> or <em>value2</em> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one.</p> <p>The <em>result</em> produced by the <code>fcmpg</code> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <code>dcmpg</code> instruction  differs  from the the <code>dcmpl</code> instruction only in its treatment of NaN. For more information about the <code>dcmpg</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>dcmpl</code> </h3> - Compare <code>double</code> s (-1 on NaN) <h3> Opcode: </h3> 151 (0x97) <h3> Instruction Format: </h3> <code>dcmpl</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>dcmpg</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> equals <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> zero. Else, if <em>value1</em> is greater than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one. Otherwise, if <em>value1</em> is less than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one. If either <em>value1</em> or <em>value2</em> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one.</p> <p>The <em>result</em> produced by the <code>fcmpl</code> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <code>dcmpl</code> instruction differs from the the <code>dcmpg</code> instruction only in its treatment of NaN. For more information about the <code>dcmpl</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>dconst_0</code> </h3> - Push <code>double</code> constant 0.0 <h3> Opcode: </h3> 14 (0xe) <h3> Instruction Format: </h3> <code>dconst_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;0.0-word1, &lt;0.0-word2</em></p> <h3> Description: </h3> <p>To execute the <code>dconst_0</code> instruction, the Java Virtual Machine pushes the <code>double</code> constant 0.0 onto the operand stack.</p> <p>For more information about the <code>dconst_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dconst_1</code> </h3> - Push <code>double</code> constant 1.0 <h3> Opcode: </h3> 15 (0xf) <h3> Instruction Format: </h3> <code>dconst_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;1.0-word1, &lt;1.0-word2</em></p> <h3> Description: </h3> <p>To execute the <code>dconst_1</code> instruction, the Java Virtual Machine pushes the <code>double</code> constant 1.0 onto the operand stack.</p> <p>For more information about the <code>dconst_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>ddiv</code> </h3> - Divide <code>double</code> s <h3> Opcode: </h3> 111 (0x6f) <h3> Instruction Format: </h3> <code>ddiv</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>ddiv</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, divides <em>value1</em> by <em>value2</em> ( <em>value1 / value2</em> ), and pushes the <code>double</code> <em>result</em>. The <em>result</em> produced by the <code>ddiv</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>ddiv</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>dload</code> </h3> - Load <code>double</code> from local variable <h3> Opcode: </h3> 24 (0x18) <h3> Instruction Format: </h3> <code>dload</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The <em>index</em> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify the first of two consecutive local variable words that contain a <code>double</code>. To execute the <code>dload</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>double</code> contained in the two consecutive local variable words specified by <em>index</em> and <em>index + 1</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>lload</code> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</p> <p>For more information about the <code>dload</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dload_0</code> </h3> - Load <code>double</code> from local variable 0 <h3> Opcode: </h3> 38 (0x26) <h3> Instruction Format: </h3> <code>dload_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes zero and one must contain a <code>double</code>. To execute the <code>dload_0</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>double</code> <em>value</em> contained in local variable words zero and one.</p> <p>For more information about the <code>dload_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dload_1</code> </h3> - Load <code>double</code> from local variable 1 <h3> Opcode: </h3> 39 (0x27) <h3> Instruction Format: </h3> <code>dload_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes one and two must contain a <code>double</code>. To execute the <code>dload_1</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>double</code> <em>value</em> contained in local variable words one and two.</p> <p>For more information about the <code>dload_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dload_2</code> </h3> - Load <code>double</code> from local variable 2 <h3> Opcode: </h3> 40 (0x28) <h3> Instruction Format: </h3> <code>dload_2</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes two and three must contain a <code>double</code>. To execute the <code>dload_2</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>double</code> <em>value</em> contained in local variable words two and three.</p> <p>For more information about the <code>dload_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dload_3</code> </h3> - Load <code>double</code> from local variable 3 <h3> Opcode: </h3> 41 (0x29) <h3> Instruction Format: </h3> <code>dload_3</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes three and four must contain a <code>double</code>. To execute the <code>dload_3</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>double</code> <em>value</em> contained in local variable words three and four.</p> <p>For more information about the <code>dload_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dmul</code> </h3> - Multiply <code>double</code> s <h3> Opcode: </h3> 107 (0x6b) <h3> Instruction Format: </h3> <code>dmul</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>dmul</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, multiplies them, and pushes the <code>double</code> <em>result</em>. The <em>result</em> produced by the <code>dmul</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>dmul</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>dneg</code> </h3> - Negate <code>double</code> <h3> Opcode: </h3> 119 (0x77) <h3> Instruction Format: </h3> <code>dneg</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>double</code>. To execute the <code>dneg</code> instruction, the Java Virtual Machine pops <em>value</em>, negates it, and pushes the <code>double</code> <em>result</em>. The <em>result</em> produced by the <code>dneg</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>Note that the <em>result</em> produced by a <code>dneg</code> instruction is not always the same as the number that would be produced by subtracting <em>value</em> from zero with the <code>dsub</code> instruction. The range of IEEE 754 floating point  numbers  includes two zeros, a positive zero and a negative zero. When <em>value</em> is +0.0, the <em>result</em> of the <code>dneg</code> instruction is -0.0. By contrast, when subtracting +0.0 from +0.0, the <code>dsub</code> instruction yields +0.0.</p> <p>For more information about the <code>dneg</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>drem</code> </h3> - Calculate remainder of division of <code>double</code> s <h3> Opcode: </h3> 115 (0x73) <h3> Instruction Format: </h3> <code>drem</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>drem</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, calculates the remainder, and pushes the <code>double</code> <em>result</em>. The remainder equals <em>value1 - (value1 / value2) * value2</em>, where <em>value1 / value2</em> is a truncating division, rather than the rounding division required by IEEE 754.</p> <p>The behavior of <code>drem</code> is comparable to that of the C library function <code>fmod()</code>.The remainder of two <code>double</code> s can be calculated according to IEEE 754 floating point standard via the <code>IEEERemainder()</code> method of class <code>java.lang.Math</code>.</p> <p>For more information about the <code>drem</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>dreturn</code> </h3> - Return <code>double</code> from method <h3> Opcode: </h3> 175 (0xaf) <h3> Instruction Format: </h3> <code>dreturn</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>[empty]</em></p> <h3> Description: </h3> <p>The return type of the returning method must be <code>double</code>. The top two words of the operand stack must be a <code>double</code>. To execute the <code>dreturn</code> instruction, the Java Virtual Machine pops <code>double</code> <em>value</em> from the operand stack of the current frame and pushes it onto the operand stack of the invoking method's frame. The virtual machine discards any other words that may still be on the returning method's frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking method's frame is made current, and the virtual machine continues execution in the invoking method.</p> <p>For more information about monitors, see Chapter 20, "Thread Synchronization." For more information about the <code>dreturn</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>dstore</code> </h3> - Store <code>double</code> into local variable <h3> Opcode: </h3> 57 (0x39) <h3> Instruction Format: </h3> <code>dstore</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <em>index</em> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The top two words of the operand stack must be a <code>double</code>. To execute the <code>dstore</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes <em>index</em> and <em>index + 1</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>dstore</code> instruction, to enable a <em>value</em> to be stored into a local variable specified by a 16-bit unsigned offset.</p> <p>For more information about the <code>dstore</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dstore_0</code> </h3> - Store <code>double</code> into local variable 0 <h3> Opcode: </h3> 71 (0x47) <h3> Instruction Format: </h3> <code>dstore_0</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes zero and one must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>double</code>. To execute the <code>dstore_0</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes zero and one.</p> <p>For more information about the <code>dstore_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dstore_1</code> </h3> - Store <code>double</code> into local variable 1 <h3> Opcode: </h3> 72 (0x48) <h3> Instruction Format: </h3> <code>dstore_1</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes one and two must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>double</code>. To execute the <code>dstore_1</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes one and two.</p> <p>For more information about the <code>dstore_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dstore_2</code> </h3> - Store <code>double</code> into local variable 2 <h3> Opcode: </h3> 73 (0x49) <h3> Instruction Format: </h3> <code>dstore_2</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes two and three must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>double</code>. To execute the <code>dstore_2</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes two and three.</p> <p>For more information about the <code>dstore_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dstore_3</code> </h3> - Store <code>double</code> into local variable 3 <h3> Opcode: </h3> 74 (0x4a) <h3> Instruction Format: </h3> <code>dstore_3</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes three and four must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>double</code>. To execute the <code>dstore_3</code> instruction, the Java Virtual Machine pops the <code>double</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes three and four.</p> <p>For more information about the <code>dstore_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dsub</code> </h3> - Subtract <code>double</code> s <h3> Opcode: </h3> 103 (0x67) <h3> Instruction Format: </h3> <code>dsub</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>double</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>dsub</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, subtracts <em>value2</em> from <em>value1</em> ( <em>value1 - value2</em> ), and pushes the <code>double</code> <em>result</em>. The <em>result</em> produced by the <code>dsub</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>dsub</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>dup</code> </h3> - Duplicate top stack word <h3> Opcode: </h3> 89 (0x59) <h3> Instruction Format: </h3> <code>dup</code> <h3> Stack: </h3> <p>Before: <em>..., word</em></p> <p>After: <em>..., word, word</em></p> <h3> Description: </h3> <p>To execute the <code>dup</code> instruction, the Java Virtual Machine duplicates the top word of the operand stack and pushes the duplicate. This instruction can be used to duplicate any single-word value from the top of the operand stack. It must not be used to duplicate half of a dual word value ( <code>long</code> or <code>double</code> ) that occupies the top of the operand stack.</p> <p>For more information about the <code>dup</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dup_x1</code> </h3> - Duplicate top stack word and put two down <h3> Opcode: </h3> 90 (0x5a) <h3> Instruction Format: </h3> <code>dup_x1</code> <h3> Stack: </h3> <p>Before: <em>..., word2, word1</em></p> <p>After: <em>..., word1, word2, word1</em></p> <h3> Description: </h3> <p>To execute the <code>dup_x1</code> instruction, the Java Virtual Machine duplicates the top word of the operand stack and  inserts  the duplicate two words down. Both <em>word1</em> and <em>word2</em> must be single-word values.</p> <p>For more information about the <code>dup_x1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dup_x2</code> </h3> - Duplicate top stack word and put three down <h3> Opcode: </h3> 91 (0x5b) <h3> Instruction Format: </h3> <code>dup_x2</code> <h3> Stack: </h3> <p>Before: <em>..., word3, word2, word1</em></p> <p>After: <em>..., word1, word3, word2, word1</em></p> <h3> Description: </h3> <p>To execute the <code>dup_x2</code> instruction, the Java Virtual Machine duplicates the top word of the operand stack and inserts the duplicate three words down. <em>word1</em> must be a single-word value. Both <em>word2</em> and <em>word3</em> must be single-word values, or together  constitute  one dual-word value (a <code>long</code> or <code>double</code> ).</p> <p>For more information about the <code>dup_x2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dup2</code> </h3> - Duplicate top two stack words <h3> Opcode: </h3> 92 (0x5c) <h3> Instruction Format: </h3> <code>dup2</code> <h3> Stack: </h3> <p>Before: <em>..., word2, word1</em></p> <p>After: <em>..., word2, word1, word2, word1</em></p> <h3> Description: </h3> <p>To execute the <code>dup2</code> instruction, the Java Virtual Machine duplicates the top two words of the operand stack and pushes the duplicate. This instruction may be used to duplicate any dual-word value or any two single-word values that occupy the top of the operand stack. It must not be used if one single-word value and half of a dual-word value ( <code>long</code> or <code>double</code> ) occupies the top of the operand stack.</p> <p>For more information about the <code>dup2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dup2_x1</code> </h3> - Duplicate top two stack words and put three down <h3> Opcode: </h3> 93 (0x5d) <h3> Instruction Format: </h3> <code>dup2_x1</code> <h3> Stack: </h3> <p>Before: <em>..., word3, word2, word1</em></p> <p>After: <em>..., word2, word1, word3, word2, word1</em></p> <h3> Description: </h3> <p>To execute the <code>dup2_x1</code> instruction, the Java Virtual Machine duplicates the top two words of the operand stack and inserts the duplicate three words down. <em>word3</em> must be a single-word value. Both <em>word1</em> and <em>word2</em> must be single-word values, or together constitute one dual-word value (a <code>long</code> or <code>double</code> ).</p> <p>For more information about the <code>dup2_x1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>dup2_x2</code> </h3> - Duplicate top two stack words and put four down <h3> Opcode: </h3> 94 (0x5e) <h3> Instruction Format: </h3> <code>dup2_x2</code> <h3> Stack: </h3> <p>Before: <em>..., word4, word3, word2, word1</em></p> <p>After: <em>..., word2, word1, word4, word3, word2, word1</em></p> <h3> Description: </h3> <p>To execute the <code>dup2_x2</code> instruction, the Java Virtual Machine duplicates the top two words of the operand stack and inserts the duplicate four words down. <em>word3</em> must be a single-word value. Both <em>word1</em> and <em>word2</em> must be single-word values, or together constitute one dual-word value (a <code>long</code> or <code>double</code> ). Likewise, both <em>word3</em> and <em>word4</em> must be single-word values, or together constitute one dual-word value.</p> <p>For more information about the <code>dup2_x2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>f2d</code> </h3> - Convert <code>float</code> to <code>double</code> <h3> Opcode: </h3> 141 (0x8d) <h3> Instruction Format: </h3> <code>f2d</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be a <code>float</code>. To execute the <code>f2d</code> instruction, the Java Virtual Machine pops <code>float</code> <em>value</em> from the operand stack, converts the <code>float</code> to a <code>double</code>, and pushes the <code>double</code> <em>result</em>.</p> <p>Note that this instruction performs a widening primitive conversion. Because all <code>float</code> values are representable by a <code>double</code>, the conversion is exact.</p> <p>For more information about the <code>f2d</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>f2i</code> </h3> - Convert <code>float</code> to <code>int</code> <h3> Opcode: </h3> 139 (0x8b) <h3> Instruction Format: </h3> <code>f2i</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be a <code>float</code>. To execute the <code>f2i</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the operand stack, converts the <code>float</code> to an <code>int</code>, and pushes the <code>int</code> <em>result</em>.</p> <p>To convert the <code>float</code> <em>value</em> to <code>int</code>, the Java Virtual Machine first checks to see if the <em>value</em> equals NaN (Not a Number). If so, the <code>int</code> <em>result</em> is zero. Else, if the <code>float</code> <em>value</em> is not a positive or negative infinity, the virtual machine rounds the <em>value</em> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by an <code>int</code>, the <code>int</code> <em>result</em> is that integral value. Otherwise, the magnitude of the <code>float</code> <em>value</em> is too great be represented in an <code>int</code>. If <em>value</em> is positive, the <code>int</code> <em>result</em> is the largest positive integer representable in an <code>int</code>. If <em>value</em> is negative, the <code>int</code> <em>result</em> is the smallest negative integer representable in an <code>int</code>.</p> <p>Note that this instruction performs a narrowing primitive conversion. Because not all <code>float</code> values are representable by an <code>int</code>, the conversion may result in a loss of magnitude and precision.</p> <p>For more information about the <code>f2i</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>f2l</code> </h3> - Convert <code>float</code> to <code>long</code> <h3> Opcode: </h3> 140 (0x8c) <h3> Instruction Format: </h3> <code>f2l</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be a <code>float</code>. To execute the <code>f2l</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the operand stack, converts the <code>float</code> to a <code>long</code>, and pushes the <code>long</code> <em>result</em>.</p> <p>To convert the <code>float</code> <em>value</em> to <code>long</code>, the Java Virtual Machine first checks to see if the <em>value</em> equals NaN (Not a Number). If so, the <code>long</code> <em>result</em> is zero. Else, if the <code>float</code> <em>value</em> is not a positive or negative infinity, the virtual machine rounds the <em>value</em> towards zero using IEEE 754 round-towards-zero mode. If the resulting integral value can be exactly represented by a <code>long</code>, the <code>long</code> <em>result</em> is that integral value. Otherwise, the magnitude of the <code>float</code> <em>value</em> is too great be represented in a <code>long</code>. If <em>value</em> is positive, the <code>long</code> <em>result</em> is the largest positive integer representable in a <code>long</code>. If <em>value</em> is negative, the <code>int</code> <em>result</em> is the smallest negative integer representable in a <code>long</code>.</p> <p>Note that this instruction performs a narrowing primitive conversion. Because not all <code>float</code> values are representable by a <code>long</code>, the conversion may result in a loss of magnitude and precision.</p> <p>For more information about the <code>f2l</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>fadd</code> </h3> - Add <code>float</code> s <h3> Opcode: </h3> 98 (0x62) <h3> Instruction Format: </h3> <code>fadd</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>float</code> s. To execute the <code>fadd</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, adds them, and pushes the <code>float</code> <em>result</em>. The <em>result</em> produced by the <code>fadd</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>fadd</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>faload</code> </h3> - Load <code>float</code> from array <h3> Opcode: </h3> 48 (0x30) <h3> Instruction Format: </h3> <code>faload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>faload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>float</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>float</code> <em>value</em> specified by <em>index</em> and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>faload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>fastore</code> </h3> - Store into <code>float</code> array <h3> Opcode: </h3> 81 (0x51) <h3> Instruction Format: </h3> <code>fastore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>faload</code> instruction, the Java Virtual Machine first pops three words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>float</code> s. The <em>index</em> word must be an <code>int</code>, and the <em>value</em> word must be a <code>float</code>. The virtual machine stores <code>float</code> <em>value</em> into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, the virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>fastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>fcmpg</code> </h3> - Compare <code>float</code> s (1 on NaN) <h3> Opcode: </h3> 150 (0x96) <h3> Instruction Format: </h3> <code>fcmpg</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be two <code>float</code> s. To execute the <code>fcmpg</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> equals <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> zero. Else, if <em>value1</em> is greater than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one. Otherwise, if <em>value1</em> is less than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one. If either <em>value1</em> or <em>value2</em> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one.</p> <p>The <em>result</em> produced by the <code>fcmpg</code> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <code>fcmpg</code> instruction differs from the the <code>fcmpl</code> instruction only in its treatment of NaN. For more information about the <code>fcmpg</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>fcmpl</code> </h3> - Compare <code>float</code> s (-1 on NaN) <h3> Opcode: </h3> 149 (0x95) <h3> Instruction Format: </h3> <code>fcmpl</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be two <code>float</code> s. To execute the <code>fcmpl</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> equals <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> zero. Else, if <em>value1</em> is greater than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one. Otherwise, if <em>value1</em> is less than <em>value2</em>, the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one. If either <em>value1</em> or <em>value2</em> equals NaN (Not a Number), the virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one.</p> <p>The <em>result</em> produced by the <code>fcmpl</code> instruction is governed by the rules of IEEE 754 floating point arithmetic. Note that the <code>fcmpl</code> instruction differs from the the <code>fcmpg</code> instruction only in its treatment of NaN. For more information about the <code>fcmpl</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>fconst_0</code> </h3> - Push <code>float</code> constant 0.0 <h3> Opcode: </h3> 11 (0xb) <h3> Instruction Format: </h3> <code>fconst_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;0.0</em></p> <h3> Description: </h3> <p>To execute the <code>fconst_0</code> instruction, the Java Virtual Machine pushes the <code>float</code> constant 0.0 onto the operand stack.</p> <p>For more information about the <code>fconst_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fconst_1</code> </h3> - Push <code>float</code> constant 1.0 <h3> Opcode: </h3> 12 (0xc) <h3> Instruction Format: </h3> <code>fconst_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;1.0</em></p> <h3> Description: </h3> <p>To execute the <code>fconst_1</code> instruction, the Java Virtual Machine pushes the <code>float</code> constant 1.0 onto the operand stack.</p> <p>For more information about the <code>fconst_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fconst_2</code> </h3> - Push <code>float</code> constant 2.0 <h3> Opcode: </h3> 13 (0xd) <h3> Instruction Format: </h3> <code>fconst_2</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;2.0</em></p> <h3> Description: </h3> <p>To execute the <code>fconst_2</code> instruction, the Java Virtual Machine pushes the <code>float</code> constant 2.0 onto the operand stack.</p> <p>For more information about the <code>fconst_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fdiv</code> </h3> - Divide <code>float</code> s <h3> Opcode: </h3> 110 (0x6e) <h3> Instruction Format: </h3> <code>fdiv</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>float</code> s. To execute the <code>fdiv</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, divides <em>value1</em> by <em>value2</em> ( <em>value1 / value2</em> ), and pushes the <code>float</code> <em>result</em>. The <em>result</em> produced by the <code>fdiv</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>fdiv</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>fload</code> </h3> - Load <code>float</code> from local variable <h3> Opcode: </h3> 23 (0x17) <h3> Instruction Format: </h3> <code>fload</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The <em>index</em> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify a local variable word that contains an <code>float</code>. To execute the <code>fload</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>float</code> contained in the local variable word specified by <em>index</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>fload</code> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</p> <p>For more information about the <code>fload</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fload_0</code> </h3> - Load <code>float</code> from local variable 0 <h3> Opcode: </h3> 34 (0x22) <h3> Instruction Format: </h3> <code>fload_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index zero must contain a <code>float</code>. To execute the <code>fload_0</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>float</code> <em>value</em> contained in local variable word zero.</p> <p>For more information about the <code>fload_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fload_1</code> </h3> - Load <code>float</code> from local variable 1 <h3> Opcode: </h3> 35 (0x23) <h3> Instruction Format: </h3> <code>fload_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index one must contain a <code>float</code>. To execute the <code>fload_1</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>float</code> <em>value</em> contained in local variable word one.</p> <p>For more information about the <code>fload_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fload_2</code> </h3> - Load <code>float</code> from local variable 2 <h3> Opcode: </h3> 36 (0x24) <h3> Instruction Format: </h3> <code>fload_2</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index two must contain a <code>float</code>. To execute the <code>fload_2</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>float</code> <em>value</em> contained in local variable word two.</p> <p>For more information about the <code>fload_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fload_3</code> </h3> - Load <code>float</code> from local variable 3 <h3> Opcode: </h3> 37 (0x25) <h3> Instruction Format: </h3> <code>fload_3</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index three must contain a <code>float</code>. To execute the <code>fload_3</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>float</code> <em>value</em> contained in local variable word three.</p> <p>For more information about the <code>fload_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fmul</code> </h3> - Multiply <code>float</code> s <h3> Opcode: </h3> 106 (0x6a) <h3> Instruction Format: </h3> <code>fmul</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>float</code> s. To execute the <code>fmul</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, multiplies them, and pushes the <code>float</code> <em>result</em>. The <em>result</em> produced by the <code>fmul</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>fmul</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>fneg</code> </h3> - Negate <code>float</code> <h3> Opcode: </h3> 118 (0x76) <h3> Instruction Format: </h3> <code>fneg</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be a <code>float</code>. To execute the <code>fneg</code> instruction, the Java Virtual Machine pops <em>value</em>, negates it, and pushes the <code>float</code> <em>result</em>. The <em>result</em> produced by the <code>fneg</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>Note that the <em>result</em> produced by an <code>fneg</code> instruction is not always the same as the number that would be produced by subtracting <em>value</em> from zero with the <code>fsub</code> instruction. The range of IEEE 754 floating point numbers includes two zeros, a positive zero and a negative zero. When <em>value</em> is +0.0, the <em>result</em> of the <code>fneg</code> instruction is -0.0. By contrast, when subtracting +0.0 from +0.0, the <code>fsub</code> instruction yields +0.0.</p> <p>For more information about the <code>fneg</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>frem</code> </h3> - Calculate remainder of division of <code>float</code> s <h3> Opcode: </h3> 114 (0x72) <h3> Instruction Format: </h3> <code>frem</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>float</code> s. To execute the <code>frem</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, calculates the remainder, and pushes the <code>float</code> <em>result</em>. The remainder equals <em>value1 - (value1 / value2) * value2</em>, where <em>value1 / value2</em> is a truncating division, rather than the rounding division required by IEEE 754.</p> <p>The behavior of <code>frem</code> is comparable to that of the C library function <code>fmod()</code>.The remainder of two <code>float</code> s can be calculated according to IEEE 754 floating point standard via the <code>IEEERemainder()</code> method of class <code>java.lang.Math</code>.</p> <p>For more information about the <code>frem</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>freturn</code> </h3> - Return <code>float</code> from method <h3> Opcode: </h3> 174 (0xae) <h3> Instruction Format: </h3> <code>freturn</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>[empty]</em></p> <h3> Description: </h3> <p>The return type of the returning method must be <code>float</code>. The top word of the operand stack, <em>value</em>, must be a <code>float</code>. To execute the <code>freturn</code> instruction, the Java Virtual Machine pops <code>float</code> <em>value</em> from the operand stack of the current frame and pushes it onto the operand stack of the invoking method's frame. The virtual machine discards any other words that may still be on the returning method's frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking method's frame is made current, and the virtual machine continues execution in the invoking method.</p> <p>For more information about monitors, see Chapter 20, "Thread Synchronization." For more information about the <code>freturn</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>fstore</code> </h3> - Store <code>float</code> into local variable <h3> Opcode: </h3> 56 (0x38) <h3> Instruction Format: </h3> <code>fstore</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <em>index</em> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The <em>value</em> on the top of the operand stack must be a <code>float</code>. To execute the <code>fstore</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the top of the operand stack and stores it into the local variable word specified by <em>index</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>fstore</code> instruction, to enable a <em>value</em> to be stored into a local variable specified by a 16-bit unsigned offset.</p> <p>For more information about the <code>fstore</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fstore_0</code> </h3> - Store <code>float</code> into local variable 0 <h3> Opcode: </h3> 67 (0x43) <h3> Instruction Format: </h3> <code>fstore_0</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index zero must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>float</code>. To execute the <code>fstore_0</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index zero.</p> <p>For more information about the <code>fstore_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fstore_1</code> </h3> - Store <code>float</code> into local variable 1 <h3> Opcode: </h3> 68 (0x44) <h3> Instruction Format: </h3> <code>fstore_1</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index one must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>float</code>. To execute the <code>fstore_1</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index one.</p> <p>For more information about the <code>fstore_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fstore_2</code> </h3> - Store <code>float</code> into local variable 2 <h3> Opcode: </h3> 69 (0x45) <h3> Instruction Format: </h3> <code>fstore_2</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index two must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>float</code>. To execute the <code>fstore_2</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index two.</p> <p>For more information about the <code>fstore_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fstore_3</code> </h3> - Store <code>float</code> into local variable 3 <h3> Opcode: </h3> 70 (0x46) <h3> Instruction Format: </h3> <code>fstore_3</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index three must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be a <code>float</code>. To execute the <code>fstore_3</code> instruction, the Java Virtual Machine pops the <code>float</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index three.</p> <p>For more information about the <code>fstore_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>fsub</code> </h3> - Subtract <code>float</code> s <h3> Opcode: </h3> 102 (0x66) <h3> Instruction Format: </h3> <code>fsub</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>float</code> s. To execute the <code>fsub</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, subtracts <em>value2</em> from <em>value1</em> ( <em>value1 - value2</em> ), and pushes the <code>float</code> <em>result</em>. The <em>result</em> produced by the <code>fsub</code> instruction is governed by the rules of IEEE 754 floating point arithmetic.</p> <p>For more information about the <code>fsub</code> instruction, see Chapter 14, "Floating Point Arithmetic."</p> <h3> <code>getfield</code> </h3> - Fetch field from object <h3> Opcode: </h3> 180 (0xb4) <h3> Instruction Format: </h3> <code>getfield</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., objectref</em></p> <p>After: <em>..., value</em></p> <p>or</p> <p>Before: <em>..., objectref</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The top word of the stack, <em>objectref</em>, must be a <code>reference</code>. To execute the <code>getfield</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Fieldref_info</code> entry. If it hasn't already, the virtual machine resolves the entry, which yields the field's width and the field's offset from the beginning of the object image. If the resolution is successful, the virtual machine pops the <em>objectref</em> and fetches the field from the object pointed to by <em>objectref</em>. If the type of the field is <code>byte</code>, <code>short</code>, or <code>char</code>, the virtual machine sign-extends the field's value to an <code>int</code> and pushes the single-word <code>int</code> <em>value</em> onto the operand stack. Else, if the type is <code>int</code>, <code>boolean</code>, <code>float</code>, or <code>reference</code>, the virtual machine pushes the single-word <em>value</em> onto the operand stack. Otherwise, the type is <code>long</code> or <code>double</code>, and the virtual machine pushes the dual-word <em>value</em> onto the operand stack. <p>As a result of executing this instruction, the virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Fieldref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Fieldref_info</code> entry, the virtual machine checks whether the field's access permission enables the current class to access the field. If the field is protected, the virtual machine makes certain the field is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <em>objectref</em> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), the virtual machine throws <code>IllegalAccessError</code>. Else, if the field exists and is accessible from the current class, but the field is static, the virtual machine throws <code>IncompatibleClassChangeError</code>. Otherwise, if <em>objectref</em> is <code>null</code>, the virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>getfield</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>getstatic</code> </h3> - Fetch static field from class <h3> Opcode: </h3> 178 (0xb2) <h3> Instruction Format: </h3> <code>getstatic</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value</em></p> <p>or</p> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>To execute the <code>getstatic</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Fieldref_info</code> entry. If it hasn't already, the virtual machine resolves the entry. If the resolution is successful, the virtual machine fetches the value of the static field. If the type of the field is <code>byte</code>, <code>short</code>, or <code>char</code>, the virtual machine sign-extends the field's value to <code>int</code> and pushes the single-word <code>int</code> <em>value</em> onto the operand stack. Else, if the type is <code>int</code>, <code>boolean</code>, <code>float</code>, or <code>reference</code> the virtual machine pushes the single-word <em>value</em> onto the operand stack. Otherwise, the type is <code>long</code> or <code>double</code>, and the virtual machine pushes the dual-word <em>value</em> onto the operand stack. <p>As a result of executing this instruction, the virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Fieldref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Fieldref_info</code> entry, the virtual machine checks whether the field's access permission enables the current class to access the field. If the field is protected, the virtual machine makes certain the field is a member of the either the current class or a superclass of the current class. If not (or if there is any other access permission problem), the virtual machine throws <code>IllegalAccessError</code>. Else, if the field exists and is accessible from the current class, but the field is not static, the virtual machine throws <code>IncompatibleClassChangeError</code>.</p> <p>For more information about the <code>getstatic</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>goto</code> </h3> - Branch always <h3> Opcode: </h3> 167 (0xa7) <h3> Instruction Format: </h3> <code>goto</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>No change</em></p> <h3> <em>Description:</em> </h3> <p><em>To execute the <code>goto</code> instruction, the Java Virtual Machine forms a signed 16-bit offset by calculating (branchbyte1 <code>8) | branchbyte2</code>.</em></p> The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>goto</code> opcode. The target address must be the address of an opcode within the same method as the <code>goto</code> opcode. The virtual machine  jumps  to the target address and continues execution there. <p>For more information about the <code>goto</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>goto_w</code> </h3> - Branch always (wide index) <h3> Opcode: </h3> 200 (0xc8) <h3> Instruction Format: </h3> <code>goto_w = 200</code>, <em>branchbyte1</em>, <em>branchbyte2</em>, <em>branchbyte3</em>, <em>branchbyte4</em> <h3> <em>Stack:</em> </h3> <p><em>No change</em></p> <h3> <em>Description:</em> </h3> <p><em>To execute the <code>goto_w</code> instruction, the Java Virtual Machine forms a signed 32-bit offset by calculating (branchbyte1 <code>24) | (branchbyte2 <code>16) | (branchbyte3</code> <code>8) | branchbyte4</code>.</em></p> The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>goto_w</code> opcode. The target address must be the address of an opcode within the same method as the <code>goto_w</code> opcode. The virtual machine jumps to the target address and continues execution there. <p>Note that despite the 32-bit offset of the <code>goto_w</code> instruction, Java methods are currently (in both the 1.0 and 1.1 releases) limited to 65,535 bytes by three items in the Java class file format: the sizes of the indexes in the <code>LineNumberTable</code> attribute, the <code>LocalVariableTable</code> attribute, and the <code>Code</code> attribute's <code>exception_table</code> item. According to the Java Virtual Machine specification, the 65,536 byte limit to Java methods may be raised in a future release. For more information about the <code>goto_w</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>i2b</code> </h3> - Convert <code>int</code> to <code>byte</code> <h3> Opcode: </h3> 145 (0x91) <h3> Instruction Format: </h3> <code>i2b</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>i2b</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack, truncates the <code>int</code> to a <code>byte</code>, sign-extends the result back to an <code>int</code>, and pushes the <code>int</code> <em>result</em>.</p> <p>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and the sign bit may change.</p> <p>For more information about the <code>i2b</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>i2c</code> </h3> - Convert <code>int</code> to <code>char</code> <h3> Opcode: </h3> 146 (0x92) <h3> Instruction Format: </h3> <code>i2c</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>i2c</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack, truncates the <code>int</code> to a <code>char</code>, zero-extends the result back to an <code>int</code>, and pushes the <code>int</code> <em>result</em>.</p> <p>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and, as the <em>result</em> is always positive, the sign bit may change.</p> <p>For more information about the <code>i2c</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>i2d</code> </h3> - Convert <code>int</code> to <code>double</code> <h3> Opcode: </h3> 135 (0x87) <h3> Instruction Format: </h3> <code>i2d</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>i2d</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack, sign-extends the <code>int</code> to a <code>double</code>, and pushes the <code>double</code> <em>result</em>.</p> <p>Note that this instruction performs a widening primitive conversion. Because all <code>int</code> values are representable by a <code>double</code>, the conversion is exact.</p> <p>For more information about the <code>i2d</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>i2f</code> </h3> - Convert <code>int</code> to <code>float</code> <h3> Opcode: </h3> 134 (0x86) <h3> Instruction Format: </h3> <code>i2f</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>i2f</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack, converts the <code>int</code> to a <code>float</code> using the IEEE round-to-nearest mode, and pushes the <code>float</code> <em>result</em>.</p> <p>Note that this instruction performs a widening primitive conversion. Because not all <code>int</code> values are exactly representable by a <code>float</code>, the conversion may result in a loss of precision.</p> <p>For more information about the <code>i2f</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>i2l</code> </h3> - Convert <code>int</code> to <code>long</code> <h3> Opcode: </h3> 133 (0x85) <h3> Instruction Format: </h3> <code>i2l</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>i2l</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack, sign-extends the <code>int</code> to a <code>long</code>, and pushes the <code>long</code> <em>result</em>.</p> <p>Note that this instruction performs a widening primitive conversion. Because all <code>int</code> values are representable by a <code>long</code>, the conversion is exact.</p> <p>For more information about the <code>i2l</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>i2s</code> </h3> - Convert <code>int</code> to <code>short</code> <h3> Opcode: </h3> 147 (0x93) <h3> Instruction Format: </h3> <code>i2s</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>i2s</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack, truncates the <code>int</code> to a <code>short</code>, sign-extends the result back to an <code>int</code>, and pushes the <code>int</code> <em>result</em>.</p> <p>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and the sign bit may change.</p> <p>For more information about the <code>i2s</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>iadd</code> </h3> - Add <code>int</code> s <h3> Opcode: </h3> 96 (0x60) <h3> Instruction Format: </h3> <code>iadd</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>iadd</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, adds them, and pushes the <code>int</code> <em>result</em>. If overflow occurs, <em>result</em> is the 32  lowest  order bits of the true mathematical result represented in a sufficiently wide two's-complement format, and the sign of <em>result</em> is different from that of the true mathematical result.</p> <p>For more information about the <code>iadd</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>iaload</code> </h3> - Load <code>int</code> from array <h3> Opcode: </h3> 46 (0x2e) <h3> Instruction Format: </h3> <code>iaload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>iaload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>int</code> s. The <em>index</em> word must be an <code>int</code>.</p> The virtual machine retrieves from the <em>arrayref</em> array the <code>int</code> <em>value</em> specified by <em>index</em> and pushes it onto the operand stack. <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array,</p> The virtual machine throws <code>ArrayIndexOutOfBoundsException</code>. <p>For more information about the <code>iaload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>iand</code> </h3> - Perform boolean AND on <code>int</code> s <h3> Opcode: </h3> 126 (0x7e) <h3> Instruction Format: </h3> <code>iand</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>iand</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, bitwise ANDs them, and pushes the <code>int</code> <em>result</em>.</p> <p>For more information about the <code>iand</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>iastore</code> </h3> - Store into <code>int</code> array <h3> Opcode: </h3> 79 (0x4f) <h3> Instruction Format: </h3> <code>iastore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>iastore</code> instruction, the Java Virtual Machine first pops three words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>int</code> s. The <em>index</em> and <em>value</em> words must be <code>int</code> s.</p> The virtual machine stores <code>int</code> <em>value</em> into the <em>arrayref</em> array location specified by <em>index</em>. <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array,</p> The virtual machine throws <code>ArrayIndexOutOfBoundsException</code>. <p>For more information about the <code>iastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>iconst_0</code> </h3> - Push <code>int</code> constant 0 <h3> Opcode: </h3> 3 (0x3) <h3> Instruction Format: </h3> <code>iconst_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., 0</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_0</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant 0 onto the operand stack.</p> <p>For more information about the <code>iconst_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iconst_1</code> </h3> - Push <code>int</code> constant 1 <h3> Opcode: </h3> 4 (0x4) <h3> Instruction Format: </h3> <code>iconst_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., 1</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_1</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant 1 onto the operand stack.</p> <p>For more information about the <code>iconst_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iconst_2</code> </h3> - Push <code>int</code> constant 2 <h3> Opcode: </h3> 5 (0x5) <h3> Instruction Format: </h3> <code>iconst_2</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., 2</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_2</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant 2 onto the operand stack.</p> <p>For more information about the <code>iconst_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iconst_3</code> </h3> - Push <code>int</code> constant 3 <h3> Opcode: </h3> 6 (0x6) <h3> Instruction Format: </h3> <code>iconst_3</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., 3</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_3</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant 3 onto the operand stack.</p> <p>For more information about the <code>iconst_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iconst_4</code> </h3> - Push <code>int</code> constant 4 <h3> Opcode: </h3> 7 (0x7) <h3> Instruction Format: </h3> <code>iconst_4</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., 4</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_4</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant 4 onto the operand stack.</p> <p>For more information about the <code>iconst_4</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iconst_5</code> </h3> - Push <code>int</code> constant 5 <h3> Opcode: </h3> 8 (0x8) <h3> Instruction Format: </h3> <code>iconst_5</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., 5</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_5</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant 5 onto the operand stack.</p> <p>For more information about the <code>iconst_5</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iconst_m1</code> </h3> - Push <code>int</code> constant -1 <h3> Opcode: </h3> 2 (0x2) <h3> Instruction Format: </h3> <code>iconst_m1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., -1</em></p> <h3> Description: </h3> <p>To execute the <code>iconst_m1</code> instruction, the Java Virtual Machine pushes the <code>int</code> constant -1 onto the operand stack.</p> <p>For more information about the <code>iconst_m1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>idiv</code> </h3> - Divide <code>int</code> s <h3> Opcode: </h3> 108 (0x6c) <h3> Instruction Format: </h3> <code>idiv</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>idiv</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, integer divides <em>value1</em> by <em>value2</em> ( <em>value1 / value2</em> ), and pushes the <code>int</code> <em>result</em>.</p> <p>Integer division rounds the magnitude of the true mathematical  quotient  towards zero to the nearest integer. If the magnitude of the denominator is greater than that of the numerator, the <code>int</code> <em>result</em> is zero. Else, with one special exception, the sign of <em>result</em> is positive if the signs of the numerator and denominator are the same, negative if they are different. The exception to this rule is when the numerator is the smallest negative integer that can be represented by an <code>int</code> and the denominator is -1. For this division, the true mathematical result is one greater than the largest positive integer that can be represented by an <code>int</code>. As a consequence, the division overflows and the result is equal to the numerator.</p> <p>If <em>value2</em> (the denominator) is zero, the Java Virtual Machine throws <code>ArithmeticException</code>.</p> <p>For more information about the <code>idiv</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>ifeq</code> </h3> - Branch if equal to 0 <h3> Opcode: </h3> 153 (0x99) <h3> Instruction Format: </h3> <code>ifeq</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ifeq</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against zero. If <em>value</em> equals zero,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifeq</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifeq</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> does not equal zero, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifeq</code> instruction. <p>For more information about the <code>ifeq</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>ifge</code> </h3> - Branch if greater than or equal to 0 <h3> Opcode: </h3> 156 (0x9c) <h3> Instruction Format: </h3> <code>ifge</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ifge</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against zero. If <em>value</em> is greater than or equal to zero,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifge</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifge</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not greater than or equal to zero, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifge</code> instruction. <p>For more information about the <code>ifge</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>ifgt</code> </h3> - Branch if greater than 0 <h3> Opcode: </h3> 157 (0x9d) <h3> Instruction Format: </h3> <code>ifgt</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ifgt</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against zero. If <em>value</em> is greater than zero,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifgt</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifgt</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not greater than zero, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifgt</code> instruction. <p>For more information about the <code>ifgt</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>ifle</code> </h3> - Branch if less than or equal to 0 <h3> Opcode: </h3> 158 (0x9e) <h3> Instruction Format: </h3> <code>ifle</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ifle</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against zero. If <em>value</em> is less than or equal to zero,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifle</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifle</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not less than or equal to zero, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifle</code> instruction. <p>For more information about the <code>ifle</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>iflt</code> </h3> - Branch if less than 0 <h3> Opcode: </h3> 155 (0x9b) <h3> Instruction Format: </h3> <code>iflt</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>iflt</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against zero. If <em>value</em> is less than zero,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>iflt</code> opcode. The target address must be the address of an opcode within the same method as the <code>iflt</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not less than zero, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>iflt</code> instruction. <p>For more information about the <code>iflt</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>ifne</code> </h3> - Branch if not equal to 0 <h3> Opcode: </h3> 154 (0x9a) <h3> Instruction Format: </h3> <code>ifne</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ifne</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against zero. If <em>value</em> does not equal zero,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifne</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifne</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> does equal zero, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifne</code> instruction. <p>For more information about the <code>ifne</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>ifnonnull</code> </h3> - Branch if not null <h3> Opcode: </h3> 199 (0xc7) <h3> Instruction Format: </h3> <code>ifnonnull</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be a <code>reference</code>. To execute the <code>ifnonnull</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against <code>null</code>. If <em>value</em> is not <code>null</code>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifnonnull</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifnonnull</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is <code>null</code>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifnonnull</code> instruction. <p>For more information about the <code>ifnonnull</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>ifnull</code> </h3> - Branch if null <h3> Opcode: </h3> 198 (0xc6) <h3> Instruction Format: </h3> <code>ifnull</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be a <code>reference</code>. To execute the <code>ifnull</code> instruction, the Java Virtual Machine pops <em>value</em> off the operand stack and compares it against <code>null</code>. If <em>value</em> is <code>null</code>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>ifnull</code> opcode. The target address must be the address of an opcode within the same method as the <code>ifnull</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not <code>null</code>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>ifnull</code> instruction. <p>For more information about the <code>ifnull</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_acmpeq</code> </h3> - Branch if object references are equal <h3> Opcode: </h3> 165 (0xa5) <h3> Instruction Format: </h3> <code>if_acmpeq</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>reference</code> s. To execute the <code>if_acmpeq</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> equals <em>value2</em> (in other words, if they both point to exactly the same object or are both <code>null</code> ),</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_acmpeq</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_acmpeq</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> does not equal <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_acmpeq</code> instruction. <p>For more information about the <code>if_acmpeq</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_acmpne</code> </h3> - Branch if object references not equal <h3> Opcode: </h3> 166 (0xa6) <h3> Instruction Format: </h3> <code>if_acmpne</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>reference</code> s. To execute the <code>if_acmpne</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> does not equal <em>value2</em> (in other words, if they don't both point to exactly the same object and they aren't both <code>null</code> ),</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_acmpne</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_acmpne</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> equals <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_acmpne</code> instruction. <p>For more information about the <code>if_acmpne</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_icmpeq</code> </h3> - Branch if <code>int</code> s equal <h3> Opcode: </h3> 159 (0x9f) <h3> Instruction Format: </h3> <code>if_icmpeq</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>if_icmpeq</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> equals <em>value2</em>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_icmpeq</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_icmpeq</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> does not equal <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_icmpeq</code> instruction. <p>For more information about the <code>if_icmpeq</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_icmpge</code> </h3> - Branch if <code>int</code> greater than or equal to other <code>int</code> <h3> Opcode: </h3> 162 (0xa2) <h3> Instruction Format: </h3> <code>if_icmpge</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>if_icmpge</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> is greater than or equal to <em>value2</em>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_icmpge</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_icmpge</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not greater than or equal to <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_icmpge</code> instruction. <p>For more information about the <code>if_icmpge</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_icmpgt</code> </h3> - Branch if <code>int</code> greater than other <code>int</code> <h3> Opcode: </h3> 163 (0xa3) <h3> Instruction Format: </h3> <code>if_icmpgt</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>if_icmpgt</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> is greater than <em>value2</em>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_icmpgt</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_icmpgt</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not greater than <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_icmpgt</code> instruction. <p>For more information about the <code>if_icmpgt</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_icmple</code> </h3> - Branch if <code>int</code> less than or equal to other <code>int</code> <h3> Opcode: </h3> 164 (0xa4) <h3> Instruction Format: </h3> <code>if_icmple</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>if_icmple</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> is less than or equal to <em>value2</em>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_icmple</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_icmple</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not less than or equal to <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_icmple</code> instruction. <p>For more information about the <code>if_icmple</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_icmplt</code> </h3> - Branch if <code>int</code> less than other <code>int</code> <h3> Opcode: </h3> 161 (0xa1) <h3> Instruction Format: </h3> <code>if_icmplt</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>if_icmplt</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> is less than <em>value2</em>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_icmplt</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_icmplt</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value</em> is not less than <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_icmplt</code> instruction. <p>For more information about the <code>if_icmplt</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>if_icmpne</code> </h3> - Branch if <code>int</code> s not equal <h3> Opcode: </h3> 160 (0xa0) <h3> Instruction Format: </h3> <code>if_icmpne</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value1, value2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>if_icmpne</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> does not equal <em>value2</em>,</p> The virtual machine forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>if_icmpne</code> opcode. The target address must be the address of an opcode within the same method as the <code>if_icmpne</code> opcode. The virtual machine jumps to the target address and continues execution there. Otherwise, if <em>value1</em> equals <em>value2</em>, The virtual machine does not take the jump. It simply continues execution at the instruction immediately following the <code>if_icmpne</code> instruction. <p>For more information about the <code>if_icmpne</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>iinc</code> </h3> - Increment <code>int</code> local variable by constant <h3> Opcode: </h3> 132 (0x84) <h3> Instruction Format: </h3> <code>iinc</code>, <em>index</em>, <em>const</em> <h3> <em>Stack:</em> </h3> <p><em>No change</em></p> <h3> <em>Description:</em> </h3> <p><em>The index operand must specify a valid 8-bit unsigned index into the local variables of the current frame. To execute the <code>iinc</code> instruction, the Java Virtual Machine adds the 8-bit signed increment const to the local variable word specified by index.</em></p> <p>Note that the <code>wide</code> instruction can precede the <code>iinc</code> instruction, to enable a local variable specified by a 16-bit unsigned offset to be incremented by a signed 16-bit constant.</p> <p>For more information about the <code>iinc</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>iload</code> </h3> - Load <code>int</code> from local variable <h3> Opcode: </h3> 21 (0x15) <h3> Instruction Format: </h3> <code>iload</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The <em>index</em> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify a local variable word that contains an <code>int</code>. To execute the <code>iload</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>int</code> <em>value</em> contained in the local variable word specified by <em>index</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>iload</code> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</p> <p>For more information about the <code>iload</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iload_0</code> </h3> - Load <code>int</code> from local variable 0 <h3> Opcode: </h3> 26 (0x1a) <h3> Instruction Format: </h3> <code>iload_0</code> <h3> Stack: </h3> <p>Before: <em>..</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index zero must contain an <code>int</code>. To execute the <code>iload_0</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>int</code> <em>value</em> contained in the local variable word zero.</p> <p>For more information about the <code>iload_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iload_1</code> </h3> - Load <code>int</code> from local variable 1 <h3> Opcode: </h3> 27 (0x1b) <h3> Instruction Format: </h3> <code>iload_1</code> <h3> Stack: </h3> <p>Before: <em>..</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index one must contain an <code>int</code>. To execute the <code>iload_1</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>int</code> contained in the local variable word one.</p> <p>For more information about the <code>iload_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iload_2</code> </h3> - Load <code>int</code> from local variable 2 <h3> Opcode: </h3> 28 (0x1c) <h3> Instruction Format: </h3> <code>iload_2</code> <h3> Stack: </h3> <p>Before: <em>..</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index two must contain an <code>int</code>. To execute the <code>iload_2</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>int</code> <em>value</em> contained in the local variable word two.</p> <p>For more information about the <code>iload_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>iload_3</code> </h3> - Load <code>int</code> from local variable 3 <h3> Opcode: </h3> 29 (0x1d) <h3> Instruction Format: </h3> <code>iload_3</code> <h3> Stack: </h3> <p>Before: <em>..</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>The local variable word at index three must contain an <code>int</code>. To execute the <code>iload_3</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>int</code> <em>value</em> contained in the local variable word three.</p> <p>For more information about the <code>iload_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>imul</code> </h3> - Multiply <code>int</code> s <h3> Opcode: </h3> 104 (0x68) <h3> Instruction Format: </h3> <code>imul</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>imul</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, multiplies them, and pushes the <code>int</code> <em>result</em>. If overflow occurs, <em>result</em> is the 32 lowest order bits of the true mathematical result represented in a sufficiently wide two's-complement format, and the sign of <em>result</em> may be different from that of the true mathematical result.</p> <p>For more information about the <code>imul</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>ineg</code> </h3> - Negate <code>int</code> <h3> Opcode: </h3> 116 (0x74) <h3> Instruction Format: </h3> <code>ineg</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ineg</code> instruction, the Java Virtual Machine pops <em>value</em>, negates it, and pushes the <code>int</code> <em>result</em>.</p> <p>The <em>result</em> produced by an <code>ineg</code> instruction is the same number that would be produced by subtracting <em>value</em> from zero with the <code>isub</code> instruction. As a consequence, when <em>value</em> is the smallest negative integer that can be represented by an <code>int</code>, the negation overflows. For this negation, the true mathematical result is one greater than the largest positive integer that can be represented by an <code>int</code>, and the actual <em>result</em> is equal to <em>value</em> with no change in sign.</p> <p>For more information about the <code>ineg</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>instanceof</code> </h3> - Determine if an object is of given type <h3> Opcode: </h3> 193 (0xc1) <h3> Instruction Format: </h3> <code>instanceof</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., objectref</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top word of the stack, <em>objectref</em>, must be a <code>reference</code>. To execute the <code>instanceof</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Class_info</code> entry. If it hasn't already, The virtual machine resolves the entry. The entry may be a class, interface, or array type. If <em>objectref</em> is not <code>null</code> and the object pointed to by <em>objectref</em> is an "instance of" the resolved type, The virtual machine pushes an <code>int</code> one <em>result</em> onto the operand stack. Otherwise, The virtual machine machine pushes an <code>int</code> zero <em>result</em> onto the operand stack. <p>To determine whether the object pointed to by <em>objectref</em> is an "instance of" the resolved type, The virtual machine first determines whether the object is a class instance or array. (It can't be an interface instance, because interfaces can't be instantiated.) If it is a class instance, and the resolved type is a class, not an interface, the object is "an instance" of the resolved class if the object's class is the resolved class or a subclass of the resolved class. Else, if it is a class instance, and the resolved type is an interface, not an class, the object is "an instance" of the resolved interface if the object's class implements the resolved interface. Otherwise, the object is an array. If the resolved type is a class, it must be <code>java.lang.Object</code>. Else, if the resolved type is an array of primitive types, the object must be an array of the same primitive type. Otherwise, the resolved type must be an array with a component type of some reference type, and the object must be an array with a component type that is an "instance of" the component type of the resolved array type. (Note that the dimension of an array doesn't enter into the <code>instanceof</code> check, only the component type of the array.)</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Class_info</code> entry.</p> <p>For more information about the <code>instanceof</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>invokeinterface</code> </h3> - Invoke interface method <h3> Opcode: </h3> 185 (0xb9) <h3> Instruction Format: </h3> <code>invokeinterface</code>, <em>indexbyte1</em>, <em>indexbyte2</em>, <em>nargs</em>, <em>0</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., objectref, [arg1, [arg2...]]</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>invokeinterface</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_InterfaceMethodref_info</code> entry. If it hasn't already, The virtual machine resolves the entry. The resolved method's descriptor must exactly match the descriptor of one of the methods declared in the resolved interface. The method must not be an instance initialization method, " <code>&lt;init&gt;</code> ", or a class initialization method, " <code>&lt;clinit&gt;</code>." <p>The <em>nargs</em> operand is an unsigned byte that indicates the number of words of parameters required by the method being invoked (including the hidden <code>this</code> reference). The operand stack must contain <em>nargs - 1</em> words of parameters and the <em>objectref</em> word. The parameter words must match the order and type of parameters required by the resolved method. The <em>objectref</em> word, the reference to the object upon which to invoke the instance method, must be a <code>reference</code>. If the resolution is successful, The virtual machine pops <em>nargs - 1</em> parameter words and <em>objectref</em>.</p> <p>To invoke the method, The virtual machine retrieves the direct reference to the instance method to invoke from a method table. It  locates  the method table for the class of object pointed to by <em>objectref</em> and searches through it for a method with a name and descriptor that matches exactly the  name  and descriptor of the resolved method. (If the object's class is an array type, The virtual machine uses the method table for class <code>java.lang.Object</code>. An array type, of course, can only implement an interface if <code>Object</code> itself implements the interface.)</p> <p>If the method is synchronized, the Java Virtual Machine, on  behalf  of the current thread, acquires the monitor associated with <em>objectref</em>.</p> <p>If the method to invoke is not native, The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current thread's Java stack. The virtual machine then places the <em>objectref</em> word and <em>nargs - 1</em> parameter words that it popped from the operand stack of the calling method's frame into the local variables of the new stack frame. It places <em>objectref</em> into local variable position zero, <em>arg1</em> into local variable position one, and so on. ( <em>objectref</em> is the hidden <code>this</code> reference passed to all instance methods.) The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</p> <p>If the method to invoke is native, The virtual machine invokes the native method in an implementation-dependent manner.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_InterfaceMethodref_info</code> entry. If no method exists in the object's class with the required name and descriptor, The virtual machine throws <code>IncompatibleClassChangeError</code>. Else, if the method exists but is static, The virtual machine throws <code>IncompatibleClassChangeError</code>. Else, if the method exists, but is not public, the virtual machine throws <code>IllegalAccessError</code>. Else, if the method is abstract, The virtual machine throws <code>AbstractMethodError</code>. Else, if the method is native and the native implementation of the method can't be loaded or linked, The virtual machine throws <code>UnsatisfiedLinkError</code>. Otherwise, if <em>objectref</em> is <code>null</code>, The virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>invokeinterface</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>invokespecial</code> </h3> - Invoke instance method with special handling for private, superclass, and instance initialization methods <h3> Opcode: </h3> 183 (0xb7) <h3> Instruction Format: </h3> <code>invokespecial</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., objectref, [arg1, [arg2...]]</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>invokespecial</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Methodref_info</code> entry. If it hasn't already, The virtual machine resolves the entry, which yields a direct reference to the method's data, including the number of words of parameters to the method, <em>nargs</em>. The resolved method's descriptor must exactly match the descriptor of one of the methods declared in the resolved class. The method must not be a class initialization method, " <code>&lt;clinit&gt;</code>." <p>The <code>invokespecial</code> instruction is used to invoke three special kinds of instance methods: superclass methods, private methods, and instance initialization methods. <code>invokespecial</code> contrasts with <code>invokevirtual</code> in the way it invokes an instance method. Whereas <code>invokevirtual</code> always selects the method to invoke at run-time based on the class of the object (dynamic binding), <code>invokespecial</code> normally (with one exception) selects the method to invoke at compile-time based on the type of the reference (static binding).</p> <p>The one exception to <code>invokespecial</code>'s pure static binding behavior occurs if</p> <p>o the resolved method is not private and is not an instance initialization method,</p> <p>o the resolved method's class is a superclass of the current method's class,</p> <p>o and the <code>ACC_SUPER</code> flag is set in the current method's class.</p> <p>In this situation, the Java Virtual Machine dynamically selects at run-time the method to invoke by finding the method in the  closest  superclass that has a descriptor that exactly matches the resolved method's descriptor, irrespective of the class of the resolved method. In the majority of cases, the class of the selected method will most likely be the class of the resolved method anyway, but it is possible that it could be some other class.</p> <p>For example, imagine you create an inheritance hierarchy of three classes: <code>Animal</code>, <code>Dog</code>, and <code>CockerSpaniel</code>. Assume class <code>Dog</code> extends class <code>Animal</code>, class <code>CockerSpaniel</code> extends class <code>Dog</code>, and that a method defined in <code>CockerSpaniel</code> uses <code>invokespecial</code> to invoke a non-private superclass method named <code>walk()</code>. Assume also that when you compiled <code>CockerSpaniel</code>, the compiler set the <code>ACC_SUPER</code> flag. In addition, assume that when you compiled <code>CockerSpaniel</code>, class <code>Animal</code> defined a <code>walk()</code> method, but <code>Dog</code> didn't. In that case, the symbolic reference from <code>CockerSpaniel</code> to the <code>walk()</code> method would give <code>Animal</code> as its class. When the <code>invokespecial</code> instruction in <code>CockerSpaniel</code>'s method is executed, The virtual machine would dynamically select and invoke <code>Animal</code>'s <code>walk()</code> method.</p> <p>Now imagine that later, you added a <code>walk()</code> method to <code>Dog</code>, and recompiled <code>Dog</code>, but didn't recompile <code>CockerSpaniel</code>. <code>CockerSpaniel</code>'s symbolic reference to the superclass <code>walk()</code> method still claims <code>Animal</code> as its class, even though there is now an implementation of <code>walk()</code> in <code>Dog</code>'s class file. Nevertheless, when the <code>invokespecial</code> instruction in <code>CockerSpaniel</code>'s method is executed, The virtual machine would dynamically select and invoke <code>Dog</code>'s implementation of the <code>walk()</code> method.</p> <p>This special (not static binding) treatment of superclass invocations was the motivation for adding the <code>ACC_SUPER</code> flag to the class <code>access_flags</code> item of class files, and for changing the name of this opcode from its original name, <code>invokenonvirtual</code>, to its current name, <code>invokespecial</code>. If the <code>CockerSpaniel</code> class of the previous example had been compiled by an old compiler that didn't set the <code>ACC_SUPER</code> flag, The virtual machine would invoke <code>Animal</code>'s implementation of <code>walk()</code> regardless of whether <code>Dog</code> declared a <code>walk()</code>. As mentioned in Chapter 6, "The Java Class File," all new Java compilers should set the <code>ACC_SUPER</code> flag in every class file they generate.</p> <p>If the resolved method is an instance initialization method, " <code>&lt;init&gt;</code>," the method must be invoked only once on each uninitialized (except to default initial values) object. In addition, an instance initialization method must be invoked on each  uninitialized  object before the first  backwards  branch. In other words, the bytecodes of a method need not call an <code>&lt;init&gt;</code> method with <code>invokespecial</code> right after a <code>new</code> instruction. Other instructions could intervene between the <code>new</code> and the <code>invokespecial</code> for the <code>&lt;init&gt;</code>, but none of those instructions may branch backwards (such as a <code>goto</code> to the beginning of the method).</p> <p>The operand stack must contain <em>nargs - 1</em> words of parameters and the <em>objectref</em> word. The parameter words must match the order and type of parameters required by the resolved method. The <em>objectref</em> word, the reference to the object upon which to invoke the instance method, must be a <code>reference</code>. If the resolution is successful, The virtual machine pops <em>nargs - 1</em> parameter words and <em>objectref</em>.</p> <p>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with <em>objectref</em>.</p> <p>If the method to invoke is not native, The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current thread's Java stack. The virtual machine then places the <em>objectref</em> word and <em>nargs - 1</em> parameter words that it popped from the operand stack of the calling method's frame into the local variables of the new stack frame. It places <em>objectref</em> into local variable position zero, <em>arg1</em> into local variable position one, and so on. ( <em>objectref</em> is the hidden <code>this</code> reference passed to all instance methods.) The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</p> <p>If the method to invoke is native, The virtual machine invokes the native method in an implementation-dependent manner.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Methodref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Methodref_info</code> entry, The virtual machine checks whether the method's access permission enables the current class to access the method. If the method is protected, The virtual machine makes certain the method is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <em>objectref</em> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), The virtual machine throws <code>IllegalAccessError</code>. Else, if the method exists and is accessible from the current class, but the method is static, The virtual machine throws <code>IncompatibleClassChangeError</code>. Else, if the method is abstract, The virtual machine throws <code>AbstractMethodError</code>. Else, if the method is native and the native implementation of the method can't be loaded or linked, The virtual machine throws <code>UnsatisfiedLinkError</code>. Otherwise, if <em>objectref</em> is <code>null</code>, The virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>invokespecial</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>invokestatic</code> </h3> - Invoke a class (static) method <h3> Opcode: </h3> 184 (0xb8) <h3> Instruction Format: </h3> <code>invokestatic</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., [arg1, [arg2...]</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>invokestatic</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Methodref_info</code> entry. If it hasn't already, The virtual machine resolves the entry, which yields a direct reference to the method's data, including the number of words of parameters to the method, <em>nargs</em>. The resolved method's descriptor must exactly match the descriptor of one of the methods declared in the resolved class. The method must not be an instance initialization method, " <code>&lt;init&gt;</code> ", or a class initialization method, " <code>&lt;clinit&gt;</code>." <p>The operand stack must contain <em>nargs</em> words of parameters. The parameter words must match the order and type of parameters required by the resolved method. If the resolution is successful, The virtual machine pops the <em>nargs</em> parameter words.</p> <p>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with the <code>Class</code> instance that represents the resolved method's class.</p> <p>If the method to invoke is not native, The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current thread's Java stack. The virtual machine then places the <em>nargs</em> parameter words that it popped from the operand stack of the calling method's frame into the local variables of the new stack frame. It places <em>arg1</em> into local variable position zero, <em>arg2</em> into local variable position one, and so on. The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</p> <p>If the method to invoke is native, The virtual machine invokes the native method in an implementation-dependent manner.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Methodref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Methodref_info</code> entry, The virtual machine checks whether the method's access permission enables the current class to access the method. If the method is protected, The virtual machine makes certain the method is a member of the either the current class or a superclass of the current class. If not (or if there is any other access permission problem), The virtual machine throws <code>IllegalAccessError</code>. Else, if the method exists and is accessible from the current class, but the method is not static, The virtual machine throws <code>IncompatibleClassChangeError</code>. Else, if the method is abstract, The virtual machine throws <code>AbstractMethodError</code>. Otherwise, if the method is native and the native implementation of the method can't be loaded or linked, The virtual machine throws <code>UnsatisfiedLinkError</code>.</p> <p>For more information about the <code>invokestatic</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>invokevirtual</code> </h3> - Invoke instance method,dispatch based on an object's class at run-time <h3> Opcode: </h3> 182 (0xb6) <h3> Instruction Format: </h3> <code>invokevirtual</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., objectref, [arg1, [arg2...]]</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>invokevirtual</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Methodref_info</code> entry. If it hasn't already, The virtual machine resolves the entry, which yields the method's method table index, <em>index</em>, and the number of words of parameters to the method, <em>nargs</em>. The resolved method's descriptor must exactly match the descriptor of one of the methods declared in the resolved class. The method must not be an instance initialization method, " <code>&lt;init&gt;</code> ", or a class initialization method, " <code>&lt;clinit&gt;</code>." <p>The operand stack must contain <em>nargs - 1</em> words of parameters and the <em>objectref</em> word. The parameter words must match the order and type of parameters required by the resolved method. The <em>objectref</em> word, the reference to the object upon which to invoke the instance method, must be a <code>reference</code>. If the resolution is successful, The virtual machine pops <em>nargs - 1</em> parameter words and <em>objectref</em>.</p> <p>To invoke the method, The virtual machine retrieves the direct reference to the instance method to invoke from a method table. It locates the method table for the class of object pointed to by <em>objectref</em> and looks up the direct reference that occupies method table position <em>index</em>. (If the object's class is an array type, The virtual machine uses the method table for class <code>java.lang.Object</code>.)</p> <p>If the method is synchronized, the Java Virtual Machine, on behalf of the current thread, acquires the monitor associated with <em>objectref</em>.</p> <p>If the method to invoke is not native, The virtual machine creates a new stack frame for the method and pushes the new stack frame onto the current thread's Java stack. The virtual machine then places the <em>objectref</em> word and <em>nargs - 1</em> parameter words that it popped from the operand stack of the calling method's frame into the local variables of the new stack frame. It places <em>objectref</em> into local variable position zero, <em>arg1</em> into local variable position one, and so on. ( <em>objectref</em> is the hidden <code>this</code> reference passed to all instance methods.) The virtual machine makes the new stack frame current, sets the program counter to the address of the first instruction in the new method, and continues execution there.</p> <p>If the method to invoke is native, The virtual machine invokes the native method in an implementation-dependent manner.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Methodref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Methodref_info</code> entry, The virtual machine checks whether the method's access permission enables the current class to access the method. If the method is protected, The virtual machine makes certain the method is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <em>objectref</em> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), The virtual machine throws <code>IllegalAccessError</code>. Else, if the method exists and is accessible from the current class, but the method is static, The virtual machine throws <code>IncompatibleClassChangeError</code>. Else, if the method is abstract, The virtual machine throws <code>AbstractMethodError</code>. Else, if the method is native and the native implementation of the method can't be loaded or linked, The virtual machine throws <code>UnsatisfiedLinkError</code>. Otherwise, if <em>objectref</em> is <code>null</code>, The virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>invokevirtual</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>ior</code> </h3> - Perform boolean OR on <code>int</code> s <h3> Opcode: </h3> 128 (0x80) <h3> Instruction Format: </h3> <code>ior</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>ior</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, bitwise ORs them, and pushes the <code>int</code> <em>result</em>.</p> <p>For more information about the <code>ior</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>irem</code> </h3> - Calculate remainder of division of <code>int</code> s <h3> Opcode: </h3> 112 (0x70) <h3> Instruction Format: </h3> <code>irem</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>irem</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, calculates the integer remainder, and pushes the <code>int</code> <em>result</em>. The integer remainder equals <em>value1 - (value1 / value2) * value2</em>.</p> <p>The <code>irem</code> instruction implements Java's remainder operator: <code>%</code>. The <code>irem</code> behaves such that the Java expression shown below is always <code>true</code>, where <code>n</code> and <code>d</code> are any two <code>int</code> s:</p> <p><code>begin</code></p> <p><code>(n/d)*d + (n%d) == n</code></p> <p><code>end</code></p> <p>This behavior means that the <em>result</em> of an <code>irem</code> instruction always takes the same sign as the numerator, which is popped off the operand stack as <em>value1</em>.</p> <p>If <em>value2</em> (the denominator) is zero, the Java Virtual Machine throws <code>ArithmeticException</code>.</p> <p>For more information about the <code>irem</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>ireturn</code> </h3> - Return <code>int</code> from method <h3> Opcode: </h3> 172 (0xac) <h3> Instruction Format: </h3> <code>ireturn</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>[empty]</em></p> <h3> Description: </h3> <p>The return type of the returning method must be <code>byte</code>, <code>short</code>, <code>int</code>, or <code>char</code>. The top word of the operand stack, <em>value</em>, must be an <code>int</code>. To execute the <code>ireturn</code> instruction, the Java Virtual Machine pops <code>int</code> <em>value</em> from the operand stack of the current frame and pushes it onto the operand stack of the invoking method's frame. The virtual machine discards any other words that may still be on the returning method's frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking method's frame is made current, and The virtual machine continues execution in the invoking method.</p> <p>For more information about the <code>ireturn</code> instruction, see Chapter 19, "Method Invocation and Return." For more information about monitors, see Chapter 20, "Thread Synchronization."</p> <h3> <code>ishl</code> </h3> - Perform left shift on <code>int</code> <h3> Opcode: </h3> 120 (0x78) <h3> Instruction Format: </h3> <code>ishl</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>ishl</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, shifts <em>value1</em> left by the number of bits specified in the 5 lowest order bits of <em>value2</em> (from 0 to 31 bit  positions  ), and pushes the <code>int</code> <em>result</em>.</p> <p>For more information about the <code>ishl</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>ishr</code> </h3> - Perform arithmetic right shift on <code>int</code> <h3> Opcode: </h3> 122 (0x7a) <h3> Instruction Format: </h3> <code>ishr</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>ishr</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, shifts <em>value1</em> right with sign extension by the number of bits specified in the 5 lowest order bits of <em>value2</em> (from 0 to 31 bit positions), and pushes the <code>int</code> <em>result</em>.</p> <p>For more information about the <code>ishr</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>istore</code> </h3> - Store <code>int</code> into local variable <h3> Opcode: </h3> 54 (0x36) <h3> Instruction Format: </h3> <code>istore</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <em>index</em> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The <em>value</em> word on the top of the operand stack must be an <code>int</code>. To execute the <code>istore</code> instruction, the Java Virtual Machine pops the <code>int</code> <em>value</em> from the top of the operand stack and stores it into the local variable word specified by <em>index</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>istore</code> instruction, to enable a <em>value</em> to be stored into a local variable specified by a 16-bit unsigned offset.</p> <p>For more information about the <code>istore</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>istore_0</code> </h3> - Store <code>int</code> into local variable 0 <h3> Opcode: </h3> 59 (0x3b) <h3> Instruction Format: </h3> <code>istore_0</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index zero must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be an <code>int</code>. To execute the <code>istore_0</code> instruction, the Java Virtual Machine pops the <code>int</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index zero.</p> <p>For more information about the <code>istore_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>istore_1</code> </h3> - Store <code>int</code> into local variable 1 <h3> Opcode: </h3> 60 (0x3c) <h3> Instruction Format: </h3> <code>istore_1</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index one must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be an <code>int</code>. To execute the <code>istore_1</code> instruction, the Java Virtual Machine pops the <code>int</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index one.</p> <p>For more information about the <code>istore_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>istore_2</code> </h3> - Store <code>int</code> into local variable 2 <h3> Opcode: </h3> 61 (0x3d) <h3> Instruction Format: </h3> <code>istore_2</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index two must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be an <code>int</code>. To execute the <code>istore_2</code> instruction, the Java Virtual Machine pops the <code>int</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index two.</p> <p>For more information about the <code>istore_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>istore_3</code> </h3> - Store <code>int</code> into local variable 3 <h3> Opcode: </h3> 62 (0x3e) <h3> Instruction Format: </h3> <code>istore_3</code> <h3> Stack: </h3> <p>Before: <em>..., value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The index three must be a valid index into the local variables of the current stack frame, and the <em>value</em> word on the top of the operand stack must be an <code>int</code>. To execute the <code>istore_3</code> instruction, the Java Virtual Machine pops the <code>int</code> <em>value</em> from the top of the operand stack and stores it into the local variable word at index three.</p> <p>For more information about the <code>istore_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>isub</code> </h3> - Subtract <code>int</code> s <h3> Opcode: </h3> 100 (0x64) <h3> Instruction Format: </h3> <code>isub</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>isub</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, subtracts <em>value2</em> from <em>value1</em> ( <em>value1 - value2</em> ), and pushes the <code>int</code> <em>result</em>. If overflow occurs, <em>result</em> is the 32 lowest order bits of the true mathematical result represented in a sufficiently wide two's-complement format, and the sign bit of <em>result</em> may be different from the true mathematical result.</p> <p>For more information about the <code>isub</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>iushr</code> </h3> - Perform logical right shift on <code>int</code> <h3> Opcode: </h3> 124 (0x7c) <h3> Instruction Format: </h3> <code>iushr</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>iushr</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, shifts <em>value1</em> right with zero extension by the number of bits specified in the 5 lowest order bits of <em>value2</em> (from 0 to 31 bit positions), and pushes the <code>int</code> <em>result</em>.</p> <p>For more information about the <code>iushr</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>ixor</code> </h3> - Perform boolean XOR on <code>int</code> s <h3> Opcode: </h3> 130 (0x82) <h3> Instruction Format: </h3> <code>ixor</code> <h3> Stack: </h3> <p>Before: <em>..., value1, value2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack, <em>value1</em> and <em>value2</em>, must be <code>int</code> s. To execute the <code>ixor</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, bitwise exclusive ORs them, and pushes the <code>int</code> <em>result</em>.</p> <p>For more information about the <code>ixor</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>jsr</code> </h3> - Jump to subroutine <h3> Opcode: </h3> 168 (0xa8) <h3> Instruction Format: </h3> <code>jsr</code>, <em>branchbyte1</em>, <em>branchbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., address</em></p> <h3> Description: </h3> <p>To execute the <code>jsr</code> instruction, the Java Virtual Machine pushes the (program counter) address of the opcode immediately following the <code>jsr</code> instruction, the <em>address</em> word, onto the operand stack.</p> The virtual machine then forms a signed 16-bit offset by calculating <em>(branchbyte1 <code>8) | branchbyte2</code></em>. It calculates a target (program counter) address by adding the calculated offset to the address of the <code>jsr</code> opcode. The target address must be the address of an opcode within the same method as the <code>jsr</code> opcode. The virtual machine jumps to the target address and continues execution there. <p>For more information about the <code>jsr</code> instruction, see Chapter 18, "Finally Clauses."</p> <h3> <code>jsr_w</code> </h3> - Jump to subroutine (wide index) <h3> Opcode: </h3> 201 (0xc9) <h3> Instruction Format: </h3> <code>jsr_w</code>, <em>branchbyte1</em>, <em>branchbyte2</em>, <em>branchbyte3</em>, <em>branchbyte4</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., address</em></p> <h3> Description: </h3> <p>To execute the <code>jsr_w</code> instruction, the Java Virtual Machine pushes the (program counter) address of the opcode immediately following the <code>jsr_w</code> instruction, the <em>address</em> word, onto the operand stack.</p> The virtual machine then forms a signed 32-bit offset by calculating <em>(branchbyte1 <code>24) | (branchbyte2 <code>16) | (branchbyte3</code> <code>8) | branchbyte4</code></em>. The virtual machine then calculates a target (program counter) address by adding the calculated offset to the address of the <code>jsr_w</code> opcode. The target address must be the address of an opcode within the same method as the <code>jsr_w</code> opcode. The virtual machine jumps to the target address and continues execution there. <p>Note that despite the 32-bit offset of the <code>jsr_w</code> instruction, Java methods are currently (in both the 1.0 and 1.1 releases) limited to 65,535 bytes by three items in the Java class file format: the sizes of the indexes in the <code>LineNumberTable</code> attribute, the <code>LocalVariableTable</code> attribute, and the <code>Code</code> attribute's <code>exception_table</code> item. According to the Java Virtual Machine specification, the 65,536 byte limit to Java methods may be raised in a future release. For more information about the <code>jsr_w</code> instruction, see Chapter 18, "Finally Clauses."</p> <h3> <code>l2d</code> </h3> - Convert <code>long</code> to <code>double</code> <h3> Opcode: </h3> 138 (0x8a) <h3> Instruction Format: </h3> <code>l2d</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>long</code>. To execute the <code>l2d</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the operand stack, converts the <code>long</code> to a <code>double</code> using the IEEE round-to-nearest mode, and pushes the <code>double</code> <em>result</em>.</p> <p>Note that this instruction performs a widening primitive conversion. Because not all <code>long</code> values are exactly representable by a <code>double</code>, the conversion may result in a loss of precision.</p> <p>For more information about the <code>l2d</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>l2f</code> </h3> - Convert <code>long</code> to <code>float</code> <h3> Opcode: </h3> 137 (0x89) <h3> Instruction Format: </h3> <code>l2f</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>long</code>. To execute the <code>l2f</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the operand stack, converts the <code>long</code> to a <code>float</code> using the IEEE round-to-nearest mode, and pushes the <code>float</code> <em>result</em>.</p> <p>Note that this instruction performs a widening primitive conversion. Because not all <code>long</code> values are exactly representable by a <code>float</code>, the conversion may result in a loss of precision.</p> <p>For more information about the <code>l2f</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>l2i</code> </h3> - Convert <code>long</code> to <code>int</code> <h3> Opcode: </h3> 136 (0x88) <h3> Instruction Format: </h3> <code>l2i</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>long</code>. To execute the <code>l2i</code> instruction, the Java Virtual Machine pops <code>long</code> <em>value</em> from the operand stack, truncates the <code>long</code> to a <code>int</code>, and pushes the <code>int</code> <em>result</em>.</p> <p>Note that this instruction performs a narrowing primitive conversion. As a result of this conversion, magnitude information may be lost and the sign bit may change.</p> <p>For more information about the <code>l2i</code> instruction, see Chapter 11, "Type Conversion."</p> <h3> <code>ladd</code> </h3> - Add <code>long</code> s <h3> Opcode: </h3> 97 (0x61) <h3> Instruction Format: </h3> <code>ladd</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>ladd</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, adds them, and pushes the <code>long</code> <em>result</em>. If overflow occurs, <em>result</em> is the 64 lowest order bits of the true mathematical result represented in a sufficiently wide two's-complement format, and the sign of <em>result</em> is different from that of the true mathematical result.</p> <p>For more information about the <code>ladd</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>laload</code> </h3> - Load <code>long</code> from array <h3> Opcode: </h3> 47 (0x2f) <h3> Instruction Format: </h3> <code>laload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>To execute the <code>laload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>long</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>long</code> <em>value</em> specified by <em>index</em> and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, The virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>laload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>land</code> </h3> - Perform boolean AND on <code>long</code> s <h3> Opcode: </h3> 127 (0x7f) <h3> Instruction Format: </h3> <code>land</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>land</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, bitwise ANDs them, and pushes the <code>long</code> <em>result</em>.</p> <p>For more information about the <code>land</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>lastore</code> </h3> - Store into <code>long</code> array <h3> Opcode: </h3> 80 (0x50) <h3> Instruction Format: </h3> <code>lastore</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index, value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>laload</code> instruction, the Java Virtual Machine first pops four words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>long</code> s. The <em>index</em> word must be an <code>int</code>, and the <em>value</em> words must be a <code>long</code>. The virtual machine stores <code>long</code> <em>value</em> into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, The virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>lastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>lcmp</code> </h3> - Compare <code>long</code> s <h3> Opcode: </h3> 148 (0x94) <h3> Instruction Format: </h3> <code>lcmp</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>lcmp</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em> off the operand stack and compares one against the other. If <em>value1</em> equals <em>value2</em>, The virtual machine pushes onto the operand stack <code>int</code> <em>result</em> zero. Else, if <em>value1</em> is greater than <em>value2</em>, The virtual machine pushes onto the operand stack <code>int</code> <em>result</em> one. Otherwise, if <em>value1</em> is less than <em>value2</em>, The virtual machine pushes onto the operand stack <code>int</code> <em>result</em> negative one.</p> <p>For more information about the <code>lcmp</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>lconst_0</code> </h3> - Push <code>long</code> constant 0 <h3> Opcode: </h3> 9 (0x9) <h3> Instruction Format: </h3> <code>lconst_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;0-word1, &lt;0-word2</em></p> <h3> Description: </h3> <p>To execute the <code>lconst_0</code> instruction, the Java Virtual Machine pushes the <code>long</code> constant 0 onto the operand stack.</p> <p>For more information about the <code>lconst_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lconst_1</code> </h3> - Push <code>long</code> constant 1 <h3> Opcode: </h3> 10 (0xa) <h3> Instruction Format: </h3> <code>lconst_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., &lt;1-word1, &lt;1-word2</em></p> <h3> Description: </h3> <p>To execute the <code>lconst_1</code> instruction, the Java Virtual Machine pushes the <code>long</code> constant 1 onto the operand stack.</p> <p>For more information about the <code>lconst_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>ldc</code> </h3> - Push item from constant pool <h3> Opcode: </h3> 18 (0x12) <h3> Instruction Format: </h3> <code>ldc</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., item</em></p> <h3> Description: </h3> <p>The <em>index</em> operand must be a valid unsigned 8-bit index into the current constant pool. To execute the <code>ldc</code> instruction, the Java Virtual Machine first looks up the constant pool entry specified by the <em>index</em> operand. At constant pool entry <em>index</em>,</p> The virtual machine must find either a <code>CONSTANT_Integer_info</code>, <code>CONSTANT_Float_info</code>, or <code>CONSTANT_String_info</code> entry. If it hasn't already, The virtual machine resolves the entry. If the entry is a <code>CONSTANT_Integer_info</code>, The virtual machine pushes the <code>int</code> value represented by the entry onto the operand stack. Else, if the entry is a <code>CONSTANT_Float_info</code>, The virtual machine pushes the <code>float</code> value represented by the entry onto the operand stack. Otherwise, the entry is a <code>CONSTANT_String_info</code> entry, and The virtual machine pushes a reference to the interned <code>String</code> object that was produced by the process of resolving the entry onto the operand stack. <p>Note that the <code>ldc_w</code> instruction performs the same function, but offers a wide (16-bit) constant pool index.</p> <p>For more information about the <code>ldc</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>ldc_w</code> </h3> - Push item from constant pool (wide index) <h3> Opcode: </h3> 19 (0x13) <h3> Instruction Format: </h3> <code>ldc_w</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., item</em></p> <h3> Description: </h3> <p>To execute the <code>ldc_w</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be either a <code>CONSTANT_Integer_info</code>, a <code>CONSTANT_Float_info</code>, or a <code>CONSTANT_String_info</code> entry. If it hasn't already, The virtual machine resolves the entry. If the entry is a <code>CONSTANT_Integer_info</code>, The virtual machine pushes the <code>int</code> value represented by the entry onto the operand stack. Else, if the entry is a <code>CONSTANT_Float_info</code>, The virtual machine pushes the <code>float</code> value it represents onto the operand stack. Otherwise, the entry is a <code>CONSTANT_String_info</code>, and The virtual machine pushes a reference to the interned <code>String</code> object that was produced by the process of resolving the entry onto the operand stack. <p>Note that the <code>ldc_w</code> instruction performs the same function as <code>ldc</code>, but offers a wide (16-bit) constant pool index as opposed to <code>ldc</code>'s 8-bit constant pool index.</p> <p>For more information about the <code>ldc_w</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>ldc2_w</code> </h3> - Push <code>long</code> or <code>double</code> from constant pool (wide index) <h3> Opcode: </h3> 20 (0x14) <h3> Instruction Format: </h3> <code>ldc2_w</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., item.word1, item.word2</em></p> <h3> Description: </h3> <p>To execute the <code>ldc2_w</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be either a <code>CONSTANT_Long_info</code> or <code>CONSTANT_Double_info</code> entry. The virtual machine resolves the entry. If the entry is a <code>CONSTANT_Long_info</code>, The virtual machine pushes the <code>long</code> value represented by the entry onto the operand stack. Otherwise, it is a <code>CONSTANT_Double_info</code> entry, and The virtual machine pushes the <code>double</code> value represented by the entry onto the operand stack. <p>Note that there is no " <code>ldc2</code> " instruction that performs the same function as <code>ldc2_w</code> but with an 8-bit constant pool index. All two-word constants must be retrieved from the constant pool with an <code>ldc2_w</code> instruction, which has a wide (16-bit) constant pool index.</p> <p>For more information about the <code>ldc2_w</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>ldiv</code> </h3> - Divide <code>long</code> s <h3> Opcode: </h3> 109 (0x6d) <h3> Instruction Format: </h3> <code>ldiv</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>ldiv</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, integer divides <em>value1</em> by <em>value2</em> ( <em>value1 / value2</em> ), and pushes the <code>long</code> <em>result</em>.</p> <p>Integer division rounds the magnitude of the true mathematical quotient towards zero to the nearest integer. If the magnitude of the denominator is greater than that of the numerator, the <code>long</code> <em>result</em> is zero. Else, with one special exception, the sign of <em>result</em> is positive if the signs of the numerator and denominator are the same, negative if they are different. The exception to this rule is when the numerator is the smallest negative integer that can be represented by a <code>long</code> and the denominator is -1. For this division, the true mathematical result is one greater than the largest positive integer that can be represented by a <code>long</code>. As a consequence, the division overflows and the result is equal to the numerator.</p> <p>If <em>value2</em> (the denominator) is zero, the Java Virtual Machine throws <code>ArithmeticException</code>.</p> <p>For more information about the <code>ldiv</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>lload</code> </h3> - Load <code>long</code> from local variable <h3> Opcode: </h3> 22 (0x16) <h3> Instruction Format: </h3> <code>lload</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The <em>index</em> operand, which serves as an 8-bit unsigned index into the local variables of the current frame, must specify the first of two consecutive local variable words that contain a <code>long</code>. To execute the <code>lload</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>long</code> contained in the two consecutive local variable words specified by <em>index</em> and <em>index + 1</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>lload</code> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</p> <p>For more information about the <code>lload</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lload_0</code> </h3> - Load <code>long</code> from local variable 0 <h3> Opcode: </h3> 30 (0x1e) <h3> Instruction Format: </h3> <code>lload_0</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes zero and one must contain a <code>long</code>. To execute the <code>lload_0</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>long</code> <em>value</em> contained in local variable words zero and one.</p> <p>For more information about the <code>lload_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lload_1</code> </h3> - Load <code>long</code> from local variable 1 <h3> Opcode: </h3> 31 (0x1f) <h3> Instruction Format: </h3> <code>lload_1</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes one and two must contain a <code>long</code>. To execute the <code>lload_1</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>long</code> <em>value</em> contained in local variable words one and two.</p> <p>For more information about the <code>lload_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lload_2</code> </h3> - Load <code>long</code> from local variable 2 <h3> Opcode: </h3> 32 (0x20) <h3> Instruction Format: </h3> <code>lload_2</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes two and three must contain a <code>long</code>. To execute the <code>lload_2</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>long</code> <em>value</em> contained in local variable words two and three.</p> <p>For more information about the <code>lload_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lload_3</code> </h3> - Load <code>long</code> from local variable 3 <h3> Opcode: </h3> 33 (0x21) <h3> Instruction Format: </h3> <code>lload_3</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>..., value.word1, value.word2</em></p> <h3> Description: </h3> <p>The two consecutive local variable words at indexes three and four must contain a <code>long</code>. To execute the <code>lload_3</code> instruction, the Java Virtual Machine pushes onto the operand stack the <code>long</code> <em>value</em> contained in local variable words three and four.</p> <p>For more information about the <code>lload_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lmul</code> </h3> - Multiply <code>long</code> s <h3> Opcode: </h3> 105 (0x69) <h3> Instruction Format: </h3> <code>lmul</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>lmul</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, multiplies them, and pushes the <code>long</code> <em>result</em>. If overflow occurs, <em>result</em> is the 64 lowest order bits of the true mathematical result represented in a sufficiently wide two's-complement format, and the sign of <em>result</em> may be different from that of the true mathematical result.</p> <p>For more information about the <code>lmul</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>lneg</code> </h3> - Negate <code>long</code> <h3> Opcode: </h3> 117 (0x75) <h3> Instruction Format: </h3> <code>lneg</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top two words of the operand stack must be a <code>long</code>, <em>value</em>. To execute the <code>lneg</code> instruction, the Java Virtual Machine pops <em>value</em>, negates it, and pushes the <code>long</code> <em>result</em>.</p> <p>The <em>result</em> produced by an <code>lneg</code> instruction is the same number that would be produced by subtracting <em>value</em> from zero with the <code>lsub</code> instruction. As a consequence, when <em>value</em> is the smallest negative integer that can be represented by an <code>long</code>, the negation overflows. For this negation, the true mathematical result is one greater than the largest positive integer that can be represented by an <code>long</code>, and the actual <em>result</em> is equal to <em>value</em> with no change in sign.</p> <p>For more information about the <code>lneg</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>lookupswitch</code> </h3> - Access jump table by key match and jump <h3> Opcode: </h3> 171 (0xab) <h3> Instruction Format: </h3> <code>lookupswitch</code>, <em>...0-3 byte pad...</em>, <em>defaultbyte1</em>, <em>defaultbyte2</em>, <em>defaultbyte3</em>, <em>defaultbyte4</em>, <em>npairs1</em>, <em>npairs2</em>, <em>npairs3</em>, <em>npairs4</em>, <em>..match-offset pairs..</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., key</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <code>lookupswitch</code> opcode is followed by zero to three bytes of padding--enough so that the byte immediately following the padding starts at an address that is a multiple of four bytes from the beginning of the method. Each padding byte is a zero. Immediately following the padding is a signed 32-bit default branch offset, <em>default</em>. Following <em>default</em> is <em>npairs</em>, a signed count of the number of case value/branch offset pairs embedded in this <code>lookupswitch instruction. The value of</code> <em>npairs</em> must be greater than or equal to zero. Following <em>npairs</em> are the case value/branch offset pairs  themselves . For each pair, the signed 32-bit case value, <em>match</em>, precedes the signed 32-bit branch offset, <em>offset</em>.</p> The virtual machine calculates all of these signed 32-bit values from the four individual bytes as <em>(byte1 <code>24) | (byte2 <code>16) | (byte3</code> <code>8) | byte4</code></em>. <p>The top word of the operand stack, <em>key</em>, must be an <code>int</code>. To execute the <code>lookupswitch instruction, the Java Virtual Machine pops</code> <em>key</em> off the operand stack and compares it to the <em>match</em> values. If the key is equal to one of the <em>match</em> values, The virtual machine calculates a target (program counter) address by adding the signed <em>offset</em> that corresponds to the matching <em>match</em> value to the address of the <code>lookupswitch</code> opcode. The target address must be the address of an opcode within the same method as the <code>lookupswitch</code> opcode. The virtual machine jumps to the target address and continues execution there.</p> <p>For more information about the <code>lookupswitch</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>lor</code> </h3> - Perform boolean OR on <code>long</code> s <h3> Opcode: </h3> 129 (0x81) <h3> Instruction Format: </h3> <code>lor</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>lor</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, bitwise ORs them, and pushes the <code>long</code> <em>result</em>.</p> <p>For more information about the <code>lor</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>lrem</code> </h3> - Calculate remainder of division of <code>long</code> s <h3> Opcode: </h3> 113 (0x71) <h3> Instruction Format: </h3> <code>lrem</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>lrem</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, calculates the integer remainder, and pushes the <code>long</code> <em>result</em>. The integer remainder equals <em>value1 - (value1 / value2) * value2</em>.</p> <p>The <code>lrem</code> instruction implements Java's remainder operator, <code>%</code>, on <code>long</code> s. The <code>lrem</code> behaves such that the Java expression shown below is always <code>true</code>, where <code>n</code> and <code>d</code> are any two <code>long</code> s:</p> <p><code>begin</code></p> <p><code>(n/d)*d + (n%d) == n</code></p> <p><code>end</code></p> <p>This behavior means that the <em>result</em> of an <code>lrem</code> instruction always takes the same sign as the numerator, which is popped off the operand stack as <em>value1</em>.</p> <p>If <em>value2</em> (the denominator) is zero, the Java Virtual Machine throws <code>ArithmeticException</code>.</p> <p>For more information about the <code>lrem</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>lreturn</code> </h3> - Return <code>long</code> from method <h3> Opcode: </h3> 173 (0xad) <h3> Instruction Format: </h3> <code>lreturn</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>[empty]</em></p> <h3> Description: </h3> <p>The return type of the returning method must be <code>long</code>. The top two words of the operand stack must be a <code>long</code>. To execute the <code>lreturn</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the operand stack of the current frame and pushes it onto the operand stack of the invoking method's frame. The virtual machine discards any other words that may still be on the returning method's frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking method's frame is made current, and The virtual machine continues execution in the invoking method.</p> <p>For more information about monitors, see Chapter 20, "Thread Synchronization." For more information about the <code>lreturn</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>lshl</code> </h3> - Perform left shift on <code>long</code> <h3> Opcode: </h3> 121 (0x79) <h3> Instruction Format: </h3> <code>lshl</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value2</em>, must be an <code>int</code>. The next two words down must be a <code>long</code>, <em>value1</em>. To execute the <code>lshl</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, shifts <em>value1</em> left by the number of bits specified in the 6 lowest order bits of <em>value2</em> (from 0 to 63 bit positions), and pushes the <code>long</code> <em>result</em>.</p> <p>For more information about the <code>lshl</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>lshr</code> </h3> - Perform arithmetic right shift on <code>long</code> <h3> Opcode: </h3> 123 (0x7b) <h3> Instruction Format: </h3> <code>lshr</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value2</em>, must be an <code>int</code>. The next two words down must be a <code>long</code>, <em>value1</em>. To execute the <code>lshr</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, shifts <em>value1</em> right with sign extension by the number of bits specified in the 6 lowest order bits of <em>value2</em> (from 0 to 63 bit positions), and pushes the <code>long</code> <em>result</em>.</p> <p>For more information about the <code>lshr</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>lstore</code> </h3> - Store <code>long</code> into local variable <h3> Opcode: </h3> 55 (0x37) <h3> Instruction Format: </h3> <code>lstore</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <em>index</em> operand must specify a valid 8-bit unsigned index into the local variables of the current frame. The top two words of the operand stack must be a <code>long</code>. To execute the <code>lstore</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes <em>index</em> and <em>index + 1</em>.</p> <p>Note that the <code>wide</code> instruction can precede the <code>lstore</code> instruction, to enable a <em>value</em> to be stored into a local variable specified by a 16-bit unsigned offset.</p> <p>For more information about the <code>lstore</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lstore_0</code> </h3> - Store <code>long</code> into local variable 0 <h3> Opcode: </h3> 63 (0x3f) <h3> Instruction Format: </h3> <code>lstore_0</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes zero and one must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>long</code>. To execute the <code>lstore_0</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes zero and one.</p> <p>For more information about the <code>lstore_0</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lstore_1</code> </h3> - Store <code>long</code> into local variable 1 <h3> Opcode: </h3> 64 (0x40) <h3> Instruction Format: </h3> <code>lstore_1</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes one and two must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>long</code>. To execute the <code>lstore_1</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes one and two.</p> <p>For more information about the <code>lstore_1</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lstore_2</code> </h3> - Store <code>long</code> into local variable 2 <h3> Opcode: </h3> 65 (0x41) <h3> Instruction Format: </h3> <code>lstore_2</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes two and three must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>long</code>. To execute the <code>lstore_2</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes two and three.</p> <p>For more information about the <code>lstore_2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lstore_3</code> </h3> - Store <code>long</code> into local variable 3 <h3> Opcode: </h3> 66 (0x42) <h3> Instruction Format: </h3> <code>lstore_3</code> <h3> Stack: </h3> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The indexes three and four must be valid indexes into the local variables of the current stack frame. The top two words on the operand stack must be a <code>long</code>. To execute the <code>lstore_3</code> instruction, the Java Virtual Machine pops the <code>long</code> <em>value</em> from the top of the operand stack and stores it into the two consecutive local variable words at indexes three and four.</p> <p>For more information about the <code>lstore_3</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>lsub</code> </h3> - Subtract <code>long</code> s <h3> Opcode: </h3> 101 (0x65) <h3> Instruction Format: </h3> <code>lsub</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>lsub</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, subtracts <em>value2</em> from <em>value1</em> ( <em>value1 - value2</em> ), and pushes the <code>long</code> <em>result</em>. If overflow occurs, <em>result</em> is the 64 lowest order bits of the true mathematical result represented in a sufficiently wide two's-complement format, and the sign bit of <em>result</em> is different from the true mathematical result.</p> <p>For more information about the <code>lsub</code> instruction, see Chapter 12, "Integer Arithmetic."</p> <h3> <code>lushr</code> </h3> - Perform logical right shift on <code>long</code> <h3> Opcode: </h3> 125 (0x7d) <h3> Instruction Format: </h3> <code>lushr</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>value2</em>, must be an <code>int</code>. The next two words down must be a <code>long</code>, <em>value1</em>. To execute the <code>lushr</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, shifts <em>value1</em> right with zero extension by the number of bits specified in the 6 lowest order bits of <em>value2</em> (from 0 to 63 bit positions), and pushes the <code>long</code> <em>result</em>.</p> <p>For more information about the <code>lushr</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>lxor</code> </h3> - Perform boolean XOR on <code>long</code> s <h3> Opcode: </h3> 131 (0x83) <h3> Instruction Format: </h3> <code>lxor</code> <h3> Stack: </h3> <p>Before: <em>..., value1.word1, value1.word2, value2.word1, value2.word2</em></p> <p>After: <em>..., result.word1, result.word2</em></p> <h3> Description: </h3> <p>The top four words of the operand stack must be two <code>long</code> s, <em>value1</em> and <em>value2</em>. To execute the <code>lxor</code> instruction, the Java Virtual Machine pops <em>value1</em> and <em>value2</em>, bitwise exclusive ORs them, and pushes the <code>long</code> <em>result</em>.</p> <p>For more information about the <code>lxor</code> instruction, see Chapter 13, "Logic."</p> <h3> <code>monitorenter</code> </h3> - Enter and acquire object monitor <h3> Opcode: </h3> 194 (0xc2) <h3> Instruction Format: </h3> <code>monitorenter</code> <h3> Stack: </h3> <p>Before: <em>..., objectref</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>objectref</em>, must be a <code>reference</code>.To execute the <code>monitorenter</code> instruction, the Java Virtual Machine pops <em>objectref</em> and, on behalf of the current thread, acquires the monitor associated with <em>objectref</em>.</p> <p>If the <em>objectref</em> word is <code>null</code>,</p> The virtual machine throws <code>NullPointerException</code>. <p>For more information about the <code>monitorenter</code> instruction, see Chapter 20, "Thread Synchronization."</p> <h3> <code>monitorexit</code> </h3> - Release and exit object monitor <h3> Opcode: </h3> 195 (0xc3) <h3> Instruction Format: </h3> <code>monitorexit</code> <h3> Stack: </h3> <p>Before: <em>..., objectref</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>objectref</em>, must be a <code>reference</code>.To execute the <code>monitorenter</code> instruction, the Java Virtual Machine pops <em>objectref</em> and, on behalf of the current thread, releases and exits the monitor associated with <em>objectref</em>.</p> <p>If the <em>objectref</em> word is <code>null</code>, The virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>monitorexit</code> instruction, see Chapter 20, "Thread Synchronization."</p> <h3> <code>multianewarray</code> </h3> - Allocate new multi-dimensional array <h3> Opcode: </h3> 197 (0xc5) <h3> Instruction Format: </h3> <code>multianewarray</code>, <em>indexbyte1</em>, <em>indexbyte2</em>, <em>dimensions</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., count1, [count2,...]</em></p> <p>After: <em>arrayref</em></p> <h3> Description: </h3> <p>The <em>dimensions</em> operand, an unsigned byte that indicates the number of dimensions in the array to create, must be greater than or equal to one. The top <em>dimensions</em> words of the operand stack, <em>count1, [count2,...]</em>, must contain <code>int</code> s that have nonnegative values. Each of these words gives the number of elements in one dimension of the array. For example, consider an array declared as:</p> <p><code>begin cc</code>.</p> <p><code>int[][][] example = new int[3][4][5];</code></p> <p><code>end</code></p> <p>For this array, <em>dimensions</em> would be equal to three and the operand stack would contain three "count" words. The <em>count1</em> word would be three, <em>count2</em> four, and <em>count3</em> five.</p> <p>To execute the <code>multianewarray</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Class_info</code> entry. If it hasn't already, The virtual machine resolves the entry. The entry must be an array type of dimensionality greater than or equal to <em>dimensions</em>. <p>If the resolution is successful, the Java Virtual Machine creates the <em>dimensions</em> -dimensional array on the heap. The virtual machine initializes the elements of the first-dimension array with references to the second-dimension arrays; it initializes the elements of each of the second-dimension array with references to the third-dimension arrays, and so on. The virtual machine initializes the elements of the last-dimension arrays with their default initial values. Lastly, the Java Virtual Machine pushes a reference to the new <em>dimensions</em> -dimensional array onto the operand stack.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Class_info</code> entry. If resolution succeeds and the array's component type is a reference type, but the current class does not have permission to access that reference type, The virtual machine throws <code>IllegalAccessError</code>. Otherwise, if any of the counts popped off of the operand stack have a negative value, the Java Virtual Machine throws <code>NegativeArraySizeException</code>.</p> <p>Note that the dimensionality of the array type specified in the resolved <code>CONSTANT_Class_info</code> entry need not be equal to the <em>dimensions</em> operand--it can also be greater than <em>dimensions</em>. For example, the name of the array class for a three-dimensional array of <code>int</code> s is " <code>[[[I</code>." The actual constant pool entry referenced by a <code>multianewarray</code> instruction that creates a three-dimensional array of <code>int</code> s must have at least three dimensions, but may have more. For instance, resolved array types of " <code>[[[I</code>," " <code>[[[[I</code>," and " <code>[[[[[[[[I</code> " would all yield three-dimensional arrays of <code>int</code> so long as the <em>dimensions</em> operand is three. This flexibility in specifying multidimensional array types to the <code>multianewarray</code> instruction can reduce the number of entries required in the constant pool of some classes.</p> <p>For more information about the <code>multianewarray</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>new</code> </h3> - Create a new object <h3> Opcode: </h3> 187 (0xbb) <h3> Instruction Format: </h3> <code>new</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., objectref</em></p> <h3> Description: </h3> <p>To execute the <code>new</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Class_info</code> entry. If it hasn't already, The virtual machine resolves the entry. The entry must be a class type, not an interface or array type. The virtual machine  allocates  sufficient memory from the heap for the new object's image, and sets the object's instance variables to their default initial values. Lastly, The virtual machine pushes <em>objectref</em>, a reference to the new object, onto the operand stack. <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Class_info</code> entry. If resolution succeeds, but the resolved type is an interface, abstract class, or array, The virtual machine throws an <code>InstantiationError</code>. Else, if the current class doesn't have permission to access the resolved class, The virtual machine throws an <code>IllegalAccessError</code>.</p> <p>For more information about the <code>new</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>newarray</code> </h3> - Allocate new array of primitive type components <h3> Opcode: </h3> 188 (0xbc) <h3> Instruction Format: </h3> <code>newarray</code>, <em>atype</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., count</em></p> <p>After: <em>arrayref</em></p> <h3> Description: </h3> <p>The top word of the operand stack, <em>count</em>, must be an <code>int</code>. The <em>atype</em> operand, which is used to  indicate  the array type, must take one of the values shown in Table A-2. To execute the <code>newarray</code> instruction, the Java Virtual Machine pops <em>count</em> and creates on the heap an array of size <em>count</em> of the primitive type specified by <em>atype</em>.</p> The virtual machine initializes each array element to its default initial value and pushes <em>arrayref</em>, a reference to the new array, onto the operand stack. <p>Table A-2. Values for <em>atype</em></p> <p><code>2  columns</code></p> <p>Array Type <em>atype</em></p> <p><code>T_BOOLEAN</code> 4</p> <p><code>T_CHAR</code> 5</p> <p><code>T_FLOAT</code> 6</p> <p><code>T_DOUBLE</code> 7</p> <p><code>T_BYTE</code> 8</p> <p><code>T_SHORT</code> 9</p> <p><code>T_INT</code> 10</p> <p><code>T_LONG</code> 11</p> <p><code>end table</code></p> <p>If <em>count</em> is less than zero, the Java Virtual Machine throws <code>NegativeArraySizeException</code>.</p> <p>For more information about the <code>newarray</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>nop</code> </h3> - Do nothing <h3> Opcode: </h3> 0 (0x0) <h3> Instruction Format: </h3> <code>nop</code> <h3> Stack: </h3> <p>No change</p> <h3> Description: </h3> <p>To execute the <code>nop</code> instruction, the Java Virtual Machine takes a coffee break.</p> <p>For more information about the <code>nop</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>pop</code> </h3> - Pop top stack word <h3> Opcode: </h3> 87 (0x57) <h3> Instruction Format: </h3> <code>pop</code> <h3> Stack: </h3> <p>Before: <em>..., word</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>pop</code> instruction, the Java Virtual Machine pops the top word from the operand stack. This instruction can be used to pop any single-word value from the top of the operand stack. It must not be used to remove half of a dual word value ( <code>long</code> or <code>double</code> ) from the top of the operand stack.</p> <p>For more information about the <code>pop</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>pop2</code> </h3> - Pop top two stack words <h3> Opcode: </h3> 88 (0x58) <h3> Instruction Format: </h3> <code>pop2</code> <h3> Stack: </h3> <p>Before: <em>..., word2, word1</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>pop2</code> instruction, the Java Virtual Machine pops the top two words from the operand stack. This instruction can be used to pop any dual-word value from the top of the operand stack, or any two single-word values. It must not be used to remove one single-word value and half of a dual word value ( <code>long</code> or <code>double</code> ) from the top of the operand stack.</p> <p>For more information about the <code>pop2</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>putfield</code> </h3> - Set field in object <h3> Opcode: </h3> 181 (0xb5) <h3> Instruction Format: </h3> <code>putfield</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., objectref, value</em></p> <p>After: <em>...</em></p> <p>or</p> <p>Before: <em>..., objectref, value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>putfield</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Fieldref_info</code> entry. If it hasn't already, The virtual machine resolves the entry, which yields the field's width and the field's offset from the beginning of the object image. <p>The type of the single or double-word <em>value</em> occupying the top of the stack must be compatible with the descriptor of the resolved field. If the resolved field's descriptor is <code>byte</code>, <code>short</code>, <code>char</code>, <code>boolean</code>, or <code>int</code>, the type of <em>value</em> must be <code>int</code>. If the resolved field's descriptor is <code>long</code>, the type of <em>value</em> must be <code>long</code>. If the resolved field's descriptor is <code>float</code>, the type of <em>value</em> must be <code>float</code>. If the resolved field's descriptor is <code>double</code>, the type of <em>value</em> must be <code>double</code>. If the resolved field's descriptor is a reference type, the type of <em>value</em> must be <code>reference</code> and must be assignment-compatible the resolved descriptor type. The <em>objectref</em> word must be a <code>reference</code>.</p> <p>The virtual machine pops <em>value</em> and <em>objectref</em> and  assigns  <em>value</em> to the appropriate field in the object pointed to by <em>objectref</em>.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Fieldref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Fieldref_info</code> entry, The virtual machine checks whether the field's access permission enables the current class to access the field. If the field is protected, The virtual machine makes certain the field is a member of the either the current class or a superclass of the current class, and that the class of the object pointed to by <em>objectref</em> is either the current class or a subclass of the current class. If not (or if there is any other access permission problem), The virtual machine throws <code>IllegalAccessError</code>. Else, if the field exists and is accessible from the current class, but the field is static, The virtual machine throws <code>IncompatibleClassChangeError</code>. Otherwise, if <em>objectref</em> is <code>null</code>, The virtual machine throws <code>NullPointerException</code>.</p> <p>For more information about the <code>putfield</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>putstatic</code> </h3> - Set static field in class <h3> Opcode: </h3> 179 (0xb3) <h3> Instruction Format: </h3> <code>putstatic</code>, <em>indexbyte1</em>, <em>indexbyte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., value</em></p> <p>After: <em>...</em></p> <p>or</p> <p>Before: <em>..., value.word1, value.word2</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>putstatic</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the constant pool by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>.</p> The virtual machine then looks up the constant pool entry specified by the calculated index. The constant pool entry at that index must be a <code>CONSTANT_Fieldref_info</code> entry. If it hasn't already, The virtual machine resolves the entry. <p>The type of the single or double-word <em>value</em> occupying the top of the stack must be compatible with the descriptor of the resolved field. If the resolved field's descriptor is <code>byte</code>, <code>short</code>, <code>char</code>, <code>boolean</code>, or <code>int</code>, the type of <em>value</em> must be <code>int</code>. If the resolved field's descriptor is <code>long</code>, the type of <em>value</em> must be <code>long</code>. If the resolved field's descriptor is <code>float</code>, the type of <em>value</em> must be <code>float</code>. If the resolved field's descriptor is <code>double</code>, the type of <em>value</em> must be <code>double</code>. If the resolved field's descriptor is a reference type, the type of <em>value</em> must be <code>reference</code> and must be assignment-compatible the resolved descriptor type.</p> <p>The virtual machine pops and assigns <em>value</em> to the appropriate static field.</p> <p>As a result of executing this instruction, The virtual machine may throw any of the linking errors listed in Chapter 8, "The Linking Model," as possible during resolution of a <code>CONSTANT_Fieldref_info</code> entry. As part of the process of resolving the <code>CONSTANT_Fieldref_info</code> entry, The virtual machine checks whether the field's access permission enables the current class to access the field. If the field is protected, The virtual machine makes certain the field is a member of the either the current class or a superclass of the current class. If not (or if there is any other access permission problem), The virtual machine throws <code>IllegalAccessError</code>. Else, if the field exists and is accessible from the current class, but the field is not static, The virtual machine throws <code>IncompatibleClassChangeError</code>.</p> <p>For more information about the <code>putstatic</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>ret</code> </h3> - Return from subroutine <h3> Opcode: </h3> 169 (0xa9) <h3> Instruction Format: </h3> <code>ret</code>, <em>index</em> <h3> <em>Stack:</em> </h3> <p><em>No change</em></p> <h3> <em>Description:</em> </h3> <p><em>The index operand is an 8-bit unsigned offset into the local variables. The local variable word specified by index must be a <code>returnAddress</code>. To execute the <code>ret</code> instruction, the Java Virtual Machine sets the program counter to the <code>returnAddress</code> value stored in local variable index, and continues execution there. (In other words,</em></p> The virtual machine jumps to the <code>returnAddress</code>.) <p>Note that the <code>wide</code> instruction can precede the <code>ret</code> instruction, to allow a local variable to be accessed with a 16-bit unsigned offset.</p> <p>For more information about the <code>ret</code> instruction, see Chapter 18, "Finally Clauses."</p> <h3> <code>return</code> </h3> - Return ( <code>void</code> ) from method <h3> Opcode: </h3> 177 (0xb1) <h3> Instruction Format: </h3> <code>return</code> <h3> Stack: </h3> <p>Before: <em>...</em></p> <p>After: <em>[empty]</em></p> <h3> Description: </h3> <p>The return type of the returning method must be <code>void</code>.To execute the <code>return</code> instruction, the Java Virtual Machine discards any words that may still be on the returning method's frame. If the returning method is synchronized, the monitor that was acquired when the method was invoked is released. The invoking method's frame is made current, and The virtual machine continues execution in the invoking method.</p> <p>For more information about monitors, see Chapter 20, "Thread Synchronization." For more information about the <code>return</code> instruction, see Chapter 19, "Method Invocation and Return."</p> <h3> <code>saload</code> </h3> - Load <code>short</code> from array <h3> Opcode: </h3> 53 (0x35) <h3> Instruction Format: </h3> <code>saload</code> <h3> Stack: </h3> <p>Before: <em>..., arrayref, index</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>saload</code> instruction, the Java Virtual Machine first pops two words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>short</code> s. The <em>index</em> word must be an <code>int</code>. The virtual machine retrieves from the <em>arrayref</em> array the <code>short</code> <em>value</em> specified by <em>index</em>, sign-extends it to an <code>int</code>, and pushes it onto the operand stack.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, The virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>saload</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>sastore</code> </h3> - Store into <code>short</code> array <h3> Opcode: </h3> 86 (0x56) <h3> Instruction Format: </h3> <code>sastore</code> <h3> Stack: </h3> <p>Before: <em>..., array, index, value</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>To execute the <code>sastore</code> instruction, the Java Virtual Machine first pops three words from the operand stack. The <em>arrayref</em> word must be a <code>reference</code> that refers to an array of <code>short</code> s. The <em>index</em> and <em>value</em> words must be <code>int</code> s. The virtual machine truncates the <code>int</code> <em>value</em> to a <code>short</code> and stores it into the <em>arrayref</em> array location specified by <em>index</em>.</p> <p>If <em>arrayref</em> is <code>null</code>, the Java Virtual Machine throws <code>NullPointerException</code>. Otherwise, if <em>index</em> is not a legal index into the <em>arrayref</em> array, The virtual machine throws <code>ArrayIndexOutOfBoundsException</code>.</p> <p>For more information about the <code>sastore</code> instruction, see Chapter 15, "Objects and Arrays."</p> <h3> <code>sipush</code> </h3> - Push 16-bit signed integer <h3> Opcode: </h3> 17 (0x11) <h3> Instruction Format: </h3> <code>sipush</code>, <em>byte1</em>, <em>byte2</em> <h3> <em>Stack:</em> </h3> <p><em>Before:...</em></p> <p>After: <em>..., value</em></p> <h3> Description: </h3> <p>To execute the <code>sipush</code> instruction, the Java Virtual Machine first forms an intermediate 16-bit signed integer from <em>byte1</em> and <em>byte2</em> by calculating <em>(byte1 <code>8) | byte2</code></em>.</p> The virtual machine then sign-extends the intermediate 16-bit signed integer to an <code>int</code>, and pushes the resulting <code>int</code> <em>value</em> onto the operand stack. <p>For more information about the <code>sipush</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>swap</code> </h3> - Swap top two stack words <h3> Opcode: </h3> 95 (0x5f) <h3> Instruction Format: </h3> <code>swap</code> <h3> Stack: </h3> <p>Before: <em>..., word2, word1</em></p> <p>After: <em>..., word1, word2</em></p> <h3> Description: </h3> <p>To execute the <code>swap</code> instruction, the Java Virtual Machine swaps the top two words of the operand stack. Both <em>word1</em> and <em>word2</em> must be single-word values.</p> <p>For more information about the <code>swap</code> instruction, see Chapter 10, "Stack Operations."</p> <h3> <code>tableswitch</code> </h3> - Access jump table by index and jump <h3> Opcode: </h3> 170 (0xaa) <h3> Instruction Format: </h3> <code>tableswitch</code>, <em>...0-3 byte pad...</em>, <em>defaultbyte1</em>, <em>defaultbyte2</em>, <em>defaultbyte3</em>, <em>defaultbyte4</em>, <em>lowbyte1</em>, <em>lowbyte2</em>, <em>lowbyte3</em>, <em>lowbyte4</em>, <em>highbyte1</em>, <em>highbyte2</em>, <em>highbyte3</em>, <em>highbyte4</em>, <em>...jump offsets...</em> <h3> <em>Stack:</em> </h3> <p><em>Before:..., index</em></p> <p>After: <em>...</em></p> <h3> Description: </h3> <p>The <code>tableswitch</code> opcode is followed by zero to three bytes of padding--enough so that the byte immediately following the padding starts at an address that is a multiple of four bytes from the beginning of the method. Each padding byte is a zero. Immediately following the padding is a signed 32-bit default branch offset, <em>default</em>. Following <em>default</em> are two signed 32-bit endpoints of the range of case values embedded in this <code>tableswitch instruction:</code> <em>low</em>, the low endpoint, and <em>high</em>, the high endpoint <code>. The value of</code> <em>low</em> must be less than or equal to the value of <em>high</em>. Following <em>low</em> and <em>high</em> are <em>high - low + 1</em> signed 32-bit branch offsets--one branch offset for high, one for low, and one for each integer case value in between high and low. These offsets serve as a  zero-based  jump table. The branch offset for <em>low</em>, the first entry in the jump table, immediately  follows  the <em>high</em> endpoint value.</p> The virtual machine calculates all of these signed 32-bit values from the four individual bytes as <em>(byte1 <code>24) | (byte2 <code>16) | (byte3</code> <code>8) | byte4</code></em>. <p>The top word of the operand stack, <em>index</em>, must be an <code>int</code>. To execute the <code>tableswitch instruction, the Java Virtual Machine pops</code> <em>index</em> off the operand stack, compares it to <em>low</em> and <em>high</em>, and selects a branch offset. If <em>index</em> is less than <em>low</em> and greater than <em>high</em>, The virtual machine selects <em>default</em> as the branch offset. Else, The virtual machine selects the branch offset at position <em>index - low</em> in the jump table. Once it has selected a branch offset, The virtual machine calculates a target (program counter) address by adding the signed branch offset to the address of the <code>tableswitch</code> opcode. The target address must be the address of an opcode within the same method as the <code>tableswitch</code> opcode. The virtual machine jumps to the target address and continues execution there.</p> <p>For more information about the <code>tableswitch</code> instruction, see Chapter 16, "Control Flow."</p> <h3> <code>wide</code> </h3> - Extend a local variable index with additional bytes <h3> Opcode: </h3> 196 (0xc4) <h3> Instruction Format: </h3> <p><code>wide</code>, <em>&lt;opcode</em>, <em>indexbyte1</em>, <em>indexbyte2</em></p> <p>or</p> <p><code>wide</code>, <code>iinc</code>, <em>indexbyte1</em>, <em>indexbyte2</em>, <em>constbyte1</em>, <em>constbyte2</em></p> <h3> Stack: </h3> <p>To see how the stack changes when an instruction is modified by <code>wide</code>, see the entry for the unmodified instruction. The stack change for an instruction modified by <code>wide</code> is identical to the stack change for that same instruction unmodified.</p> <h3> Description: </h3> <p>The <code>wide</code> opcode modifies instructions that reference the local variables, extending the modified instruction's unsigned 8-bit local variable index to an unsigned 16-bit index. As shown above, a <code>wide</code> instruction comes in two formats. When the <code>wide</code> opcode modifies <code>iload</code>, <code>fload</code>, <code>aload</code>, <code>lload</code>, <code>dload</code>, <code>istore</code>, <code>fstore</code>, <code>astore</code>, <code>lstore</code>, <code>dstore</code>, or <code>ret</code>, the instruction has the first format. When the <code>wide</code> opcode modifies <code>iinc</code>, the instruction has the second format.</p> <p>To execute any <code>wide</code> instruction, the Java Virtual Machine first forms an unsigned 16-bit index into the local variables by calculating <em>(indexbyte1 <code>8) | indexbyte2</code></em>. Irrespective of the opcode that <code>wide</code> modifies, the calculated index must be a valid index into the local variables of the current frame. If the <code>wide</code> opcode modifies <code>lload</code>, <code>dload</code>, <code>lstore</code>, or <code>dstore</code>, then one more than the calculated index must also be a valid index into the local variables. Given a valid unsigned 16-bit (wide) local variable index, The virtual machine executes the modified instruction using the wide index.</p> <p>When a <code>wide</code> opcode modifies an <code>iinc</code> instruction, the format of the <code>iinc</code> instruction changes. An unmodified <code>iinc</code> instruction has two operands, an 8-bit unsigned local variable <em>index</em>, and an 8-bit signed increment <em>const</em>. When modified by <code>wide</code>, however, both the <code>iinc</code> instruction's local variable index and its increment are extended by an extra byte. To execute this instruction, The virtual machine forms a signed 16-bit increment by calculating <em>(constbyte1 <code>8) | constbyte2</code></em>.</p> <p>Note that from the perspective of the bytecode verifier, the opcode modified by <code>wide</code> is seen as an operand to the <code>wide</code> opcode. The bytecodes are not allowed to treat opcodes modified by <code>wide</code> independently. For example, it is illegal for a <code>goto</code> instruction to jump directly to an opcode modified by <code>wide</code>.</p> <p>For more information about the <code>wide</code> instruction, see Chapter 10, "Stack Operations."</p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="20.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="22.html">Next page</a>
                </div>
            </div>
            <hr/>

        </div>

    </div>

</div>

</body>
</html>


