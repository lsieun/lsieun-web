<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>15 Objects and Arrays | Inside the Java 2 Virtual Machine</title>
    <meta name="description" content="Inside the Java 2 Virtual Machine">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="main.css" type="text/css"/>
</head>
<body>
<div class="container">
    <div class="row">
        <div class="twelve columns">

            <div class="row test">
                <h1>15 Objects and Arrays</h1>
            </div>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="14.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="16.html">Next page</a>
                </div>
            </div>

            <div class="content index ">
                <div class="u-cf"></div>

                <div class="waka">
                    <hr/>
                    <ul>
                        <li><a href="#on_the_cd">On the CD-ROM</a></li>
                        <li><a href="#resources_page">The Resources Page</a></li>
                    </ul>
                    <hr>
                    <p>This chapter describes the instructions that create and manipulate objects and arrays inside the Java Virtual Machine. All of these instructions involve the heap. Most of them refer to entries in the constant pool.</p> <p>Accompanying this chapter on the CD-ROM is an applet that interactively illustrates the material presented in the chapter. The applet, named <em>Three-Dimensional Array</em>, simulates the Java Virtual Machine executing a method that allocates and initializes a three dimensional array. At the end of this chapter, you will find a description of this applet and the bytecodes it executes.</p> <p><em> A Refresher on Objects and Arrays </em></p> <p>As mentioned in earlier chapters, in the Java Virtual Machine, memory is allocated on the garbage-collected heap only as objects. There is no way to allocate memory for a primitive type on the heap, except as part of an object. If you want to use a primitive type where an <code>Object</code> reference is needed, you can allocate a wrapper object for the type from the <code>java.lang</code> package. For example, there is an <code>Integer</code> class that wraps an <code>int</code> type with an object. Only object references and primitive types can reside on the Java stack as local variables. Objects can never reside on the Java stack.</p> <p>The architectural separation of objects and primitive types in the Java Virtual Machine is reflected in the Java programming language, in which objects cannot be declared as local variables--only object references and primitive types. Upon declaration, an object reference refers to nothing. Only after the reference has been explicitly initialized --either with a reference to an existing object or with a call to <code>new</code> --does the reference refer to an actual object.</p> <p>In the Java Virtual Machine instruction set, all objects are instantiated and accessed with the same set of opcodes, except for arrays. As mentioned in earlier chapters, arrays in Java are full-fledged objects. Like any other Java object, arrays are created dynamically. Array references can be used anywhere a reference to type <code>Object</code> is called for, and any method of <code>Object</code> can be invoked on an array. Still, in the Java Virtual Machine, array operations are handled by special bytecodes.</p> <p>As with any other object, arrays cannot be declared as local variables; only array references can. Array objects themselves always contain either an array of primitive types or an array of object references. If you declare an array of objects, you get an array of object references. The objects themselves must be explicitly created with <code>new</code> and assigned to the elements of the array.</p> <p><em> Opcodes for Objects </em></p> <p>Instantiation of new objects is accomplished via the <code>new</code> opcode, shown in Table 15-1. Two one-byte operands follow the <code>new</code> opcode. These two bytes are combined to form an unsigned 16-bit index into the constant pool. The constant pool entry at the specified offset gives information about the class of the new object. If it hasn't already, the virtual machine resolves the constant pool entry. It creates a new instance of the object on the heap, initializes the object's instance variables to default initial values, and pushes the reference to the new object onto the stack.</p> <p>Table 15-1. Object creation</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>new</code></td> <td>indexbyte1, indexbyte2</td> <td>creates a new object on the heap, pushes reference</td></tr> </tbody> </table> <p>Table 15-2 shows the opcodes that put and get object fields. These opcodes, <code>putfield</code> and <code>getfield</code>, operate only on fields that are instance variables. Static variables are accessed by <code>putstatic</code> and <code>getstatic</code>, which are described later. The <code>putfield</code> and <code>getfield</code> instructions each take two one-byte operands, which are combined to form an unsigned 16-bit index into the constant pool. The constant pool entry at that index contains information about the class, name, and type of the field. If it hasn't already, the virtual machine resolves the constant pool entry. The object reference is taken from the stack in both the <code>putfield</code> and <code>getfield</code> instructions. The <code>putfield</code> instruction takes the instance variable value from the stack, and the <code>getfield</code> instruction pushes the retrieved instance variable value onto the stack.</p> <p>Table 15-2. Accessing instance variables</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>putfield</code></td> <td>indexbyte1, indexbyte2</td> <td>set field, indicated by index, of object to value (both taken from stack)</td></tr> <tr><td><code>getfield</code></td> <td>indexbyte1, indexbyte2</td> <td>pushes field, indicated by index, of object (taken from stack)</td></tr> </tbody> </table> <p>Class variables are accessed via the <code>getstatic</code> and <code>putstatic</code> opcodes, as shown in Table 15-3. Both <code>getstatic</code> and <code>putstatic</code> take two one-byte operands, which are combined by the Java Virtual Machine to form a 16-bit unsigned offset into the constant pool. The constant pool item at that location gives information about one static field of a class. If it hasn't already, the virtual machine resolves the constant pool entry. Because there is no particular object associated with a static field, there is no object reference used by either <code>getstatic</code> or <code>putstatic</code>. The <code>putstatic</code> instruction takes the value to assign from the stack. The <code>getstatic</code> instruction pushes the retrieved value onto the stack.</p>
                    <p>Table 15-3. Accessing class variables</p>
                    <table>
                        <tbody>
                        <tr>
                            <td><strong> Opcode </strong></td>
                            <td><strong> Operand(s) </strong></td>
                            <td><strong> Description </strong></td>
                        </tr>
                        <tr>
                            <td><code>putstatic</code></td>
                            <td>indexbyte1, indexbyte2</td>
                            <td>sets static field, indicated by index, to value (taken from stack)</td>
                        </tr>
                        <tr>
                            <td><code>getstatic</code></td>
                            <td>indexbyte1, indexbyte2</td>
                            <td>pushes static field, indicated by index</td>
                        </tr>
                        </tbody>
                    </table>
                    <p>The following opcodes check to see whether the object reference on the top of the stack refers to an instance of the class or interface indexed by the operands following the opcode. In both cases, the virtual machine forms an unsigned 16-bit index into the constant pool from the two bytes that follow the opcode. If it hasn't already, the virtual machine resolves the constant pool entry.</p> <p>The <code>checkcast</code> instruction throws <code>CheckCastException</code> if the object is not an instance of the specified class or interface. Otherwise, <code>checkcast</code> does nothing. The object reference remains on the stack and execution is continued at the next instruction. This instruction ensures that casts are safe at run time and forms part of the Java Virtual Machine's security blanket.</p> <p>The <code>instanceof</code> instruction, shown in Table 15-4, pops the object reference from the top of the stack and pushes true or false. If the object is indeed an instance of the specified class or interface, then true is pushed onto the stack, otherwise, false is pushed onto the stack. The <code>instanceof</code> instruction is used to implement the <code>instanceof</code> keyword of the Java language, which allows you to test whether an object is an instance of a particular class or interface.</p> <p>Table 15-4. Type checking</p>
                    <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>checkcast</code></td> <td>indexbyte1, indexbyte2</td> <td>Throws <code>ClassCastException</code> if objectref on stack cannot be cast to class at index</td></tr> <tr><td><code>instanceof</code></td> <td>indexbyte1, indexbyte2</td> <td>Pushes <code>true</code> if objectref on stack is an instance of class at index, else pushes <code>false</code></td></tr> </tbody> </table> <p><em> Opcodes for Arrays </em></p> <p>Instantiation of new arrays is accomplished via the <code>newarray</code>, <code>anewarray</code>, and <code>multianewarray</code> opcodes, shown in Table 15-6. The <code>newarray</code> opcode is used to create arrays of primitive types other than object references. The particular primitive type is specified by a single one-byte operand, the "atype," following the <code>newarray</code> opcode. The <code>newarray</code> instruction can create arrays for <code>byte</code>, <code>short</code>, <code>char</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, or <code>boolean</code>. Table 15-5 shows the legal values for atype and the corresponding array types.</p> <p>Table 15-5. Values for atype</p> <table> <tbody> <tr><td><strong> Array Type </strong></td> <td><strong> atype </strong></td></tr> <tr><td><code>T_BOOLEAN</code></td> <td>4</td></tr> <tr><td><code>T_CHAR</code></td> <td>5</td></tr> <tr><td><code>T_FLOAT</code></td> <td>6</td></tr> <tr><td><code>T_DOUBLE</code></td> <td>7</td></tr> <tr><td><code>T_BYTE</code></td> <td>8</td></tr> <tr><td><code>T_SHORT</code></td> <td>9</td></tr> <tr><td><code>T_INT</code></td> <td>10</td></tr> <tr><td><code>T_LONG</code></td> <td>11</td></tr> </tbody> </table> <p>Note that the instructions that create arrays is one place in the Java Virtual Machine where <code>boolean</code> values are referred to explicitly. This enables implementations, especially those that must operate under constrained memory requirements, to compress arrays of <code>boolean</code> values into bit maps. In such a representation, each <code>boolean</code> element of an array would be represented by one bit. On implementations that have more memory available, <code>boolean</code> arrays may instead be implemented as arrays of <code>byte</code> s. This representation would likely yield better performance than a bit map approach, though it would consume more memory. No matter what internal implementation a particular virtual machine uses for <code>boolean</code> arrays, the elements of a <code>boolean</code> array are accessed with the same opcodes used to access <code>byte</code> arrays. These opcodes are described later in this chapter.</p> <p>The <code>anewarray</code> instruction creates an array of object references. Two one-byte operands follow the <code>anewarray</code> opcode and are combined to form an unsigned 16-bit index into the constant pool. A description of the class of object for which the array is to be created is found in the constant pool at the specified index. If it hasn't already, the virtual machine resolves the constant pool entry. This instruction allocates space for the array of object references and initializes the references to null.</p> <p>The <code>multianewarray</code> instruction is used to allocate multidimensional arrays, which are simply arrays of arrays. A multidimensional array could alternatively be allocated with repeated use of the <code>anewarray</code> and <code>newarray</code> instructions. The <code>multianewarray</code> instruction simply compresses the bytecodes needed to create multidimensional arrays into one instruction. Two one-byte operands follow the <code>multianewarray</code> opcode and are combined to form an unsigned 16-bit index into the constant pool. A description of the class of object for which the array is to be created is found in the constant pool at the specified index. If it hasn't already, the virtual machine resolves the symbolic reference. Immediately following the two one-byte operands that form the constant pool index is an unsigned one-byte operand that specifies the number of dimensions in this multidimensional array. The sizes for each dimension are popped off the stack. This instruction allocates space for all arrays that are needed to implement the multidimensional arrays.</p> <p>The constant pool entry referred to by a <code>multianewarray</code> instruction contains a <code>Constant_CLASS</code> entry with an array class name. For example, the constant pool entry for a four-dimensional array of float would have the name <code>"[[[[F"</code>. The class name in the constant pool entry may have more (but not less) left-brackets than indicated by the dimensions byte. The virtual machine always creates the number of dimensions specified by the dimensions byte.</p> <p>Table 15-6. Creating new arrays</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>newarray</code></td> <td>atype</td> <td>pops length, allocates new array of primitive types of type indicated by atype, pushes objectref of new array</td></tr> <tr><td><code>anewarray</code></td> <td>indexbyte1, indexbyte2</td> <td>pops length, allocates a new array of objects of class indicated by indexbyte1 and indexbyte2, pushes objectref of new array</td></tr> <tr><td><code>multianewarray</code></td> <td>indexbyte1, indexbyte2, dimensions</td> <td>pops dimensions number of array lengths, allocates a new multidimensional array of class indicated by indexbyte1 and indexbyte2, pushes objectref of new array</td></tr> </tbody> </table>
                    <p>Table 15-7 shows the <code>arraylength</code> instruction, which pops an array reference off the top of the stack and pushes the length of that array.</p>
                    <p>Table 15-7. Getting an array length</p>
                    <table>
                        <tbody>
                        <tr>
                            <td><strong> Opcode </strong></td>
                            <td><strong> Operand(s) </strong></td>
                            <td><strong> Description </strong></td>
                        </tr>
                        <tr>
                            <td><code>arraylength</code></td>
                            <td>(none)</td>
                            <td>pops objectref of an array, pushes length of that array</td>
                        </tr>
                        </tbody>
                    </table>
                    <p>The opcodes shown in Table 15-8 retrieve an element from an array. The array index and array reference are popped from the stack, and the value at the specified index of the specified array is pushed back onto the stack. The <code>baload</code> opcode converts the <code>byte</code> or <code>boolean</code> value to <code>int</code> by sign extending, then pushes the <code>int</code>. Likewise, the <code>saload</code> opcode converts the short value to <code>int</code> by sign extending, then pushes the <code>int</code>. The <code>caload</code> instruction converts the <code>char</code> to an <code>int</code> by zero-extending, then pushes the <code>int</code>.</p> <p>Table 15-8. Retrieving an array element</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>baload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>byte</code> s or <code>boolean</code> s, pushes arrayref[index]</td></tr> <tr><td><code>caload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>char</code> s, pushes arrayref[index]</td></tr> <tr><td><code>saload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>short</code> s, pushes arrayref[index]</td></tr> <tr><td><code>iaload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>int</code> s, pushes arrayref[index]</td></tr> <tr><td><code>laload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>long</code> s, pushes arrayref[index]</td></tr> <tr><td><code>faload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>float</code> s, pushes arrayref[index]</td></tr> <tr><td><code>daload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of <code>double</code> s, pushes arrayref[index]</td></tr> <tr><td><code>aaload</code></td> <td>(none)</td> <td>pops index and arrayref of an array of objectrefs, pushes arrayref[index]</td></tr> </tbody> </table> <p>Table 15-9 shows the opcodes that store a value into an array element. The value, index, and array reference are popped from the top of the stack. The <code>bastore</code> instruction just stores the lower eight bits of the popped <code>int</code> value. The <code>sastore</code> and <code>castore</code> instructions just store the lower 16 bits of the popped <code>int</code> value.</p> <p>Table 15-9. Storing to an array element</p> <table> <tbody> <tr><td><strong> Opcode </strong></td> <td><strong> Operand(s) </strong></td> <td><strong> Description </strong></td></tr> <tr><td><code>bastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>byte</code> s or <code>boolean</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>castore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>char</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>sastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>short</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>iastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>int</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>lastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>long</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>fastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>float</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>dastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of <code>double</code> s, assigns arrayref[index] = value</td></tr> <tr><td><code>aastore</code></td> <td>(none)</td> <td>pops value, index, and arrayref of an array of objectrefs, assigns arrayref[index] = value</td></tr> </tbody> </table> <p><em> Three-Dimensional Array: A Simulation </em></p> <p>The <em>Three-Dimensional Array</em> applet, shown in Figure 15-1, demonstrates a Java Virtual Machine executing a sequence of bytecodes. This applet is embedded in a web page on the CD-ROM in file <code>applets/ThreeDArray.html</code>.</p> <p>The bytecode sequence in the simulation was generated by <code>javac</code> for the <code>initAnArray()</code> method of the class shown below:</p> <pre> <p><code>begin</code></p> <code><p/></code> <code>// On CD-ROM in file opcodes/ex1/ThreeDTree.java <p>class ThreeDTree {</p> <p></p> <p>static void initAnArray() {</p> <p></p> <p>int[][][] threeD = new int[5][4][3];</p> <p></p> <p>for (int i = 0; i &lt; 5; ++i) {</p> <p>for (int j = 0; j &lt; 4; ++j) {</p> <p>for (int k = 0; k &lt; 3; ++k) {</p> <p>threeD[i][j][k] = i + j + k;</p> <p>}</p> <p>}</p> <p>}</p> <p>}</p> <p>}</p></code> <code><p></p></code> <code>end</code> </pre> <p><code>The bytecodes generated by <code>javac</code> for <code>initAnArray()</code> are shown below:</code></p> <pre> <p><code>begin</code></p> <code><p/></code> <code>0 iconst_5      // Push constant int 5. <p>1 iconst_4      // Push constant int 4.</p> <p>2 iconst_3      // Push constant int 3.</p> <p>3 multianewarray #2 dim #3 &lt;Class [[[I</p></code> <p>// Create a new multi-dimensional array using</p> <p>// constant pool entry #2 as the class (which</p> <p>// is [[[I, an 3D array of ints) with a</p> <p>// dimension of 3.</p> <p>7 astore_0      // Pop object ref into local variable 0:</p> <p>// int threeD[][][] = new int[5][4][3];</p> <p>8 iconst_0      // Push constant int 0.</p> <p>9 istore_1      // Pop int into local variable 1: int i = 0;</p> <p>10 goto 54       // Go to section of code that tests outer loop.</p> <p>13 iconst_0      // Push constant int 0.</p> <p>14 istore_2      // Pop int into local variable 2: int j = 0;</p> <p>15 goto 46       // Go to section of code that tests middle loop.</p> <p>18 iconst_0      // Push constant int 0.</p> <p>19 istore_3      // Pop int into local variable 3: int k = 0;</p> <p>20 goto 38       // Go to section of code that tests inner loop.</p> <p>23 aload_0       // Push object ref from local variable 0.</p> <p>24 iload_1       // Push int from local variable 1 (i).</p> <p>25 aaload        // Pop index and arrayref, push object ref</p> <p>// at arrayref[index] (gets threeD[i]).</p> <p>26 iload_2       // Push int from local variable 2 (j).</p> <p>27 aaload        // Pop index and arrayref, push object ref</p> <p>// at arrayref[index] (gets threeD[i][j]).</p> <p>28 iload_3       // Push int from local variable 3 (k).</p> <p>// Now calculate the int that will be assigned</p> <p>// to threeD[i][j][k]</p> <p>29 iload_1       // Push int from local variable 1 (i).</p> <p>30 iload_2       // Push int from local variable 2 (j).</p> <p>31 iadd          // Pop two ints, add them, push int result (i + j).</p> <p>32 iload_3       // Push int from local variable 3 (k).</p> <p>33 iadd          // Pop two ints, add them, push int</p> <p>// result (i + j + k).</p> <p>34 iastore       // Pop value, index, and arrayref; assign</p> <p>// arrayref[index] = value:</p> <p>// threeD[i][j][k] = i + j + k;</p> <p>35 iinc 3 1      // Increment by 1 the int in local variable 3: ++k;</p> <p>38 iload_3       // Push int from local variable 3 (k).</p> <p>39 iconst_3      // Push constant int 3.</p> <p>40 if_icmplt 23  // Pop right and left ints, jump if left &lt; right:</p> <p>// for (...; k &lt; 3;...)</p> <p>43 iinc 2 1      // Increment by 1 the int in local variable 2: ++j;</p> <p>46 iload_2       // Push int from local variable 2 (j).</p> <p>47 iconst_4      // Push constant int 4.</p> <p>48 if_icmplt 18  // Pop right and left ints, jump if left &lt; right:</p> <p>// for (...; j &lt; 4;...)</p> <p>51 iinc 1 1      // Increment by 1 the int in local variable 1: ++i;</p> <p>54 iload_1       // Push int from local variable 1 (i).</p> <p>55 iconst_5      // Push constant int 5.</p> <p>56 if_icmplt 13  // Pop right and left ints, jump if left &lt; right:</p> <p>// for (...; i &lt; 5;...)</p> <p>59 return</p> <code><p></p></code> <code>end</code> </pre> <p><code>The <code>initAnArray()</code> method merely allocates and initializes a three-dimensional array. This simulation demonstrates how the Java Virtual Machine handles multidimensional arrays. In response to the <code>multianewarray</code> instruction, which in this example requests the allocation of a three-dimensional array, the Java Virtual Machine creates a tree of one-dimensional arrays. The reference returned by the <code>multianewarray</code> instruction refers to the base one-dimensional array in the tree. In the <code>initAnArray()</code> method, the base array has five components -- <code>threeD[0]</code> through <code>threeD[4]</code>. Each component of the base array is itself a reference to a one-dimensional array of four components, accessed by <code>threeD[0][0]</code> through <code>threeD[4][3]</code>. The components of these twenty arrays are also references to arrays, each of which has three components. These components are <code>int</code> s, the elements of this multidimensional array, and they are accessed by <code>threeD[0][0][0]</code> through <code>threeD[4][3][2]</code>.</code></p>
                    <p><code>In response to the <code>multianewarray</code> instruction in the <code>initAnArray()</code> method, the Java Virtual Machine creates 1 five-element array of arrays, 5 four-element array of arrays, 20 three-element array of <code>ints</code>. The Java Virtual Machine allocates these 26 arrays on the heap, initializes their components such that they form a tree, and returns the reference to the base array.</code></p>
                    <p><code>To assign an <code>int</code> value to an element of the three-dimensional array, the Java Virtual Machine uses <code>aaload</code> to get a component of the base array. Then the Java Virtual Machine uses <code>aaload</code> again on this component--which is itself an array of arrays--to get a component of the branch array. This component is a reference to a leaf array of <code>ints</code>. Finally the Java Virtual Machine &nbsp;uses <code>iastore</code> to assign an <code>int</code> value to the element of the leaf array. The Java Virtual Machine uses multiple one-dimensional array accesses to accomplish operations on multidimensional arrays.</code></p> <p><code>To drive the <em>Three-Dimensional Array</em> simulation, use the Step, Reset, Run, and Stop buttons. Each time you press the Step button, the simulator will execute the instruction pointed to by the pc register. If you press the Run button, the simulation will continue with no further coaxing on your part until you press the Stop button. To start the simulation over, press the Reset button. For each step of the simulation, a panel at the bottom of the applet contains an explanation of what the next instruction will do. Happy clicking.</code></p> <p><code><img src="images/fig15-1.gif" alt="figure 15-1"></code></p> <p><code><em> On the CD-ROM </em></code></p> <p><code>The CD-ROM contains the source code examples from this chapter in the <code>opcodes</code> directory. The <em>Three-Dimensional Array</em> applet is part of a web page on the CD-ROM in file <code>applets/ThreeDArray.html</code>. The source code for this applet is found alongside its class files, in the <code>applets/JVMSimulators</code> and <code>applets/JVMSimulators/COM/artima/jvmsim</code> directories.</code></p> <p><code><em> The Resources Page </em></code></p> <p><code>For more information about the material presented in this chapter, visit the resources page: <a href="http://www.artima.com/insidejvm/resources" target="_blank">http://www.artima.com/insidejvm/resources</a>.</code></p>

                </div>

            </div>
            <br/>
            <div class="u-cf"></div>

            <div class="row">
                <div class="one-third column value">
                    <a class="button button-primary mod" href="14.html">Previous page</a>
                </div>
                <div class="one-third column value" style="text-align:center;">
                    <a class="button button-primary mod" href="index.html">Table of content</a>
                </div>
                <div class="one-third column value">
                    <a class="button button-primary mod u-pull-right" href="16.html">Next page</a>
                </div>
            </div>
            <hr/>

        </div>

    </div>

</div>

</body>
</html>


