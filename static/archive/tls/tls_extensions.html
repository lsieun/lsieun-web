<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">TLS Extensions</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/tls/tls_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<div title="Extension(RFC8446)" class="plaintext">
struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;

enum {
    server_name(0),                             /* RFC 6066 */
    max_fragment_length(1),                     /* RFC 6066 */
    status_request(5),                          /* RFC 6066 */
    supported_groups(10),                       /* RFC 8422, 7919 */
    signature_algorithms(13),                   /* RFC 8446 */
    use_srtp(14),                               /* RFC 5764 */
    heartbeat(15),                              /* RFC 6520 */
    application_layer_protocol_negotiation(16), /* RFC 7301 */
    signed_certificate_timestamp(18),           /* RFC 6962 */
    client_certificate_type(19),                /* RFC 7250 */
    server_certificate_type(20),                /* RFC 7250 */
    padding(21),                                /* RFC 7685 */
    pre_shared_key(41),                         /* RFC 8446 */
    early_data(42),                             /* RFC 8446 */
    supported_versions(43),                     /* RFC 8446 */
    cookie(44),                                 /* RFC 8446 */
    psk_key_exchange_modes(45),                 /* RFC 8446 */
    certificate_authorities(47),                /* RFC 8446 */
    oid_filters(48),                            /* RFC 8446 */
    post_handshake_auth(49),                    /* RFC 8446 */
    signature_algorithms_cert(50),              /* RFC 8446 */
    key_share(51),                              /* RFC 8446 */
    (65535)
} ExtensionType;
</div>

<h2>Hello Extensions</h2>

<p class="indented">
    The extension format for extended client hellos and extended server hellos is:
</p>

<div title="Extension" class="plaintext">
struct {
    ExtensionType extension_type;
    opaque extension_data<0..2^16-1>;
} Extension;
</div>

<ul>
    <li><code>extension_type</code> identifies the particular extension type.</li>
    <li><code>extension_data</code> contains information specific to the particular extension type.</li>
</ul>

<p class="indented">
    The extension types defined in this document are:
</p>

<div title="ExtensionType" class="plaintext">
enum {
    server_name(0), max_fragment_length(1),
    client_certificate_url(2), trusted_ca_keys(3),
    truncated_hmac(4), status_request(5), (65535)
} ExtensionType;
</div>



<h3>Extended Master Secret(RFC 7627)</h3>

<p class="indented">
    In TLS [<a href="/doc/rfc/rfc5246.html" target="_blank">RFC5246</a>], every session has a "master_secret" computed as:
</p>

<div title="RFC5246" class="plaintext">
master_secret = PRF(pre_master_secret, "master secret",
                    ClientHello.random + ServerHello.random)
                    [0..47];
</div>

<p class="indented">
    When the extended master secret extension is negotiated in a full
    handshake, the "master_secret" is computed as
</p>

<div title="RFC7627" class="plaintext">
master_secret = PRF(pre_master_secret, "extended master secret",
                    session_hash)
                    [0..47];
</div>

<p class="indented">
    RFC 7627 defines a new TLS extension, "extended_master_secret"
    (with extension type <code>0x0017</code>), which is used to signal both client and
    server to use the extended master secret computation.  The
    "extension_data" field of this extension is empty.  Thus, the entire
    encoding of the extension is <code>00 17 00 00</code> (in hexadecimal.)
</p>

<h3>Renegotiation Info(RFC 5746)</h3>

<p class="indented">
    TLS (RFC 5246) allows either the client or the server to <strong>initiate
    renegotiation</strong> -- <strong>a new handshake that establishes new cryptographic
    parameters</strong>.  Unfortunately, although the new handshake is carried out
    using the cryptographic parameters established by the original
    handshake, there is no cryptographic binding between the two.  This
    creates the opportunity for an attack in which the attacker who can
    intercept a client's transport layer connection can inject traffic of
    his own as a prefix to the client's interaction with the server.  One
    form of this attack proceeds as shown below:
</p>

<div title="renegotiation attack" class="plaintext">
Client                        Attacker                        Server
------                        -------                         ------
                                  <----------- Handshake ---------->
                                  <======= Initial Traffic ========>
<--------------------------  Handshake ============================>
<======================== Client Traffic ==========================>
</div>

<p class="indented">
    To start the attack, the attacker forms a TLS connection to the
    server (perhaps in response to an initial intercepted connection from
    the client). He then sends any traffic of his choice to the server.
    This may involve multiple requests and responses at the application
    layer, or may simply be a partial application layer request intended
    to prefix the client's data.  This traffic is shown with <code>==</code> to
    indicate it is encrypted.  He then allows the client's TLS handshake
    to proceed with the server.  The handshake is in the clear to the
    attacker but encrypted over the attacker's TLS connection to the
    server.  Once the handshake has completed, the client communicates
    with the server over the newly established security parameters with
    the server.  The attacker cannot read this traffic, but the server
    believes that the initial traffic to and from the attacker is the
    same as that to and from the client.
</p>

<p class="indented">
    In some protocols (notably HTTPS), no distinction is made between pre- and post-authentication stages and the bytes are handled uniformly,
    resulting in the server believing that the initial traffic corresponds to the authenticated client identity.
    For instance, if HTTPS [RFC2818] is in use with HTTP cookies [RFC2965],
    the attacker may be able to generate a request of his choice validated by the client's cookie.
</p>

<p class="indented">
    These attacks can be prevented by cryptographically binding
    renegotiation handshakes to the enclosing TLS cryptographic
    parameters, thus allowing the server to differentiate <strong>renegotiation</strong>
    from <strong>initial negotiation</strong>, as well as preventing renegotiations from
    being spliced in between connections.  An attempt by an attacker to
    inject himself as described above will result in a mismatch of the
    cryptographic binding and can thus be detected.
</p>

<p class="indented">
    <a href="/doc/rfc/rfc5746.html" target="_blank">RFC 5746</a>(2010.02) defines a new TLS extension, "renegotiation_info" (with
    extension type <code>0xff01</code>), which contains a cryptographic binding to the
    enclosing TLS connection (if any) for which the renegotiation is
    being performed.  The "extension data" field of this extension
    contains a "RenegotiationInfo" structure:
</p>

<div title="RFC 5746: RenegotiationInfo" class="plaintext">
struct {
    opaque renegotiated_connection<0..255>;
} RenegotiationInfo;
</div>

<p>
    The contents of this extension are specified as follows.
</p>

<ul>
    <li>
        If this is the initial handshake for a connection, then the
        "renegotiated_connection" field is of zero length in both the
        ClientHello and the ServerHello.  Thus, the entire encoding of the
        extension is <code>ff 01 00 01 00</code>.  The first two octets represent the
        extension type, the third and fourth octets the length of the
        extension itself, and the final octet the zero length byte for the
        "renegotiated_connection" field.
    </li>
    <li>
        For ClientHellos that are renegotiating, this field contains the
        "client_verify_data".
    </li>
    <li>
        For ServerHellos that are renegotiating, this field contains the
        concatenation of client_verify_data and server_verify_data.  For
        current versions of TLS, this will be a 24-byte value (for SSLv3,
        it will be a 72-byte value).
    </li>
</ul>

<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>

<h2>References</h2>

<ul>
    <li>
        RFC 3546 - Transport Layer Security (TLS) Extensions (2003.06):
        <a href="/doc/rfc/rfc3546.html" target="_blank">Local</a>
        <a class="external" href="https://tools.ietf.org/html/rfc3546" target="_blank">Remote</a>
    </li>
    <li>
        RFC 7627 - Transport Layer Security (TLS) Session Hash and
        Extended Master Secret Extension (2015.09):
        <a href="/doc/rfc/rfc7627.html" target="_blank">Local</a>
        <a class="external" href="https://tools.ietf.org/html/rfc7627" target="_blank">Remote</a>
    </li>
</ul>
