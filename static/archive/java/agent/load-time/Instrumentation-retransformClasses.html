<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">Instrumentation.retransformClasses(Class&lt;?&gt;... classes)</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="../java-agent-index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<h2 id="intro">Intro</h2>

<ul>
    <li>
        <code>void retransformClasses(Class&lt;?&gt;... classes)</code>:
        Retransform the supplied set of classes.
    </li>
</ul>

<p>
    This method operates on a set in order to allow interdependent changes to more than one class at the same time
    (a retransformation of class A can require a retransformation of class B).
</p>

<h3>transformation process</h3>

<p>
    This function facilitates the instrumentation of already loaded classes.
    When classes are initially loaded or when they are redefined,
    the initial class file bytes can be transformed with the <code>ClassFileTransformer</code>.
    This function reruns the transformation process (whether or not a transformation has previously occurred).
    This retransformation follows these steps:
</p>

<ul>
    <li>
        starting from the initial class file bytes
    </li>
    <li>
        for each transformer that was added with <code>canRetransform</code> <code>false</code>,
        the bytes returned by <code>transform</code> method during the last class load or redefine are reused as the output of the transformation;
        note that this is equivalent to reapplying the previous transformation, unaltered; except that <code>transform</code> is not called
    </li>
    <li>
        for each transformer that was added with <code>canRetransform</code> true, the <code>transform</code> method is called in these transformers
    </li>
    <li>
        the transformed class file bytes are installed as the new definition of the class
    </li>
</ul>

<h3>order of transformation</h3>

<p>
    The order of transformation is described in the <code>transform</code> method.
    This same order is used in the automatic reapplication of retransformation incapable transforms.
</p>

<p>
    The initial class file bytes represent the bytes passed to <code>ClassLoader.defineClass</code> or <code>redefineClasses</code>
    (before any transformations were applied), however they might not exactly match them.
    The constant pool might not have the same layout or contents.
    The constant pool may have more or fewer entries.
    Constant pool entries may be in a different order;
    however, constant pool indices in the bytecodes of methods will correspond.
    Some attributes may not be present.
    Where order is not meaningful, for example the order of methods, order might not be preserved.
</p>


<h3>active stack frames</h3>

<p>
    If a retransformed method has active stack frames,
    those active frames continue to run the bytecodes of the original method.
    The retransformed method will be used on new invokes.
</p>

<h3>initialization</h3>

<p>
    This method does not cause any initialization except that which would occur under the customary JVM semantics.
    In other words, redefining a class does not cause its initializers to be run.
    The values of static variables will remain as they were prior to the call.
</p>

<p>
    Instances of the retransformed class are not affected.
</p>

<h3>restrictions</h3>

<p>
    The retransformation may change method bodies, the constant pool and attributes.
    The retransformation must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance.
    These restrictions maybe be lifted in future versions.
</p>

<h3>transformations</h3>

<p>
    The class file bytes are not checked, verified and installed until after the transformations have been applied,
    if the resultant bytes are in error this method will throw an exception.
</p>

<h3>exception</h3>

<p>
    If this method throws an exception, no classes have been retransformed.
</p>
<p></p>
<p></p>
<p></p>
<p></p>

<h2 id="application">Application</h2>

<pre title="HelloWorld.java" class="javacode">
public class HelloWorld {
}
</pre>

<pre title="Program.java" class="javacode">
public class Program {
    public static void main(String[] args) throws Exception {
        HelloWorld instance = new HelloWorld();
        System.out.println(instance);
    }
}
</pre>

<h2 id="java-agent-jar">Java Agent Jar</h2>

<h3 id="agent-class">Agent Class</h3>

<pre title="LoadTimeAgent.java" class="javacode">
import lsieun.transformer.ASMTransformer;

import java.lang.instrument.Instrumentation;
import java.lang.instrument.UnmodifiableClassException;

public class LoadTimeAgent {
    public static void premain(String agentArgs, Instrumentation inst) {
        System.out.println("Premain-Class: " + LoadTimeAgent.class.getName());
        System.out.println("Can-Redefine-Classes: " + inst.isRedefineClassesSupported());
        System.out.println("Can-Retransform-Classes: " + inst.isRetransformClassesSupported());
        System.out.println("Can-Set-Native-Method-Prefix: " + inst.isNativeMethodPrefixSupported());

        inst.addTransformer(new ASMTransformer(), true);
        try {
            Class&lt;?&gt; clazz = Object.class;
            if (inst.isModifiableClass(clazz)) {
                inst.retransformClasses(clazz);
            }
        } catch (UnmodifiableClassException ex) {
            ex.printStackTrace();
        }
    }
}
</pre>

<h3 id="transformer">Transformer</h3>

<pre title="ASMTransformer.java" class="javacode">
import lsieun.visitor.modify.ReplaceMethodBodyVisitor;
import org.objectweb.asm.*;

import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;

public class ASMTransformer implements ClassFileTransformer {
    @Override
    public byte[] transform(ClassLoader loader,
                            String className,
                            Class&lt;?&gt; classBeingRedefined,
                            ProtectionDomain protectionDomain,
                            byte[] classfileBuffer) throws IllegalClassFormatException {
        if (className == null) return null;

        if (className.equals("java/lang/Object")) {
            ClassReader cr = new ClassReader(classfileBuffer);
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);
            ClassVisitor cv = new ReplaceMethodBodyVisitor(cw, "toString", "()Ljava/lang/String;") {
                @Override
                protected void generateNewBody(MethodVisitor mv, String owner,
                                               int methodAccess, String methodName, String methodDesc) {
                    mv.visitCode();
                    mv.visitLdcInsn("This is an object.");
                    mv.visitInsn(Opcodes.ARETURN);
                    mv.visitMaxs(1, 1);
                    mv.visitEnd();
                }
            };

            int parsingOptions = ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES;
            cr.accept(cv, parsingOptions);
            byte[] bytes = cw.toByteArray();
            return bytes;
        }

        return null;
    }
}
</pre>

<h2 id="run-application">Run Application</h2>

<h3 id="run-without-agent">Run</h3>

<pre title="java sample.Program" class="plaintext">
$ java sample.Program
sample.HelloWorld@15db9742
</pre>

<h3 id="run-with-agent">Run With Agent</h3>

<pre title="java -javaagent:TheAgent.jar sample.Program" class="plaintext">
$ java -javaagent:D:/git-repo/learn-java-agent/target/TheAgent.jar sample.Program
Premain-Class: lsieun.agent.LoadTimeAgent
Can-Redefine-Classes: true
Can-Retransform-Classes: true
Can-Set-Native-Method-Prefix: true
This is an object.
</pre>
