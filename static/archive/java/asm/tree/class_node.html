<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">ClassNode</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_asm_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<h2>ClassNode</h2>

<p class="indented">
    The ASM <span class="text-compare-blue">tree API</span> for generating and transforming compiled Java classes is
    based on the <code>ClassNode</code> class.
</p>

<h3>fields</h3>

<pre title="ClassNode.java" class="javacode">
public class ClassNode extends ClassVisitor {
    public int version;
    public int access;
    public String name;
    public String signature;
    public String superName;
    public List&lt;String&gt; interfaces;

    public String sourceFile;
    public String sourceDebug;
    public ModuleNode module;
    public String outerClass;
    public String outerMethod;
    public String outerMethodDesc;
    public List&lt;AnnotationNode&gt; visibleAnnotations;
    public List&lt;AnnotationNode&gt; invisibleAnnotations;
    public List&lt;TypeAnnotationNode&gt; visibleTypeAnnotations;
    public List&lt;TypeAnnotationNode&gt; invisibleTypeAnnotations;
    public List&lt;Attribute&gt; attrs;
    public List&lt;InnerClassNode&gt; innerClasses;
    public String nestHostClass;
    public List&lt;String&gt; nestMembers;
    public List&lt;String&gt; permittedSubclasses;
    public List&lt;RecordComponentNode&gt; recordComponents;

    public List&lt;FieldNode&gt; fields;
    public List&lt;MethodNode&gt; methods;
}
</div>

<h3>create ClassNode object</h3>

<pre title="HelloWorld.java" class="javacode">
public class ClassNode extends ClassVisitor {
    public ClassNode() {
        this(Opcodes.ASM9);
    }

    public ClassNode(final int api) {
        super(api);
        this.interfaces = new ArrayList&lt;&gt;();
        this.innerClasses = new ArrayList&lt;&gt;();
        this.fields = new ArrayList&lt;&gt;();
        this.methods = new ArrayList&lt;&gt;();
    }
}
</div>

<h3>accept method</h3>

<p class="indented">
    The <code>ClassNode</code> class extends the <code>ClassVisitor</code> class,
    and also provides an <code>accept</code> method that takes a <code>ClassVisitor</code> as parameter.
    The <code>accept</code> method generates events based on the <code>ClassNode</code> field values,
    while the <code>ClassVisitor</code> methods perform the inverse operation, i.e. set the <code>ClassNode</code> fields based on the received events:
</p>

<pre title="ClassNode.java" class="javacode">
public class ClassNode extends ClassVisitor {
    public void accept(final ClassVisitor classVisitor) {
        // Visit the header.
        String[] interfacesArray = new String[this.interfaces.size()];
        this.interfaces.toArray(interfacesArray);
        classVisitor.visit(version, access, name, signature, superName, interfacesArray);

        // Visit the source.
        if (sourceFile != null || sourceDebug != null) {
            classVisitor.visitSource(sourceFile, sourceDebug);
        }

        // ......

        // Visit the fields.
        for (int i = 0, n = fields.size(); i < n; ++i) {
            fields.get(i).accept(classVisitor);
        }

        // Visit the methods.
        for (int i = 0, n = methods.size(); i < n; ++i) {
            methods.get(i).accept(classVisitor);
        }
        classVisitor.visitEnd();
    }
}
</div>

<h2>bytes and ClassNode</h2>

<p class="indented">
    <span class="text-compare-blue">Constructing a <code>ClassNode</code> from a byte array</span>
    can therefore be done by composing it with a <code>ClassReader</code>,
    so that the events generated by the <code>ClassReader</code> are consumed by the <code>ClassNode</code> component,
    resulting in the initialization of its fields:
</p>

<pre title="from bytes to ClassNode" class="javacode">
ClassNode cn = new ClassNode();
ClassReader cr = new ClassReader(...);
cr.accept(cn, 0);
</div>

<p class="indented">
    Symmetrically <span class="text-compare-blue">a <code>ClassNode</code> can be converted to its byte array representation</span>
    by composing it with a <code>ClassWriter</code>,
    so that the events generated by the <code>ClassNode</code>'s <code>accept</code> method are consumed by the <code>ClassWriter</code>:
</p>

<pre title="from ClassNode to bytes" class="javacode">
ClassWriter cw = new ClassWriter(0);
cn.accept(cw);
byte[] b = cw.toByteArray();
</div>

<p class="indented">
    Transforming a class with the tree API can be done by putting these elements together:
</p>

<pre title="examples" class="javacode">
// (1) 构建ClassReader
ClassReader cr = new ClassReader(...);

// (2) 构建ClassNode
ClassNode cn = new ClassNode(ASM4);
cr.accept(cn, 0);

// (3) 进行transform
... // here transform cn as you want

// (4) 构建ClassWriter
ClassWriter cw = new ClassWriter(0);
cn.accept(cw);

// (5) 生成byte[]内容输出
byte[] bytes = cw.toByteArray();
</div>

<h2>Patterns</h2>

<p class="indented">
    It is possible to use a <span class="text-compare-blue">tree based</span> <span class="text-compare-green">class transformer</span>
    like a <span class="text-compare-green">class adapter</span> with the <span class="text-compare-blue">core API</span>.
    <span class="text-emphasize">Two common patterns</span> are used for that.
</p>

<p class="indented">
    <span class="text-compare-grey">The first one</span> uses inheritance:
</p>

<pre title="MyClassAdapter.java" class="javacode">
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;

public class MyClassAdapter extends ClassNode {
    public MyClassAdapter(int api, ClassVisitor cv) {
        super(api);
        this.cv = cv;
    }

    @Override
    public void visitEnd() {
        // put your transformation code here
        accept(cv);
    }
}
</div>

<p class="indented">
    When this class adapter is used in a classical transformation chain:
</p>

<pre title="classical transformation chain" class="javacode">
ClassWriter cw = new ClassWriter(0);
ClassNode ca = new MyClassAdapter(cw);
ClassReader cr = new ClassReader(...);
cr.accept(ca, 0);
byte[] b = cw.toByteArray();
</div>

<p>
    the events generated by <code>cr</code> are consumed by the <code>ClassNode ca</code>,
    which results in the initialization of the fields of this object.
    At the end, when the <code>visitEnd</code> event is consumed,
    <code>ca</code> performs the transformation and,
    by calling its <code>accept</code> method,
    generates new events corresponding to the transformed class,
    which are consumed by <code>cw</code>.
</p>

<p class="indented">
    <span class="text-compare-grey">The second pattern</span> that can be used to achieve the same result,
    with a similar sequence diagram, uses <span class="text-compare-green">delegation</span> instead of <span class="text-compare-green">inheritance</span>:
</p>

<pre title="MyClassAdapter.java" class="javacode">
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;

public class MyClassAdapter extends ClassVisitor {
    ClassVisitor next;
    public MyClassAdapter(int api, ClassVisitor cv) {
        super(api, new ClassNode());
        next = cv;
    }

    @Override
    public void visitEnd() {
        ClassNode cn = (ClassNode) cv;
        // put your transformation code here
        cn.accept(next);
    }
}
</div>

<p class="indented">
    This pattern uses two objects instead of one,
    but works exactly in the same way as the first pattern:
    the received events are used to construct a <code>ClassNode</code>,
    which is transformed and converted back to an event based representation
    when the last event is received.
</p>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        上面介绍的两种pattern，主要是希望将tree based api和core based api结合到一起使用。
    </p>
    <p>
        如果单纯的想使用tree based api，可以可以直接使用<code>ClassTransformer</code>这种形式。对于如何使用<code>ClassTransformer</code>，可以参考这两个例子：<a href="/archive/java/asm/tree/field_add.html">Adding Field</a>和<a href="/archive/java/asm/tree/method_remove.html">Removing Method</a>。
    </p>
</div>

<p class="indented">
    Both patterns allow you to <span class="text-compare-green">compose your tree based class adapters with event based adapters</span>.
    They can also be used to compose tree based adapters together,
    but if you <span class="text-compare-green">only need to compose tree based adapters</span> this is not the best solution:
    in this case using classes such as <code>ClassTransformer</code> will avoid
    unnecessary conversions between the two representations.
</p>

<pre title="ClassTransformer.java" class="javacode">
import org.objectweb.asm.tree.ClassNode;

public class ClassTransformer {
    protected  ClassTransformer ct;

    public ClassTransformer(ClassTransformer ct) {
        this.ct = ct;
    }

    public void transform(ClassNode cn) {
        if (ct != null) {
            ct.transform(cn);
        }
    }
}
</div>

<h2>Tree API VS Core API</h2>

<p class="indented">
    Using the <span class="text-compare-blue">tree API</span> to <span class="text-compare-green">generate a class</span>
    <span class="text-key-point">takes about 30% more time and consumes more memory</span>
    than using the <span class="text-compare-blue">core API</span>.
    But it makes it possible to generate the class elements in any order, which can be convenient in some cases.
</p>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        class generation是从“无”到“有”生成一个.class文件。
    </p>
    <p>
        class transformation是对已有的一个.class文件进行变换。
    </p>
</div>

<p class="indented">
    <span class="indented">Adding and removing class members</span> simply consists in adding or removing
    elements in the <code>fields</code> or <code>methods</code> lists of a <code>ClassNode</code> object.
    <sub class="my_note" style="color:blue">笔记：对class members进行add和remove操作，就是transform class。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    Like for <span class="text-compare-green">class generation</span>,
    using the <span class="text-compare-blue">tree API</span> to <span class="text-compare-green">transform classes</span>
    <span class="text-key-point">takes more time and consumes more memory</span>
    than using the <span class="text-compare-blue">core API</span>.
    But it makes it possible to implement some transformations more easily.
    This is the case, for example, of <span class="text-example">a transformation that adds to a class an annotation containing a digital signature of its content</span>.
    With the <span class="text-compare-blue">core API</span> the digital signature can be computed only when all the class has been visited,
    but then it is too late to add an annotation containing it,
    because annotations must be visited before class members.
    With the <span class="text-compare-blue">tree API</span> this problem disappears because there is no such constraint in this case.
</p>

<p class="indented">
    In fact it is possible to implement the <code>AddDigitalSignature</code> example with the <span class="text-compare-blue">core API</span>,
    but then the class must be transformed in two passes.
    During <span class="text-compare-green">the first pass</span> the class is visited with a <code>ClassReader</code> (and no <code>ClassWriter</code>),
    in order to compute the digital signature based on the class content.
    During <span class="text-compare-green">the second pass</span> the same <code>ClassReader</code> is reused to do a second visit of the class,
    this time with an <code>AddAnnotationAdapter</code> chained to a <code>ClassWriter</code>.
    By generalizing this argument we see that, in fact,
    <span class="text-key-point">any transformation can be implemented with the core API alone, by using several passes if necessary.</span>
    But this increases the transformation code complexity,
    this requires to store state between passes (which can be as complex as a full tree representation!),
    and parsing the class several times has a cost,
    which must be compared to the cost of constructing the corresponding <code>ClassNode</code>.
</p>

<p class="indented">
    The conclusion is that <span class="text-key-point">the tree API is generally used for transformations that cannot be implemented in one pass with the core API</span>.
    But there are of course exceptions.
    For example <span class="text-example">an obfuscator cannot be implemented in one pass</span>,
    because you cannot transform classes before the mapping from original to obfuscated names is fully constructed,
    which requires to parse all classes.
    But the <span class="text-compare-blue">tree API</span> is not a good solution either,
    because it would require keeping in memory the object representation of all the classes to obfuscate.
    In this case it is better to use the <span class="text-compare-blue">core API</span> with two passes:
    <span class="text-compare-grey">one to compute the mapping between original and obfuscated names</span>
    (a simple hash table that requires much less memory than a full object representation of all the classes),
    and <span class="text-compare-grey">one to transform the classes based on this mapping</span>.
</p>




<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
