<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">Core And Tree Pattern</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_asm_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<h2>Patterns</h2>

<p class="indented">
    It is possible to use a <span class="text-compare-green">tree based</span> <span class="text-compare-green">class transformer</span>
    like a <span class="text-compare-green">class adapter</span> with the <span class="text-compare-green">core API</span>.
    <span class="text-emphasize">Two common patterns</span> are used for that.
</p>

<p class="indented">
    <span class="text-compare-grey">The first one</span> uses inheritance:
</p>

<pre title="MyClassAdapter.java" class="javacode">
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;

public class MyClassAdapter extends ClassNode {
    public MyClassAdapter(int api, ClassVisitor cv) {
        super(api);
        this.cv = cv;
    }

    @Override
    public void visitEnd() {
        // put your transformation code here
        accept(cv);
    }
}
</pre>

<p class="indented">
    When this class adapter is used in a classical transformation chain:
</p>

<pre title="classical transformation chain" class="javacode">
ClassWriter cw = new ClassWriter(0);
ClassNode ca = new MyClassAdapter(cw);
ClassReader cr = new ClassReader(...);
cr.accept(ca, 0);
byte[] b = cw.toByteArray();
</pre>

<p>
    the events generated by <code>cr</code> are consumed by the <code>ClassNode ca</code>,
    which results in the initialization of the fields of this object.
    At the end, when the <code>visitEnd</code> event is consumed,
    <code>ca</code> performs the transformation and,
    by calling its <code>accept</code> method,
    generates new events corresponding to the transformed class,
    which are consumed by <code>cw</code>.
</p>

<p class="indented">
    <span class="text-compare-grey">The second pattern</span> that can be used to achieve the same result,
    with a similar sequence diagram, uses <span class="text-compare-green">delegation</span> instead of <span class="text-compare-green">inheritance</span>:
</p>

<pre title="MyClassAdapter.java" class="javacode">
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.tree.ClassNode;

public class MyClassAdapter extends ClassVisitor {
    ClassVisitor next;
    public MyClassAdapter(int api, ClassVisitor cv) {
        super(api, new ClassNode());
        next = cv;
    }

    @Override
    public void visitEnd() {
        ClassNode cn = (ClassNode) cv;
        // put your transformation code here
        cn.accept(next);
    }
}
</pre>

<p class="indented">
    This pattern uses two objects instead of one,
    but works exactly in the same way as the first pattern:
    the received events are used to construct a <code>ClassNode</code>,
    which is transformed and converted back to an event based representation
    when the last event is received.
</p>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        上面介绍的两种pattern，主要是希望将tree based api和core based api结合到一起使用。
    </p>
    <p>
        如果单纯的想使用tree based api，可以可以直接使用<code>ClassTransformer</code>这种形式。对于如何使用<code>ClassTransformer</code>，可以参考这两个例子：<a href="/archive/java/asm/tree/field_add.html">Adding Field</a>和<a href="/archive/java/asm/tree/method_remove.html">Removing Method</a>。
    </p>
</div>

<p class="indented">
    Both patterns allow you to <span class="text-compare-green">compose your tree based class adapters with event based adapters</span>.
    They can also be used to compose tree based adapters together,
    but if you <span class="text-compare-green">only need to compose tree based adapters</span> this is not the best solution:
    in this case using classes such as <code>ClassTransformer</code> will avoid
    unnecessary conversions between the two representations.
</p>

<pre title="ClassTransformer.java" class="javacode">
import org.objectweb.asm.tree.ClassNode;

public class ClassTransformer {
    protected  ClassTransformer ct;

    public ClassTransformer(ClassTransformer ct) {
        this.ct = ct;
    }

    public void transform(ClassNode cn) {
        if (ct != null) {
            ct.transform(cn);
        }
    }
}
</pre>


