<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">FieldVisitor and FieldWriter<br/>Intro</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_asm_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<h2>FieldVisitor</h2>

<p>
    在学习<code>FieldVisitor</code>的时候，可以与<code>ClassVisitor</code>进行类比，这两个类之间有很大的相似性。
</p>

<ul>
    <li>
        第一，两者都是abstract类。
    </li>
    <li>
        第二，定义了哪些字段。
    </li>
    <li>
        第三，定义了哪些构造函数。
    </li>
    <li>
        第四，定义了哪些具体的<code>visitXxx</code>方法。
    </li>
</ul>

<pre title="ASM: FieldVisitor.java" class="javacode">
public abstract class FieldVisitor {
    protected final int api;
    protected FieldVisitor fv;

    public FieldVisitor(final int api) {
        this(api, null);
    }

    public FieldVisitor(final int api, final FieldVisitor fieldVisitor) {
        this.api = api;
        this.fv = fieldVisitor;
    }

    // ......

    public void visitAttribute(final Attribute attribute) {
        if (fv != null) {
            fv.visitAttribute(attribute);
        }
    }

    public void visitEnd() {
        if (fv != null) {
            fv.visitEnd();
        }
    }
}
</pre>

<p>
    另外，<code>FieldVisitor</code>内定义的<code>visitXxx</code>方法也要遵循一定的调用顺序：
</p>

<pre title="The methods of FieldVisitor class must be called in the following order" class="plaintext">
(visitAnnotation | visitTypeAnnotation | visitAttribute )* visitEnd
</pre>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        注意：在对<code>visitXxx</code>方法调用过程中，最后一定要调用<code>visitEnd()</code>方法。
    </p>
    <p>
        联想一下：什么样的人是靠谱的人？所谓靠谱的人，就是凡事有交代，件件有着落，事事有回音！说是三件事，其实是一件事，就是一个人要在协作中完成闭环。所谓闭环，就是一件事有开头，就必有结尾。但是一般人做到这一条并不容易。
    </p>
    <p>
        对于<code>visitEnd()</code>方法的调用，就是明确的声明“这件事情，我做完了”。
    </p>
</div>

<h2>FieldWriter</h2>

<p>
    <code>ClassWriter</code>、<code>FieldWriter</code>和<code>MethodWriter</code>三个类是一个“组合”
</p>

<h3>SuperClass</h3>

<p class="indented">
    第一个要注意的地方，就是<code>FieldWriter</code>的父类。
</p>

<pre title="ASM: FieldWriter.java" class="javacode">
final class FieldWriter extends FieldVisitor {
}
</pre>

<h3>fields</h3>

<p class="indented">
    第二个要注意的地方，就是<code>FieldWriter</code>定义的字段有哪些。
</p>

<p class="indented">
    <code>FieldWriter</code>定义的字段与<code>ClassFile</code>当中的<code>field_info</code>结构密切相关。
</p>

<pre title="ClassFile: field_info" hidden class="plaintext">
field_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</pre>

<pre title="ASM: FieldWriter.java" class="javacode">
final class FieldWriter extends FieldVisitor {
    private final SymbolTable symbolTable;

    private final int accessFlags;
    private final int nameIndex;
    private final int descriptorIndex;

    private Attribute firstAttribute;
}
</pre>

<h3>Constructor</h3>

<p class="indented">
    第三个要注意的地方，就是<code>ClassWriter</code>定义的构造函数。
</p>

<pre title="ASM: FieldWriter.java" class="javacode">
final class FieldWriter extends FieldVisitor {
    FieldWriter(final SymbolTable symbolTable, final int access, final String name, final String descriptor,
                final String signature, final Object constantValue) {
        super(/* latest api = */ Opcodes.ASM9);
        this.symbolTable = symbolTable;
        this.accessFlags = access;
        this.nameIndex = symbolTable.addConstantUtf8(name);
        this.descriptorIndex = symbolTable.addConstantUtf8(descriptor);
        if (signature != null) {
            this.signatureIndex = symbolTable.addConstantUtf8(signature);
        }
        if (constantValue != null) {
            this.constantValueIndex = symbolTable.addConstant(constantValue).index;
        }
    }
}
</pre>

<h3>methods</h3>

<p class="indented">
    第四个要注意的地方，就是<code>FieldWriter</code>定义的方法。
</p>

<pre title="ASM: FieldWriter.java" class="javacode">
final class FieldWriter extends FieldVisitor {
    // ......

    @Override
    public void visitAttribute(final Attribute attribute) {
        // Store the attributes in the <i>reverse</i> order of their visit by this method.
        attribute.nextAttribute = firstAttribute;
        firstAttribute = attribute;
    }

    @Override
    public void visitEnd() {
        // Nothing to do.
    }

    int computeFieldInfoSize() {
        // ......
    }

    void putFieldInfo(final ByteVector output) {
        // ......
    }
}
</pre>

<ul>
    <li>
        <code>visitXxx()</code>方法调用，就是对<code>FieldWriter</code>中定义的字段赋值的过程，它是一个过程。在目前的阶段，我们只关注<code>visitEnd()</code>方法就可以了；这么做的目的是为了刚开始接触的时候尽量简化不必要的操作，因为一个类字段在没有额外Attribute、Annotation的情况也能正常使用。在后续内容当中，我们再去关注<code>visitAttribute()</code>、<code>visitAnnotation()</code>等其他方法。
    </li>
    <li>
        <code>computeFieldInfoSize()</code>和<code>putFieldInfo()</code>方法的调用，是在构建<code>FieldWriter</code>中字段赋值的过程结束后，将所对应的“字段信息”转换成字节内容（<code>byte[]</code>）。这些字节内容（<code>byte[]</code>）符合<code>field_info</code>的结构。
    </li>
</ul>

<pre title="ASM: FieldWriter.java" class="javacode">
final class FieldWriter extends FieldVisitor {
    private final SymbolTable symbolTable;

    private final int accessFlags;
    private final int nameIndex;
    private final int descriptorIndex;

    private Attribute firstAttribute;
}
</pre>

<pre title="ClassFile: field_info" class="plaintext">
field_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
</pre>

<h2>Summing Up</h2>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/asm/asm_study_three_level.png" alt=""/>
</div>

