<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">ClassVisitor</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_asm_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<p>
    The ASM API for generating and transforming compiled classes is based on the <code>ClassVisitor</code> abstract class.
</p>

<h2>Methods In ClassVisitor</h2>

<p class="indented">
    Each method in this class corresponds to the class file structure.
    <span class="text-example">Simple sections</span> are visited with a single method call whose arguments describe their content, and which returns <code>void</code>.
    <span class="text-example">Sections whose content can be of arbitrary length and complexity</span> are visited with a initial method call that returns an auxiliary visitor class.
    This is the case of the <code>visitAnnotation</code>, <code>visitField</code> and <code>visitMethod</code> methods,
    which return an <code>AnnotationVisitor</code>, a <code>FieldVisitor</code> and a <code>MethodVisitor</code> respectively.
</p>

<pre title="ClassVisitor" class="javacode">
public abstract class ClassVisitor {
    public ClassVisitor(final int api);
    public ClassVisitor(final int api, final ClassVisitor classVisitor);
    public void visit(
        final int version,
        final int access,
        final String name,
        final String signature,
        final String superName,
        final String[] interfaces);
    public void visitSource(final String source, final String debug);
    public ModuleVisitor visitModule(final String name, final int access, final String version);
    public void visitNestHost(final String nestHost);
    public void visitOuterClass(final String owner, final String name, final String descriptor);
    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible);  // 访问注解
    public AnnotationVisitor visitTypeAnnotation(
        final int typeRef,
        final TypePath typePath,
        final String descriptor,
        final boolean visible);
    public void visitAttribute(final Attribute attribute);
    // ......
    public void visitInnerClass(
        final String name,
        final String outerName,
        final String innerName,
        final int access);
    // ......
    public FieldVisitor visitField( // 访问字段
        final int access,
        final String name,
        final String descriptor,
        final String signature,
        final Object value);
    public MethodVisitor visitMethod( // 访问方法
        final int access,
        final String name,
        final String descriptor,
        final String signature,
        final String[] exceptions);
    public void visitEnd();
}
</div>

<h2>Method Invocation Order</h2>

<p class="indented">
    <span class="text-example">The methods</span> of the <code>ClassVisitor</code> class must be called in the following order,
    specified in the Javadoc of this class:
</p>

<pre title="The methods of ClassVisitor must be called in the following order" class="plaintext">
visit
[visitSource] [visitModule] [visitNestHost][ visitPermittedSubclass] [visitOuterClass]
(visitAnnotation | visitTypeAnnotation | visitAttribute)*
(visitNestMember | visitInnerClass | visitRecordComponent | visitField | visitMethod)*
visitEnd.
</div>

<p class="indented">
    This means that <code>visit</code> must be called first,
    followed by at most one call to <code>visitSource</code>,
    followed by at most one call to <code>visitOuterClass</code>,
    followed by any number of calls in any order to <code>visitAnnotation</code> and <code>visitAttribute</code>,
    followed by any number of calls in any order to <code>visitInnerClass</code>, <code>visitField</code>
    and <code>visitMethod</code>, and terminated by a single call to <code>visitEnd</code>.
</p>

<h2>Three Core Components</h2>

<p>
    ASM provides <span class="text-example">three core components</span> based on the <code>ClassVisitor</code> API to generate and transform classes:
</p>

<ul>
    <li>
        The <code>ClassReader</code> class parses a compiled class given as a byte array,
        and calls the corresponding <code>visitXxx</code> methods on the <code>ClassVisitor</code> instance passed as argument to its <code>accept</code> method.
        <span class="text-key-point">It can be seen as an event producer</span>.
    </li>
    <li>
        The <code>ClassWriter</code> class is a subclass of the <code>ClassVisitor</code> abstract class that builds compiled classes directly in binary form.
        It produces as output a byte array containing the compiled class, which can be retrieved with the <code>toByteArray</code> method.
        <span class="text-key-point">It can be seen as an event consumer</span>.
    </li>
    <li>
        The <code>ClassVisitor</code> class delegates all the method calls it receives to another <code>ClassVisitor</code> instance.
        <span class="text-key-point">It can be seen as an event filter</span>.
    </li>
</ul>
