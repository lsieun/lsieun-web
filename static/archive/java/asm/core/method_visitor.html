<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">MethodVisitor</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_asm_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<h2>Intro</h2>

<p class="indented">
    <span class="text-key-point">The ASM API for generating and transforming compiled methods is based on the <code>MethodVisitor</code> abstract class</span>,
    which is returned by the <code>ClassVisitor</code>'s <code>visitMethod</code> method.
</p>

<div title="ClassVisitor.java" class="javacode">
public abstract class ClassVisitor {
    public MethodVisitor visitMethod(final int access, final String name, final String descriptor,
                                     final String signature, final String[] exceptions) {
        if (cv != null) {
            return cv.visitMethod(access, name, descriptor, signature, exceptions);
        }
        return null;
    }
}
</div>

<p class="indented">
    In addition to some methods related to annotations and debug information,
    <span class="text-key-point">this class defines one method per bytecode instruction category</span>,
    based on the number and type of arguments of these instructions.
</p>

<div title="MethodVisitor.java" hidden class="javacode">
public abstract class MethodVisitor {
    public void visitParameter(final String name, final int access);
    public AnnotationVisitor visitAnnotationDefault();
    public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible);
    public AnnotationVisitor visitTypeAnnotation(final int typeRef, final TypePath typePath,
                                                 final String descriptor, final boolean visible);
    public void visitAnnotableParameterCount(final int parameterCount, final boolean visible);
    AnnotationVisitor visitParameterAnnotation(final int parameter, final String descriptor, final boolean visible);
    public void visitAttribute(final Attribute attribute);

    public void visitCode();
    public void visitFrame(final int type,
                           final int numLocal, final Object[] local,
                           final int numStack, final Object[] stack);
    public void visitInsn(final int opcode);
    public void visitIntInsn(final int opcode, final int operand);
    public void visitVarInsn(final int opcode, final int var);
    public void visitTypeInsn(final int opcode, final String type);
    public void visitFieldInsn(final int opcode, final String owner, final String name, final String descriptor);
    public void visitMethodInsn(final int opcode, final String owner, final String name, final String descriptor,
                                final boolean isInterface);
    public void visitInvokeDynamicInsn(final String name, final String descriptor, final Handle bootstrapMethodHandle,
                                       final Object... bootstrapMethodArguments);
    public void visitJumpInsn(final int opcode, final Label label);
    public void visitLabel(final Label label);
    public void visitLdcInsn(final Object value);
    public void visitIincInsn(final int var, final int increment);
    public void visitTableSwitchInsn(final int min, final int max, final Label dflt, final Label... labels);
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels);
    public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions);


    public AnnotationVisitor visitInsnAnnotation(final int typeRef, final TypePath typePath,
                                                 final String descriptor, final boolean visible);
    public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type);
    public AnnotationVisitor visitTryCatchAnnotation(final int typeRef, final TypePath typePath,
                                                     final String descriptor, final boolean visible);
    public void visitLocalVariable(
        final String name,
        final String descriptor,
        final String signature,
        final Label start,
        final Label end,
        final int index);
    public AnnotationVisitor visitLocalVariableAnnotation(
        final int typeRef,
        final TypePath typePath,
        final Label[] start,
        final Label[] end,
        final int[] index,
        final String descriptor,
        final boolean visible);
    public void visitLineNumber(final int line, final Label start);
    public void visitMaxs(final int maxStack, final int maxLocals);
    public void visitEnd();
}
</div>

<p class="indented">
    <span class="text-key-point">These methods must be called in the following order</span>
    (with some additional constraints specified in the
    Javadoc of the <code>MethodVisitor</code> interface):
</p>

<div title="The methods of MethodVisitor class must be called in the following order" class="plaintext">
(visitParameter)*
[visitAnnotationDefault]
(visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation | visitTypeAnnotation | visitAttribute)*
[
    visitCode
    (
        visitFrame |
        visitXxxInsn |
        visitLabel |
        visitInsnAnnotation |
        visitTryCatchBlock |
        visitTryCatchAnnotation |
        visitLocalVariable |
        visitLocalVariableAnnotation |
        visitLineNumber
    )*
    visitMaxs
]
visitEnd.
</div>

<p class="indented">
    This means that <span class="text-key-point">annotations and attributes</span>, if any, <span class="text-key-point">must be visited first</span>,
    <span class="text-key-point">followed by the method's bytecode, for non abstract methods</span>.
    For these methods the code must be visited in sequential order,
    between exactly one call to <code>visitCode</code> and exactly one call to <code>visitMaxs</code>.
</p>

<p class="indented">
    The <code>visitCode</code> and <code>visitMaxs</code> methods can therefore
    be used to detect the start and end of the method’s bytecode in a sequence of events.
    Like for classes, the <code>visitEnd</code> method must be called last,
    and is used to detect the end of a method in a sequence of events.
</p>

<p class="indented">
    The <code>ClassVisitor</code> and <code>MethodVisitor</code> classes can be combined in order to generate complete classes:
</p>

<div title="" class="javacode">
ClassVisitor cv = ...;
cv.visit(...);
MethodVisitor mv1 = cv.visitMethod(..., "m1", ...);
mv1.visitCode();
mv1.visitInsn(...);
...
mv1.visitMaxs(...);
mv1.visitEnd();
MethodVisitor mv2 = cv.visitMethod(..., "m2", ...);
mv2.visitCode();
mv2.visitInsn(...);
...
mv2.visitMaxs(...);
mv2.visitEnd();
cv.visitEnd();
</div>

<h2>Three core Components</h2>

<p class="indented">
    ASM provides <span class="text-example">three core components</span> based on the <code>MethodVisitor</code> API to
    generate and transform methods:
</p>

<ul>
    <li>
        The <code>ClassReader</code> class <span class="text-example">parses the content of compiled methods</span> and
        <span class="text-example">calls the corresponding methods on the <code>MethodVisitor</code> objects</span>
        returned by the <code>ClassVisitor</code> passed as argument to its <code>accept</code> method.
    </li>
    <li>
        The <code>ClassWriter</code>'s <code>visitMethod</code> method returns an implementation of
        the <code>MethodVisitor</code> interface that builds compiled methods directly in binary form.
    </li>
    <li>
        The <code>MethodVisitor</code> class delegates all the method calls it receives to
        another <code>MethodVisitor</code> instance. It can be seen as an event filter.
    </li>
</ul>

<h2>ClassWriter options</h2>

<p class="indented">
    When you create a <code>ClassWriter</code>
    you can specify what must be automatically computed:
</p>

<ul>
    <li>
        with <code>new ClassWriter(0)</code> <span class="text-key-point">nothing is automatically computed</span>.
        You have to compute yourself <span class="text-example">the frames</span> and
        the <span class="text-example">local variables and operand stack sizes</span>.
    </li>
    <li>
        with <code>new ClassWriter(ClassWriter.COMPUTE_MAXS)</code>
        <span class="text-example">the sizes of the local variables and operand stack</span> parts are computed for you.
        You must still call <code>visitMaxs</code>, but you can use any arguments:
        they will be ignored and recomputed.
        With this option you still have to compute <span class="text-example">the frames</span> yourself.
    </li>
    <li>
        with <code>new ClassWriter(ClassWriter.COMPUTE_FRAMES)</code>
        <span class="text-key-point">everything is computed automatically</span>.
        You don’t have to call <code>visitFrame</code>,
        but you must still call <code>visitMaxs</code> (arguments will be ignored and recomputed).
    </li>
</ul>

<p class="indented">
    Using these options is convenient but this has a cost:
    <span class="text-example">the <code>COMPUTE_MAXS</code> option</span> makes a <code>ClassWriter</code> 10% slower,
    and using <span class="text-example">the <code>COMPUTE_FRAMES</code> option</span> makes it two times slower.
    This must be compared to the time it would take to compute this yourself:
    in specific situations there are often easier and faster algorithms for computing this,
    compared to the algorithm used in ASM, which must handle all cases.
</p>

<p class="indented">
    Note that <span class="text-key-point">if you choose to compute the frames yourself</span>,
    <span class="text-key-point">you can let the <code>ClassWriter</code> class do the compression step for you</span>.
    For this you just have to visit your uncompressed frames with <code>visitFrame(F_NEW, nLocals, locals, nStack, stack)</code>,
    where <code>nLocals</code> and <code>nStack</code> are the number of locals and the operand stack size,
    and <code>locals</code> and <code>stack</code> are arrays containing the corresponding.
</p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
<p class="indented"></p>
