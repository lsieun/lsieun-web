<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">Removing Attribute</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_asm_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<h2>Remove Debug Info</h2>

<div title="HelloWorld.java" class="javacode">
public class HelloWorld {
    public class InnerClass {
        //
    }

    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
</div>

<p class="indented">
    For example the following class adapter removes the information about <span class="text-example">outer and inner classes</span>,
    as well as <span class="text-example">the name of the source file</span> from which the class was compiled
    (the resulting class remains fully functional, because these elements are only used for debugging purposes).
    This is done by not forwarding anything in the appropriate <code>visitXxx</code> methods:
</p>

<div title="RemoveDebugClassAdapter.java" class="javacode">
import org.objectweb.asm.ClassVisitor;

public class RemoveDebugClassAdapter extends ClassVisitor {
    public RemoveDebugClassAdapter(int api, ClassVisitor cv) {
        super(api, cv);
    }

    @Override
    public void visitSource(String source, String debug) {
        // do nothing
    }

    @Override
    public void visitOuterClass(String owner, String name, String descriptor) {
        // do nothing
    }

    @Override
    public void visitInnerClass(String name, String outerName, String innerName, int access) {
        // do nothing
    }
}
</div>



<div title="App.java" class="javacode">
import lsieun.utils.FileUtils;
import lsieun.utils.ReadUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Opcodes;

public class App {
    public static void main(String[] args) {
        String relative_path = "sample/HelloWorld.class";
        String filepath = FileUtils.getFilePath(relative_path);
        byte[] bytes1 = ReadUtils.readByPath(filepath);

        //（1）构建ClassReader
        ClassReader cr = new ClassReader(bytes1);

        //（2）构建ClassWriter
        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);

        //（3）串连ClassVisitor
        // cv forwards all events to cw
        ClassVisitor cv = new RemoveDebugClassAdapter(Opcodes.ASM9, cw);

        //（4）两者进行结合
        cr.accept(cv, 0);

        //（5）重新生成Class
        byte[] bytes2 = cw.toByteArray();

        FileUtils.writeBytes(filepath, bytes2);
    }
}
</div>

<p class="indented">
    <span class="text-key-point">This strategy does not work for fields and methods</span>,
    because the <code>visitField</code> and <code>visitMethod</code> methods must return a result.
</p>
