<!-- 标题 -->
<h1 class="w3-center w3-padding-64 w3-tangerine"><span class="w3-tag w3-wide">JVM Architecture</span></h1>
<!-- 内容 -->

<div style="text-align: right">
    <a title="Table Of Content" href="/archive/java/java_classfile_index.html">TOC</a>
    <a href="javascript:void(0);" onclick="toggle_all_sub_note()">Toggle Commentary</a>
</div>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        原文章的内容来自<a class="external" href="https://dzone.com/articles/jvm-architecture-explained" target="_blank">DZone: The JVM Architecture Explained</a>
    </p>
</div>

<p>
    As shown in the following architecture diagram, the JVM is divided into three main subsystems:
</p>

<ol>
    <li>ClassLoader Subsystem</li>
    <li>Runtime Data Area</li>
    <li>Execution Engine</li>
</ol>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/jvm/jvm_architecture.png" alt="JVM Architecture Diagram"/>
</div>

<h2 onclick="$(this).next().toggle()">ClassLoader Subsystem</h2>

<div>
<p class="indented">
    Java's dynamic class loading functionality is handled by the ClassLoader subsystem. It loads, links. and initializes the class file when it refers to a class for the first time at runtime, not compile time.
</p>

<h3>Loading</h3>

<p class="indented">
    Classes will be loaded by this component. BootStrap ClassLoader, Extension ClassLoader, and Application ClassLoader are the three ClassLoaders that will help in achieving it.
</p>

<ol>
    <li><b>BootStrap ClassLoader</b> – Responsible for loading classes from the bootstrap classpath, nothing but <code>rt.jar</code>. Highest priority will be given to this loader.</li>
    <li><b>Extension ClassLoader</b> – Responsible for loading classes which are inside the <code>ext</code> folder (<code>jre\lib</code>).</li>
    <li><b>Application ClassLoader</b> –Responsible for loading Application Level Classpath, path mentioned Environment Variable, etc.</li>
</ol>

<p class="indented">
    The above ClassLoaders will follow Delegation Hierarchy Algorithm while loading the class files.
</p>

<h3>Linking</h3>

<ol>
    <li>
        <b>Verify</b> – Bytecode verifier will verify whether the generated bytecode is proper or not if verification fails we will get the verification error.
        <sub class="my_note" style="color:blue">笔记：验证class文件的格式是否正确</sub>
        <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
    </li>
    <li>
        <b>Prepare</b> – For all static variables memory will be allocated and assigned with default values.
        <sub class="my_note" style="color:blue">笔记：为class文件定义的static variable分配内存空间，并赋默认值。During the preparation phase, Java Virtual Machine implementations may also allocate memory for data structures that are intended to improve the performance of the running program. An example of such a data structure is a <b>method table</b>, which contains a pointer to the data for every method in a class, including those inherited from its superclasses. A method table enables an inherited method to be invoked on an object without a search of superclasses at the point of invocation.换一种说，Prepare是对自身内容的解析。</sub>
        <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
    </li>
    <li>
        <b>Resolve</b> – All original symbolic references are replaced with the memory references from Method Area.
        <sub class="my_note" style="color:blue">笔记：将class文件constant pool定义的symbolic references替换成直接的内存地址。换一种说法，Resolve是对自身之外的内容的解析。</sub>
        <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
    </li>
</ol>

<h3>Initialization</h3>

<p class="indented">
    This is the final phase of ClassLoading; here, all <b>static variables</b> will be assigned with the <b>original values</b>, and the <b>static block</b> will be executed.
</p>
</div>

<h2 onclick="$(this).next().toggle()">JVM Run-Time Data Areas</h2>

<div>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        要掌握各个内存区域，需要回答两个关键问题就可以了：
    </p>

    <ul>
        <li>第一问题，当前内存区域，存储的是什么数据？</li>
        <li>第二问题，当前内存区域，是每一个线程都有自己私有的一份，还是所有线程共享的区域？</li>
    </ul>
</div>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/jvm/jvm_runtime_memory.png" alt="JVM runtime memory"/>
</div>

<h3 onclick="$(this).next().toggle()">Run-time Constant Pool</h3>
<div>
<p class="indented">
    <b>Run-time constant pool</b> is created out of the <b>method area</b> and it is created by JVM when a class or interface is created.
</p>

<p class="indented">
    A <b>run-time constant pool</b> is a per-class or per-interface run-time representation of the <code>constant_pool</code> table in a <b>class</b> file.
    It contains several kinds of constants, ranging from numeric literals known at compile-time to method and field references that must be resolved at run-time.
</p>
</div>

<h3 onclick="$(this).next().toggle()">Method Area</h3>

<p class="indented">
    All the class-level data will be stored here, including static variables.
    There is only one method area per JVM, and it is a shared resource.
    In general, <b>method area</b> is a logical part of <b>heap area</b>. But that is left to the JVM implementers to decide.
</p>

<h3 onclick="$(this).next().toggle()">Heap Area</h3>

<p class="indented">
    All the Objects and their corresponding instance variables and arrays will be stored here.
    There is also one Heap Area per JVM.
    Since the Method and Heap areas share memory for multiple threads, the data stored is not thread-safe.
</p>

<h3 onclick="$(this).next().toggle()">JVM Stacks</h3>

<div>
<p class="indented">
    Each Java Virtual Machine <b>thread</b> has a private <b>Java Virtual Machine stack</b>, created at the same time as the thread.
    The stack area is thread-safe since it is not a shared resource.

</p>

<p>
    A <b>Java Virtual Machine stack</b> stores <b>frames</b>.
    For every method call, one entry will be made in the stack memory which is called Stack Frame.
    The Stack Frame is divided into three subentities:
</p>

<ul>
    <li><b>Local Variable Array</b> – Related to the method how many local variables are involved and the corresponding values will be stored here.</li>
    <li><b>Operand stack</b> – If any intermediate operation is required to perform, operand stack acts as runtime workspace to perform the operation.</li>
    <li><b>Frame data</b> – All symbols corresponding to the method is stored here. In the case of any exception, the catch block information will be maintained in the frame data.</li>
</ul>
</div>

<h3 onclick="$(this).next().toggle()">Program Counter (PC) Register</h3>

<div>
<p class="indented">
    A <b>program counter</b> (PC) Register is created every time a new thread is created.
    Each thread will have separate PC Registers, to hold the address of current executing instruction.
    Once the instruction is executed the PC register will be updated with the next instruction.
</p>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/classfile/program_counter_example.gif" alt="PC"/>
    <p>PC hold the address of current executing instruction</p>
</div>
</div>

<h3 onclick="$(this).next().toggle()">Native Method Stacks</h3>

<p class="indented">
    Native Method Stack holds native method information. For every thread, a separate native method stack will be created.
</p>

<h3 onclick="$(this).next().toggle()">Summing Up</h3>

<div>
<p>
    These six JVM run-time memory areas can be broadly classified into two groups,
</p>

<ul>
    <li>
        <b>Managed per-thread</b> – If the memory area is uniquely allocated for every single thread created. These data area are initialized on thread start and destroyed once the thread completes.
    </li>
    <li>
        <b>Shared with all threads</b> – If the memory area is common and can be accessed by all the threads. These are initialized when JVM is started and destroyed on shutdown.
    </li>
</ul>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/jvm/jvm_runtime_data_areas.png" alt="Java JVM Run-time Memory Areas"/>
</div>
</div>

</div>

<h2 onclick="$(this).next().toggle()">JVM Execution Engine</h2>

<div>
<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>
        ClassLoader Subsystem是为了把class文件加载进来，而Runtime Data Area是为加载进来的class文件、创建的各种object提供一个存储空间，而Execution Engine是在现有的“内存布局”的情况下去执行class文件里的代码。
    </p>
</div>

<p class="indented">
    The execution engine reads the Java Byte code in the unit of instruction.
    It is like a CPU executing the machine command one by one.
    Each command of the byte code consists of a 1-byte OpCode and additional Operand.
    The execution engine gets one OpCode and execute task with the Operand, and then executes the next OpCode.
    Execution engine mainly contain 2 parts.
</p>

<ol>
    <li>Interpreter</li>
    <li>JIT Compiler</li>
</ol>

<p class="indented">
    Whenever any java program is executing at the first time <b>interpreter</b> will comes into picture and
    it converts one by one byte code instruction into machine level instruction.
    <b>JIT compiler</b> (just in time compiler) will comes into picture from the second time onward
    if the same java program is executing and it gives the machine level instruction to the process which are available in the buffer memory.
    <b>The main aim of JIT compiler is to speed up the execution of java program</b>.
</p>

<h3>Interpreter</h3>

<p class="indented">
    It is responsible to read byte code and interpret into machine code (native code) and execute that machine code line by line.
    <b>The problem with interpret</b> is it interprets every time even some method invoked multiple times which effects performance of the system.
    To overcome this problem SUN people introduced JIT compilers in 1.1 V.
</p>

<h3>JIT Compiler</h3>

<p class="indented">
    The JIT compiler has been introduced to compensate for the disadvantages of the interpreter.
    <b>The main purpose of JIT compiler is to improve the performance</b>.
    Internally JIT compiler maintains a separate <b>count</b> for every method.
    Whenever JVM across any method call, first that method will be interpreted normally by the interpreter and
    JIT compiler increments the corresponding <b>count</b> variable.
</p>

<p class="indented">
    This process will be continued for every method once if any method count reaches thread hold value
    then JIT compiler identifies that method is a <b>repeatedly used method</b> (Hotspot) and
    immediately JIT compiler compiles that method and generates corresponding native code.
    Next time JVM come across that method call then JVM directly uses native code and executes it instead of interpreting once again,
    so that performance of the system will be improved.
    Threshold is varied from JVM to JVM.
    Some advanced JIT compilers will recompile generated native code
    if count reaches threshold value second time so that more optimized code will be generated.
</p>

<p class="indented">
    <b>Profiler</b> which is the part of JIT compiler is responsible to identify <b>Hotspot</b>  (Repeated Used Methods).
</p>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/jvm/jvm_execution_engine.png" alt="JVM Execution Engine"/>
    <p>
        JVM interprets total program line by line at least once. JIT compilation is applicable only for repeatedly invoked method but not for every method.
    </p>
</div>
</div>

<h2 onclick="$(this).next().toggle()">Method Area</h2>

<div>
    <div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
        <p>
            这里的内容来自《Inside the Java 2 Virtual Machine》的<a class="external" href="https://www.artima.com/insidejvm/ed2/jvmP.html" target="_blank">Chapter 5 The Java Virtual Machine</a>
        </p>
    </div>

    <p>
        For each type it loads, a Java Virtual Machine must store the following kinds of information in the <b>method area</b>:
    </p>

    <ul>
        <li>The fully qualified name of the type</li>
        <li>
            The fully qualified name of <b>the type's direct superclass</b> (unless the type is an interface or class <code>java.lang.Object</code>, neither of which have a superclass)
        </li>
        <li>Whether or not the type is a class or an interface</li>
        <li>The type's modifiers (some subset of <code>public</code>, <code>abstract</code>, <code>final</code>)</li>
        <li>An ordered list of the fully qualified names of any <b>direct superinterfaces</b></li>
        <li>The constant pool for the type</li>
        <li>Field information</li>
        <li>Method information</li>
    </ul>

    <p>
        In addition to the basic type information listed above, the virtual machine must also store for each loaded type:
    </p>

    <ul>
        <li>All <b>class (static) variables</b> declared in the type, except constants</li>
        <li>
            <b>A reference to class</b> <code>ClassLoader</code>
            <ul>
                <li>
                    For each type it loads, a Java Virtual Machine must keep track of whether or not the type was loaded via the primordial class loader or a class loader object.
                    For those types loaded via a class loader object, the virtual machine must store a reference to the class loader object that loaded the type.
                    This information is stored as part of the type's data in the method area.
                </li>
                <li>
                    The virtual machine uses this information during dynamic linking.
                    When one type refers to another type, the virtual machine requests the referenced type from the same class loader that loaded the referencing type.
                    This process of dynamic linking is also central to the way the virtual machine forms separate name spaces.
                    To be able to properly perform dynamic linking and maintain multiple name spaces,
                    the virtual machine needs to know what class loader loaded each type in its method area.
                </li>
            </ul>
        </li>
        <li>
            <b>A reference to class</b> <code>Class</code>
            <ul>
                <li>
                    An instance of class <code>java.lang.Class</code> is created by the Java Virtual Machine for every type it loads.
                    The virtual machine must in some way associate a reference to the <code>Class</code> instance for a type with <b>the type's data in the method area</b>.
                </li>
                <li>
                    Your Java programs can obtain and use references to <code>Class</code> objects.
                    <ul>
                        <li><code>Class.forName("java.lang.String");</code></li>
                        <li><code>obj.getClass();</code></li>
                    </ul>
                </li>
                <li>
                    Given a reference to a <code>Class</code> object, you can find out information about the type by invoking methods declared in class <code>Class</code>.
                    If you look at these methods, you will quickly realize that class <code>Class</code> gives the running application access to the information stored in the method area.
                </li>
            </ul>
        </li>
    </ul>
</div>

<h2 onclick="$(this).next().toggle()">Frame</h2>
<div>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p>在这部分内容中，我们主要是关注于local variable和operand stack这两个内存空间。对于local variable和operand stack，我们应该掌握什么呢？</p>
    <ul>
        <li>第一，在1个slot上，可以存储哪些数据？（slot是计算local variable和operand stack大小的单位，slot是一个抽象的概念，不同的JVM实现对于slot占用的byte大小也不同。）</li>
        <li>第二，local variable和operand stack，它们各自占多少slot单位的空间？两者都是在compile-time决定的。</li>
        <li>第三，local variable和operand stack，它们通过什么机制来实现的？local variable是通过“索引”来实现，而operand stack是通过出栈入栈来实现。</li>
    </ul>
</div>

<p class="indented">
    <b>Frames</b> are allocated from the <b>Java Virtual Machine stack</b>.
</p>

<p class="indented">
    A new frame is created each time a method is invoked.
    A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception).
    <sub class="my_note" style="color:blue">笔记：这里主要讲frame和method之间的关系。对于method的调用，会生成一个frame；当method执行结束，相应的frame会销毁掉。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/jvm/jvm_stack_for_each_thread.jpg" alt="The life cycle of a frame"/>
</div>

<p class="indented">
    Each <b>frame</b> has <b>its own array of local variables</b>, <b>its own operand stack</b>, and <b>a reference to the run-time constant pool</b> of the class of the current method.
</p>

<div class="w3-display-container w3-center">
    <img class="w3-image w3-center" src="/images/java/jvm/jvm_stack_a_frame.png" alt="Frames"/>
</div>

<p class="indented">
    The sizes of <b>the local variable array</b> and <b>the operand stack</b> are determined at <b>compile-time</b> and
    are supplied along with the code for the method associated with the frame.
</p>

<p class="indented">
    The stack frame has three parts: local variables, operand stack, and frame data.
</p>

<h3>Local Variables</h3>

<div class="w3-panel w3-pale-blue w3-leftbar w3-border-blue">
    <p><code>LocalVariableTable</code>属性，就是对Local Variables内存空间的描述信息。</p>
</div>

<p class="indented">
    Each frame contains an array of variables known as its <b>local variables</b>.
</p>

<p class="indented">
    <b>A single local variable</b> can hold a value of type <code>boolean</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>float</code>, <code>reference</code>, or <code>returnAddress</code>.
    <b>A pair of local variables</b> can hold a value of type <code>long</code> or <code>double</code>.
</p>

<p class="indented">
    <b>The length of the local variable array</b> of a frame is determined at compile-time and supplied in the binary representation of a class or interface along with the code for the method associated with the frame.
    <sub class="my_note" style="color:blue">笔记：local variable，它的整体长度，是在compile-time决定的。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    <b>Local variables are addressed by indexing.</b>
    The index of the first local variable is <b>zero</b>.
    An integer is considered to be an index into the local variable array if and only if that integer is between zero and one less than the size of the local variable array.
    <sub class="my_note" style="color:blue">笔记：local variable，取值和赋值，是通过索引来完成的。它的索引，是从0开始的。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    The Java Virtual Machine uses <b>local variables</b> to <b>pass parameters on method invocation</b>.
    On <b>class method invocation</b>, any parameters are passed in consecutive local variables starting from local variable <code>0</code>.
    On <b>instance method invocation</b>, local variable <code>0</code> is always used to pass a reference to the object
    on which the instance method is being invoked (<code>this</code> in the Java programming language).
    Any parameters are subsequently passed in consecutive local variables starting from local variable <code>1</code>.
    <sub class="my_note" style="color:blue">笔记：local variable，它的作用，是传递方法调用的参数。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    A value of type <code>long</code> or type <code>double</code> occupies <b>two consecutive local variables</b>.
    <b>Such a value may only be addressed using the lesser index</b>.
    For example, a value of type <code>double</code> stored in the local variable array at index <code>n</code> actually
    occupies the local variables with indices <code>n</code> and <code>n+1</code>;
    however, the local variable at index <code>n+1</code> cannot be loaded from. It can be stored into.
    However, doing so invalidates the contents of local variable <code>n</code>.
    <sub class="my_note" style="color:blue">笔记：local variable，它对于long和double类型的特殊处理。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<h3>Operand Stacks</h3>

<p class="indented">
    Each frame contains a last-in-first-out (LIFO) stack known as its <b>operand stack</b>.
</p>

<p class="indented">
    Each entry on the operand stack can hold a value of any Java Virtual Machine type, including a value of type <code>long</code> or type <code>double</code>.
</p>

<p class="indented">
    At any point in time, an operand stack has an associated depth,
    where a value of type <code>long</code> or <code>double</code> contributes <b>two units</b> to the depth
    and <b>a value of any other type</b> contributes <b>one unit</b>.
</p>

<p class="indented">
    <b>The maximum depth of the operand stack</b> of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame.
    <sub class="my_note" style="color:blue">笔记：operand stack，它的整体大小，是在compile-time决定的。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    <b>The operand stack is empty when the frame that contains it is created</b>.
    The Java Virtual Machine supplies instructions to load constants or values from <b>local variables</b> or <b>fields</b> onto the <b>operand stack</b>.
    Other Java Virtual Machine instructions take operands from the operand stack, operate on them, and push the result back onto the operand stack.
    <b>The operand stack is also used to prepare parameters to be passed to methods and to receive method results.</b>
    <sub class="my_note" style="color:blue">笔记：operand stack，它的刚开始的时候，是空的，不存在任何数据。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    For example, the <code>iadd</code> instruction adds two <code>int</code> values together.
    It requires that the <code>int</code> values to be added be the top two values of the operand stack, pushed there by previous instructions.
    Both of the <code>int</code> values are popped from <b>the operand stack</b>.
    They are added, and their sum is pushed back onto the operand stack.
    <sub class="my_note" style="color:blue">笔记：operand stack，这里以iadd进行举例。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    <b>Values from the operand stack must be operated upon in ways appropriate to their types</b>.
    It is not possible, for example, to push two <code>int</code> values and subsequently treat them as a <code>long</code>
    or to push two <code>float</code> values and subsequently add them with an <code>iadd</code> instruction.
    A small number of Java Virtual Machine instructions (the <code>dup</code> instructions and <code>swap</code>) operate on run-time data areas as raw values without regard to their specific types; these instructions are defined in such a way that they cannot be used to modify or break up individual values.
    These restrictions on operand stack manipulation are enforced through class file verification.
    <sub class="my_note" style="color:blue">笔记：operand stack，在使用的过程中，应保持value和opcode的类型一致。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>



<h3>Frame Data</h3>

<p class="indented">
    In addition to the <b>local variables</b> and <b>operand stack</b>, the Java stack frame includes data to support <b>constant pool resolution</b>, <b>normal method return</b>, and <b>exception dispatch</b>.
    This data is stored in the <b>frame data</b> portion of <b>the Java stack frame</b>.
</p>

<ul>
    <li>
        frame
        <ul>
            <li>local variables</li>
            <li>operand stack</li>
            <li>
                frame data
                <ul>
                    <li>constant pool resolution</li>
                    <li>normal method completion</li>
                    <li>abrupt method completion</li>
                </ul>
            </li>
        </ul>
    </li>
</ul>

<p class="indented">
    Many instructions in the Java virtual machine's instruction set refer to <b>entries in the constant pool</b>.
    <b>Some instructions</b> merely push constant values of type <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, or <code>String</code> from the constant pool onto the operand stack.
    <b>Some instructions</b> use constant pool entries to refer to classes or arrays to instantiate, fields to access, or methods to invoke.
    <b>Other instructions</b> determine whether a particular object is a descendant of a particular class or interface specified by a constant pool entry.
    <sub class="my_note" style="color:blue">笔记：这里围绕着frame data中的constant pool resolution展开。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    Whenever the Java virtual machine encounters any of the instructions that refer to an entry in the constant pool,
    it uses the frame data's pointer to the constant pool to access that information.
    <b>References to types, fields, and methods</b> in the constant pool <b>are initially symbolic</b>.
    When the virtual machine looks up a constant pool entry that refers to a class, interface, field, or method, that reference may still be symbolic.
    If so, <b>the virtual machine must resolve the reference at that time</b>.
    <sub class="my_note" style="color:blue">笔记：这里围绕着frame data中的constant pool resolution展开。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    Aside from <b>constant pool resolution</b>, the frame data must assist the virtual machine in <b>processing a normal or abrupt method completion</b>.
    <b>If a method completes normally</b> (by returning), the virtual machine must restore the stack frame of the invoking method.
    It must set the <code>pc</code> register to point to the instruction in the invoking method that follows the instruction that invoked the completing method.
    If the completing method returns a value, the virtual machine must push that value onto the operand stack of the invoking method.
    <sub class="my_note" style="color:blue">笔记：这里围绕着frame data中的normal method completion展开。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    The frame data must also contain some kind of reference to <b>the method's exception table</b>, which the virtual machine uses to process any exceptions thrown during the course of execution of the method.
    An <b>exception table</b>, defines <b>ranges</b> within the bytecodes of a method that are protected by catch clauses.
    Each entry in an exception table gives <b>a starting and ending position</b> of the range protected by a catch clause,
    an <b>index</b> into the constant pool that gives the exception class being caught,
    and <b>a starting position</b> of the catch clause's code.
    <sub class="my_note" style="color:blue">笔记：这里围绕着frame data中的abrupt method completion展开。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<div title="HelloWorld.java" hidden class="javacode">
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class HelloWorld {
    public void test() {
        try {
            FileInputStream fin = new FileInputStream("/path/to/file");
            int b = fin.read();
        } catch (FileNotFoundException e) {
            System.out.println("File Not Found Exception");
        } catch (IOException e) {
            System.out.println("IOException");
        }
    }
}
</div>

<div title="test:()V Code Attribute" hidden class="plaintext">
constant_pool_count='0037' (55)
constant_pool
    ......
    |006| CONSTANT_Class {Value='java/io/FileNotFoundException', HexCode='070025'}
    ......
    |010| CONSTANT_Class {Value='java/io/IOException', HexCode='07002B'}
    ......
    |016| CONSTANT_Utf8 {Value='Code', HexCode='010004436F6465'}
    ......
attributes_count='0001' (1)
attributes
--->|000| Code:
HexCode: 0010000000B10003000300000028BB0002591203B700044C2BB600053DA700184CB200071208B60009A7000C4CB2......
attribute_name_index='0010' (#16)
attribute_length='000000B1' (177)
max_stack='0003' (3)
max_locals='0003' (3)
code_length='00000028' (40)
code: BB0002591203B700044C2BB600053DA700184CB200071208B60009A7000C4CB2
0007120BB60009B1
exception_table_length='0002' (2)
exception_table[0] {
    start_pc='0000' (0)
    end_pc='000F' (15)
    handler_pc='0012' (18)
    catch_type='0006' (#6)
}
exception_table[1] {
    start_pc='0000' (0)
    end_pc='000F' (15)
    handler_pc='001E' (30)
    catch_type='000A' (#10)
}
attributes_count='0003' (3)
    LineNumberTable: 00110000002600090000000A000A000B000F00100012000C0013000D001B0010001E000E001F000F00270011
    LocalVariableTable: 00120000002A0004000A000500160017000100130008001800190001001F00080018001A000100000028001300140000
    StackMapTable: 001B0000000B00035207001C4B07001D08
</div>

<div title="test:()V Exception Table" hidden class="plaintext">
=== === ===  === === ===  === === ===
Method test:()V
=== === ===  === === ===  === === ===
max_stack = 3
max_locals = 3
code_length = 40
code = BB0002591203B700044C2BB600053DA700184CB200071208B60009A7000C4CB20007120BB60009B1
Exception Table:
from    to  target  type
   0    15      18  java/io/FileNotFoundException
   0    15      30  java/io/IOException
=== === ===  === === ===  === === ===
0000: new             #2   // BB0002     || java/io/FileInputStream
0003: dup                  // 59
0004: ldc             #3   // 1203       || /path/to/file
0006: invokespecial   #4   // B70004     || java/io/FileInputStream.&lt;init&gt;:(Ljava/lang/String;)V
0009: astore_1             // 4C
0010: aload_1              // 2B
0011: invokevirtual   #5   // B60005     || java/io/FileInputStream.read:()I
0014: istore_2             // 3D
0015: goto            24   // A70018
0018: astore_1             // 4C
0019: getstatic       #7   // B20007     || java/lang/System.out:Ljava/io/PrintStream;
0022: ldc             #8   // 1208       || File Not Found Exception
0024: invokevirtual   #9   // B60009     || java/io/PrintStream.println:(Ljava/lang/String;)V
0027: goto            12   // A7000C
0030: astore_1             // 4C
0031: getstatic       #7   // B20007     || java/lang/System.out:Ljava/io/PrintStream;
0034: ldc             #11  // 120B       || IOException
0036: invokevirtual   #9   // B60009     || java/io/PrintStream.println:(Ljava/lang/String;)V
0039: return               // B1
=== === ===  === === ===  === === ===
LocalVariableTable:
index  start_pc  length  name_and_type
    0         0      40  this:Lsample/HelloWorld;
    1        10       5  fin:Ljava/io/FileInputStream;
    1        19       8  e:Ljava/io/FileNotFoundException;
    1        31       8  e:Ljava/io/IOException;
</div>

<p class="indented">
    When a method throws an exception, the Java virtual machine uses <b>the exception table</b> referred to by the frame data to determine how to handle the exception.
    If the virtual machine finds a matching catch clause in the method's exception table, it transfers control to the beginning of that catch clause.
    If the virtual machine doesn't find a matching catch clause, the method completes abruptly.
    The virtual machine uses the information in the frame data to restore the invoking method's frame.
    It then rethrows the same exception in the context of the invoking method.
    <sub class="my_note" style="color:blue">笔记：这里围绕着frame data中的abrupt method completion展开。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>

<p class="indented">
    In addition to data to support <b>constant pool resolution</b>, <b>normal method return</b>, and <b>exception dispatch</b>,
    the stack frame may also include other information that is <b>implementation dependent</b>, such as data to support debugging.
    <sub class="my_note" style="color:blue">笔记：这里是说frame data中，可能还包含一些与具体implementation相关的数据。</sub>
    <img src="/images/note.png" onclick="toggle_paragraph_sub_note(this)"/>
</p>
<p class="indented"></p>
</div>

<h2>References</h2>

<ul>
    <li><a class="external" href="https://www.artima.com/insidejvm/ed2/jvmP.html" target="_blank">《Inside the Java 2 Virtual Machine》 Chapter 5 The Java Virtual Machine</a></li>
    <li><a class="external" href="https://dzone.com/articles/jvm-architecture-explained" target="_blank">DZone: The JVM Architecture Explained</a></li>
    <li><a class="external" href="https://javapapers.com/core-java/java-jvm-run-time-data-areas/" target="_blank">Java JVM Run-time Data Areas</a></li>
    <li><a class="external" href="http://www.herongyang.com/JVM/Stack-Overflow-What-Is-JVM-Stack.html" target="_blank">What Is JVM Stack?</a></li>
    <li><a class="external" href="https://indrabasak.github.io/java-runtime-memory/" target="_blank">Memories of a Java Runtime</a></li>
    <li><a class="external" href="https://www.waytoeasylearn.com/learn/execution-engine/" target="_blank">Execution Engine</a></li>
</ul>